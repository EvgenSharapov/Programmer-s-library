-- MySQL dump 10.13  Distrib 8.0.40, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: questions
-- ------------------------------------------------------
-- Server version	8.0.40

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `topic_library`
--

DROP TABLE IF EXISTS `topic_library`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `topic_library` (
  `id` int NOT NULL AUTO_INCREMENT,
  `themes` varchar(255) DEFAULT NULL,
  `content` text,
  `topic_area` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=179 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `topic_library`
--

LOCK TABLES `topic_library` WRITE;
/*!40000 ALTER TABLE `topic_library` DISABLE KEYS */;
INSERT INTO `topic_library` VALUES (18,'В чем разница между checked и unchecked исключениями',' <p class=\"card-text\"><p>Исключения (exceptions) важная часть обработки ошибок. Есть две основные категории: проверяемые (checked) и непроверяемые (unchecked).</p>\n \n <p><strong>Проверяемые исключения (Checked Exceptions):</strong></p>\n \n <ul>\n 	<li>Должны быть явно обработаны в коде с помощью блока <strong>`try-catch`</strong> или должны быть указаны в сигнатуре метода с помощью ключевого слова<strong> `throws`</strong>.&nbsp;</li>\n 	<li>Они представляют ошибки, которые могут возникнуть во время выполнения программы и которые во многих случаях программист может предвидеть и обработать. Например, ошибка чтения файла, когда файл не существует.</li>\n 	<li>Примеры классов проверяемых исключений включают <strong>`IOException`</strong>, <strong>`FileNotFoundException`</strong>, <strong>`ClassNotFoundException`</strong> и другие.</li>\n </ul>\n \n <p>Пример:</p>\n \n <pre>\n <code class=\"language-java\">try {\n     FileInputStream file = new FileInputStream(\"non_existent_file.txt\");\n } catch (FileNotFoundException e) {\n     e.printStackTrace();\n }</code></pre>\n \n <p>В этом примере <strong>`FileNotFoundException`</strong> является проверяемым исключением, и его необходимо обрабатывать в блоке <strong>`try-catch`</strong>.</p>\n \n <p><strong>Непроверяемые исключения (Unchecked Exceptions):</strong></p>\n \n <ul>\n 	<li>Не требуют обязательной обработки в коде. Они обычно возникают из-за ошибок программирования, таких как деление на ноль или доступ к элементу за пределами массива.</li>\n 	<li>К ним относятся ошибки времени выполнения (RuntimeException) и ошибки (Error).&nbsp;</li>\n 	<li>Примеры включают <strong>`NullPointerException`</strong>, <strong>`IndexOutOfBoundsException`</strong>, <strong>`ArithmeticException`</strong> и другие.</li>\n </ul>\n \n <p>Пример:</p>\n \n <pre>\n <code class=\"language-java\">int result = 10 / 0; // Приводит к ArithmeticException</code></pre>\n \n <p>Здесь <strong>`ArithmeticException`</strong> является непроверяемым исключением, вызванным делением на ноль.</p>\n \n <p><strong>Почему разделение на checked и unchecked?</strong><br />\n Разделение позволяет управлять потенциальными ошибками, которые могут быть исправлены, и отличать их от ошибок времени выполнения, которые чаще всего являются результатом ошибок в коде. Это способствует написанию более надежного и устойчивого к ошибкам кода.</p></p>\n                         \n                         \n                     </div>\n                 </div>\n             </div>\n             \n             <div class=\"row\">\n                 <div class=\"card mb-3 col\" >\n                     <div class=\"card-body\">\n                         <p class=\"card-text\"><p>В Java все исключения делятся на два типа:</p>\n \n <ul>\n 	<li><strong>checked (контролируемые/проверяемые исключения)</strong>&nbsp;должны обрабатываться блоком&nbsp;<code>catch</code>&nbsp;или описываться в заголовке метода (например,&nbsp;<code>throws IOException</code>). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;</li>\n 	<li><strong>unchecked (неконтролируемые/непроверяемые исключения)</strong>, к которым относятся ошибки&nbsp;<code>Error</code>&nbsp;(например,&nbsp;<code>OutOfMemoryError</code>), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом&nbsp;<code>RuntimeException</code>&nbsp;и его наследниками (например,&nbsp;<code>NullPointerException</code>), которые могут не обрабатываться блоком&nbsp;<code>catch</code>&nbsp;и не быть описанными в заголовке метода.</li>\n </ul></p>\n                         \n                         \n                     </div>\n                 </div>\n             </div>',1),(19,'Иерархия исключений','<p class=\"card-text\"><p>Иерархия исключений организована в виде дерева наследования, где все классы исключений являются потомками класса <strong>Throwable</strong>. Он делится на два основных подкласса: <strong>Error</strong> и<strong> Exception</strong>.</p>\n\n<p>1. <strong>Throwable</strong><br />\nОт него напрямую наследуются классы <strong>Error</strong> и <strong>Exception</strong>. Этот класс содержит методы для получения сообщения об ошибке, локализованного сообщения, причины исключения и стека вызовов, а также методы для подавления исключений и работы со стеком вызовов.</p>\n\n<p>2.<strong> Error</strong><br />\nError описывает серьёзные ошибки, возникающие на уровне виртуальной машины и библиотеки языка, из-за которых приложение обычно не может восстановиться. Примеры включают <strong>OutOfMemoryError</strong> и <strong>StackOverflowError</strong>. Ошибки этого типа обычно не предназначены для обработки приложением.</p>\n\n<p>3. <strong>Exception</strong><br />\nЭтот класс и подклассы описывают исключения, с которыми приложение может и должно справиться. Делится на две большие категории: проверяемые(<strong>checked exceptions</strong>) и непроверяемые исключения (<strong>unchecked exceptions</strong>).</p>\n\n<p>Проверяемые исключения<br />\nТребуют обязательной обработки в блоке<strong> try-catch</strong> или должны быть объявлены в сигнатуре метода с помощью<strong> throws</strong>. Они бозначают условия, с которыми приложение может предвидеть и справиться. Примеры включают <strong>IOException</strong>, <strong>FileNotFoundException</strong> и <strong>ClassNotFoundException</strong>.</p>\n\n<p>Непроверяемые исключения<br />\nЯвляются непроверяемыми исключениями. Они обозначают ошибки, такие как неверное приведение типов (<strong>ClassCastException</strong>), обращение по нулевой ссылке (<strong>NullPointerException</strong>) и выход за пределы массива (<strong>ArrayIndexOutOfBoundsException</strong>). Эти исключения не требуют обязательной обработки в блоке<strong> try-catch</strong>.</p>\n\n<p>Иерархия исключений обеспечивает структурированный и гибкий способ обработки ошибок и исключительных ситуаций в приложениях. Позволяет различать серьёзные проблемы системного уровня, с которыми приложение не может справиться.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Исключения делятся на несколько классов, но все они имеют общего предка &mdash; класс&nbsp;<code>Throwable</code>, потомками которого являются классы&nbsp;<code>Exception</code>&nbsp;и&nbsp;<code>Error</code>.</p>\n\n<p><strong>Ошибки (Errors)</strong>&nbsp;представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.</p>\n\n<p><strong>Исключения (Exceptions)</strong>&nbsp;являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(20,'Что такое ООП','<p class=\"card-text\"><p>Объектно-ориентированное программирование (ООП) &mdash; это парадигма, основанная на концепции &quot;объектов&quot;, которые могут содержать данные в виде полей (часто называемых атрибутами или свойствами) и код в виде процедур (часто называемых методами). ООП фокусируется на использовании объектов для моделирования реальных или абстрактных сущностей, интересующих в процессе разработки программного обеспечения, облегчая тем самым разработку и поддержку программ.</p>\n\n<p>Основные принципы:</p>\n\n<p>1. <strong>Инкапсуляция</strong> &mdash; это сокрытие внутренних деталей реализации объекта от внешнего мира. Только сам объект управляет своим состоянием, внешние объекты взаимодействуют с ним через методы. Это позволяет упростить интерфейсы взаимодействия между компонентами и улучшить модульность.</p>\n\n<p>2. <strong>Наследование</strong> &mdash; механизм, с помощью которого один класс (дочерний класс) может наследовать свойства и методы другого класса (родительского класса), потенциально переопределяя некоторые из них. Это способствует повторному использованию кода и иерархической организации классов.</p>\n\n<p>3. <strong>Полиморфизм</strong> &mdash; способность объектов с одинаковым интерфейсом предоставлять различную реализацию. Это позволяет одному и тому же коду работать с объектами разных типов.</p>\n\n<p>4. <strong>Абстракция</strong> &mdash; процесс выделения существенных характеристик объекта, исключая несущественные. Это помогает сосредоточиться на том, что объект делает, а не на том, как он это делает.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">class Животное {\n    void есть() {\n        System.out.println(\"Животное ест\");\n    }\n}\n\nclass Кот extends Животное {\n    void есть() {\n        System.out.println(\"Кот ест рыбу\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Животное моеЖивотное = new Кот();\n        моеЖивотное.есть(); // Выведет \"Кот ест рыбу\", демонстрируя полиморфизм\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`Кот` </strong>наследует поведение от <strong>`Животное`</strong> и переопределяет метод <strong>`есть`</strong>, демонстрируя наследование и полиморфизм. Инкапсуляция и абстракция также затрагиваются, поскольку мы взаимодействуем с объектами через их поведение, не заботясь о внутреннем устройстве.</p>\n\n<p>Объектно-ориентированное программирование &mdash; это подход к разработке программ, который использует &quot;объекты&quot; &mdash; сущности с данными и методами для моделирования реального или абстрактного мира. Это помогает сделать код более модульным, легко расширяемым и поддерживаемым.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Объектно-ориентированное программирование (ООП)</strong>&nbsp;&mdash; методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.</p>\n\n<ul>\n	<li>объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;</li>\n	<li>каждый объект является экземпляром определенного класса</li>\n	<li>классы образуют иерархии.</li>\n</ul>\n\n<p>Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.</p>\n\n<p>Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.</p></p>\n                        \n    \n                    </div>\n                </div>\n            </div>',0),(21,'Методы в классе Object','<p class=\"card-text\"><p><strong>Object</strong> - суперкласс для всех классов. Все объекты, включая массивы, наследуют методы этого класса. Они предоставляют функции, которые доступны для любого объекта. Вот основные методы:</p>\n\n<p>1. <strong>`clone()`</strong> - создает и возвращает копию объекта. Метод защищенный, поэтому его можно вызвать только внутри класса объекта или в классах потомках.</p>\n\n<p>2. <strong>`equals(Object obj)`</strong> - определяет равенство между двумя объектами. По умолчанию, этот метод сравнивает ссылки на объекты.</p>\n\n<p>3.<strong> `finalize()` </strong>- вызывается перед удалением объекта сборщиком мусора. Метод устарел.</p>\n\n<p>4.<strong> `getClass()`</strong> - возвращает Class, который представляет класс данного объекта. Можно использовать для получения имени во время выполнения.</p>\n\n<p>5. <strong>`hashCode()` </strong>- возвращает хеш-код, который используется для оптимизации хранения в структурах данных.</p>\n\n<p>6. <strong>`notify()`</strong> - пробуждает один поток, который ожидает на объекте (вызвавший wait()). Этот метод должен вызываться в синхронизированном контексте.</p>\n\n<p>7. <strong>`notifyAll()`</strong> - пробуждает все ожидающие потоки. Должен вызываться в синхронизированном контексте.</p>\n\n<p>8. <strong>`toString()`</strong> - возвращает строковое представление. По умолчанию, возвращает класс и хеш-код, но часто переопределяется для предоставления более информативного представления.</p>\n\n<p>9. <strong>`wait()`</strong> - заставляет текущий поток ожидать, пока другой поток не вызовет <strong>notify()</strong> или <strong>notifyAll()</strong>. Существуют перегруженные версии <strong>wait(long timeout)</strong> и <strong>wait(long timeout, int nanos)</strong>, позволяющие указать максимальное время ожидания.</p>\n\n<p>Эти методы предоставляют основу для механизмов, таких как сравнение объектов, их клонирование, уведомление и ожидание в многопоточных средах, а также для работы с хеш-таблицами. Играют важную роль в проектировании и реализации Java-программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>public boolean equals(Object obj)</code>&nbsp;&ndash; служит для сравнения объектов по значению;</p>\n\n<p><code>int hashCode()</code>&nbsp;&ndash; возвращает hash код для объекта;</p>\n\n<p><code>String toString()</code>&nbsp;&ndash; возвращает строковое представление объекта;</p>\n\n<p><code>Class getClass()</code>&nbsp;&ndash; возвращает класс объекта во время выполнения;</p>\n\n<p><code>protected Object clone()</code>&nbsp;&ndash; создает и возвращает копию объекта;</p>\n\n<p><code>void notify()</code>&nbsp;&ndash; возобновляет поток, ожидающий монитор;</p>\n\n<p><code>void notifyAll()</code>&nbsp;&ndash; возобновляет все потоки, ожидающие монитор;</p>\n\n<p><code>void wait()</code>&nbsp;&ndash; остановка вызвавшего метод потока до момента пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>void wait(long timeout)</code>&nbsp;&ndash; остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>void wait(long timeout, int nanos)</code>&nbsp;&ndash; остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>protected void finalize()</code>&nbsp;&ndash; может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(22,'Иерархия коллекций','<p class=\"card-text\"><p>Иерархия коллекций &mdash; это набор интерфейсов и классов, которые предоставляют общие структуры данных, такие как списки, множества и карты. Находится в пакете `java.util` и разработана для работы с группами объектов.</p>\n\n<p><strong>Основные интерфейсы</strong></p>\n\n<p><strong>Collection Interface:</strong> Корневой интерфейс иерархии коллекций. Определяет методы, такие как <strong>`add()`</strong>, <strong>`remove()`</strong>,<strong> `size()`</strong>, <strong>`isEmpty()`</strong> и <strong>`iterator()`</strong>, которые должны быть реализованы всеми коллекциями.</p>\n\n<ul>\n	<li><strong>List Interface:</strong> Представляет упорядоченную коллекцию. Элементы в списке могут быть доступны по индексам. Допускает дублирование элементов. Реализации включают<strong> `ArrayList`</strong>, <strong>`LinkedList` </strong>и <strong>`Vector`</strong>.</li>\n</ul>\n\n<p>&nbsp;&nbsp;</p>\n\n<ul>\n	<li><strong>Set Interface:</strong> Набор уникальных элементов. Не допускает дублирования элементов. Реализации включают<strong> `HashSet`</strong>, <strong>`LinkedHashSet`</strong> и <strong>`TreeSet`</strong>.</li>\n	<li><strong>Queue Interface:</strong> Для работы с коллекциями, используемыми для хранения элементов перед обработкой. Поддерживает операции вставки, извлечения и инспекции.<strong> `LinkedList`</strong> реализует как <strong>`List`</strong>, так и <strong>`Queue`</strong>. Также есть <strong>`PriorityQueue` </strong>для элементов, которые должны обрабатываться в порядке приоритета.</li>\n</ul>\n\n<p><strong>Map Interface: </strong>Не наследуется от <strong>`Collection`</strong> интерфейса. Описывает структуру для хранения пар ключ/значение. Ключи уникальны, а значения могут дублироваться. Реализации включают <strong>`HashMap`</strong>, <strong>`LinkedHashMap`</strong>, <strong>`TreeMap`</strong> и <strong>`Hashtable`</strong>.</p>\n\n<p><strong>Особенности классов</strong></p>\n\n<ul>\n	<li><strong>ArrayList:</strong> Динамический массив для хранения элементов, который автоматически расширяется. Предлагает быстрый доступ к элементам по индексу.</li>\n	<li><strong>LinkedList: </strong>Двусвязный список, который обеспечивает эффективное добавление/удаление элементов. Может использоваться как список и очередь.</li>\n	<li><strong>HashSet:</strong> Использует хеш-таблицу для хранения уникальных элементов. Не гарантирует порядок элементов.</li>\n	<li><strong>LinkedHashSet:</strong> Расширяет <strong>`HashSet`</strong>, сохраняя порядок вставки элементов.</li>\n	<li><strong>TreeSet:</strong> Хранит элементы в отсортированном и восходящем порядке. Использует красно-черное дерево.</li>\n	<li><strong>HashMap:</strong> Хеш-таблица для хранения пар ключ/значение. Не поддерживает упорядоченность ключей или значений.</li>\n</ul></p>',7),(23,'Что такое SOLID',' <p class=\"card-text\"><p>SOLID &mdash; это акроним, представляющий пять основных принципов ООП и дизайна, направленных на повышение гибкости, масштабируемости и поддерживаемости ПО. Они помогает избежать проблемы с проектированием, такие как жесткая зависимость между компонентами программы и сложности в внесении изменений или добавлении новых функций.</p>\n\n<p>1. <strong>Принцип единственной ответственности (SRP): </strong>Подчеркивает важность разделения функциональности, чтобы каждый класс выполнял только одну задачу.</p>\n\n<pre>\n<code class=\"language-java\">   class UserSettings {\n       void changeEmail(User user) {\n           if(checkAccess(user)) {\n               // Изменение email пользователя\n           }\n       }\n\n       boolean checkAccess(User user) {\n           // Проверка прав доступа\n           return true;\n       }\n   }</code></pre>\n\n<p>&nbsp; &nbsp;Здесь класс <strong>`UserSettings` </strong>нарушает SRP, если бы в нем также были методы для управления пользователями. Лучше вынести метод <strong>`checkAccess`</strong> в отдельный класс.</p>\n\n<p>2. <strong>Принцип открытости/закрытости (OCP):</strong>&nbsp;Можно добавлять новую функциональность, не изменяя существующий код.<br />\n&nbsp; &nbsp;<br />\n3. <strong>Принцип подстановки Лисков (LSP):</strong> Классы-наследники должны дополнять, а не изменять поведение базовых классов.</p>\n\n<p>4. <strong>Принцип разделения интерфейса (ISP):</strong> Этот принцип ведет к созданию узкоспециализированных интерфейсов, вместо одного &quot;толстого&quot; интерфейса.</p>\n\n<p>5. <strong>Принцип инверсии зависимостей (DIP):</strong> Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций. Этот принцип направлен на уменьшение зависимостей между модулями программы.</p>\n\n<p>SOLID принципы направлены на создание гибкой, масштабируемой архитектуры, которая легко поддается изменениям и развитию. Используя эти принципы, можно создавать системы, которые легче понимать, поддерживать и расширять.</p></p>',6),(24,'Как организована HashMap','<p class=\"card-text\"><p><strong>`HashMap`</strong> &mdash; это структура данных, которая использует хеш-таблицу для хранения пар &quot;ключ-значение&quot;. Gозволяет выполнять операции вставки, удаления и поиска элементов с почти постоянным временем выполнения, что делает её очень эффективной для определённых задач. Вот как она организована:</p>\n\n<p><strong>Внутреннее устройство</strong></p>\n\n<p>1. <strong>Хеш-функция: </strong>Ключи хранятся с использованием хеш-функции, которая преобразует ключ в индекс массива. Этот индекс используется для хранения значения в массиве. Она должна равномерно распределять ключи по индексам массива, чтобы минимизировать коллизии.</p>\n\n<p>2. <strong>Массив бакетов (корзин):</strong> Внутри, она состоит из массива бакетов, где каждый бакет представляет собой &quot;корзину&quot;, которая может хранить одну или более пар &quot;ключ-значение&quot;. При добавлении новой пары &quot;ключ-значение&quot;, хеш-функция вычисляет индекс бакета для хранения значения на основе хеш-кода ключа.</p>\n\n<p>3. <strong>Связный список или дерево:</strong> В случае коллизии, когда два разных ключа имеют одинаковый хеш-код и попадают в один и тот же бакет, <strong>`HashMap`</strong> использует структуру данных в виде связного списка или дерева для хранения и разрешения коллизий. После определённого порога коллизий, список преобразуется в дерево для улучшения производительности поиска в этом бакете.</p>\n\n<p><strong>Работа</strong></p>\n\n<ul>\n	<li><strong>Вставка:</strong> Для вставки новой пары &quot;ключ-значение&quot;, сначала вычисляется хеш-код ключа, затем используется хеш-функция для определения индекса бакета. Если в бакете уже есть элементы, происходит проверка на наличие ключа с таким же хеш-кодом. Если такой ключ найден, его значение обновляется. Если ключ уникален, пара добавляется в бакет.</li>\n	<li><strong>Поиск:</strong> Поиск значения по ключу также начинается с вычисления хеш-кода ключа, определения индекса бакета и последующего поиска в связном списке или дереве этого бакета.</li>\n	<li><strong>Удаление:</strong> Удаление пары &quot;ключ-значение&quot; происходит аналогично поиску: сначала находится бакет, затем в нём ищется и удаляется элемент.</li>\n</ul>\n\n<p><strong>Расширение</strong></p>\n\n<p>Когда фактор заполнения <strong>`HashMap` </strong>превышает определённый порог, происходит автоматическое расширение массива бакетов и перехеширование всех элементов для равномерного распределения по новому массиву бакетов. Это обеспечивает высокую производительность `<strong>HashMap`</strong> даже при большом количестве элементов.</p>\n\n<p><strong>`HashMap`</strong> &mdash; это мощная и эффективная структура данных для хранения и быстрого доступа к данным через ключи. Благодаря использованию хеш-таблиц, <strong>`HashMap`</strong> обеспечивает быстрые операции вставки, поиска и удаления. Разрешение коллизий с помощью связных списков или деревьев и автоматическое расширение помогают поддерживать производительность на высоком уровне.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>HashMap</code>&nbsp;состоит из &laquo;корзин&raquo; (bucket). С технической точки зрения &laquo;корзины&raquo; &mdash; это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары &laquo;ключ-значение&raquo;, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.</p></p>\n                        ',7),(25,'Чем отличаются LinkedList и ArrayList','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`LinkedList`</strong> и<strong> `ArrayList`</strong> являются двумя разными реализациями интерфейса <strong>`List`</strong>, предназначенные для работы со списками объектов. Они имеют различные внутренние структуры данных, что влияет на их производительность в разных операциях.</p>\n\n<p><strong>ArrayList </strong>основан на динамическом массиве. Его элементы хранятся в массиве, размер которого автоматически увеличивается, когда количество элементов в списке превышает его емкость.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li><strong>Быстрый доступ к элементам:</strong> Доступ к любому элементу по индексу выполняется за константное время \\(O(1)\\), так как внутренне используется массив.</li>\n	<li><strong>Меньше занимаемого места</strong>&nbsp;(по сравнению с <strong>`LinkedList`</strong>), если список не изменяется часто, так как <strong>`ArrayList`</strong> не хранит ссылки на предыдущий и следующий элементы.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><strong>Добавление и удаление элементов: </strong>Операции добавления и удаления элементов могут быть медленнее, особенно если операции выполняются в начале списка, так как это требует сдвига всех последующих элементов.</li>\n	<li><strong>Потребление памяти при росте списка: </strong>При увеличении размера списка<strong> `ArrayList`</strong> должен создать новый, больший массив и скопировать в него элементы из старого, что может быть ресурсоемкой операцией.</li>\n</ul>\n\n<p><strong>LinkedList </strong>реализует двусвязный список, где каждый элемент списка содержит ссылки на предыдущий и следующий элементы в списке.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li><strong>Эффективное добавление и удаление: </strong>Добавление и удаление элементов выполняется за константное время \\(O(1)\\), так как не требуется сдвиг элементов. Достаточно изменить ссылки соседних элементов.</li>\n	<li><strong>Гибкость:</strong> <strong>`LinkedList`</strong> может использоваться как список, двусвязный список, стек или очередь.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><strong>Медленный доступ к элементам:</strong> Доступ к элементам по индексу требует времени \\(O(n)\\) в худшем случае, так как приходится проходить список от начала или конца до нужного элемента.</li>\n	<li><strong>Большее потребление памяти: </strong>Каждый элемент списка хранит не только данные, но и две ссылки на предыдущий и следующий элементы, что увеличивает общее потребление памяти.</li>\n</ul>\n\n<p>Выбор между LinkedList и ArrayList зависит от конкретных требований к производительности приложения:</p>\n\n<p><strong>Используйте `ArrayList`:</strong></p>\n\n<ul>\n	<li>&nbsp;Если в приоритете быстрый доступ к элементам по индексу.</li>\n	<li>&nbsp;Если операции добавления и удаления элементов выполняются преимущественно в конце списка или не являются основной операцией.</li>\n</ul>\n\n<p><strong>Используйте `LinkedList`:</strong></p>\n\n<ul>\n	<li>&nbsp;Если приложение интенсивно добавляет и удаляет элементы, особенно в начале или середине списка.</li>\n	<li>&nbsp;Если нужны функциональные возможности двусвязного списка или необходимо реализовать структуры данных, такие как стеки и очереди.</li>\n</ul>\n\n<p>Выбор между этими двумя структурами данных должен базироваться на их производительностных характеристиках в контексте конкретного использования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>ArrayList</code>&nbsp;это список, реализованный на основе массива, а&nbsp;<code>LinkedList</code>&nbsp;&mdash; это классический двусвязный список, основанный на объектах с ссылками между ними.</p>\n\n<p><code>ArrayList</code>:</p>\n\n<ul>\n	<li>доступ к произвольному элементу по индексу за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>;</li>\n	<li>доступ к элементам по значению за&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>вставка в конец в среднем производится за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>;</li>\n	<li>удаление произвольного элемента из списка занимает значительное время т. к. при этом все элементы, находящиеся &laquo;правее&raquo; смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);</li>\n	<li>вставка элемента в произвольное место списка занимает значительное время т. к. при этом все элементы, находящиеся &laquo;правее&raquo; смещаются на одну ячейку вправо;</li>\n	<li>минимум накладных расходов при хранении.</li>\n</ul>\n\n<p><code>LinkedList</code>:</p>\n\n<ul>\n	<li>на получение элемента по индексу или значению потребуется&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>но доступ к первому и последнему элементу списка всегда осуществляется за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>&nbsp;&mdash; ссылки постоянно хранятся на первый и последний элемент;</li>\n	<li>на добавление и удаление в начало или конец списка потребуется&nbsp;<em>константное</em>&nbsp;<em>O(1)</em>;</li>\n	<li>вставка или удаление в/из произвольного место&nbsp;<em>константное</em>&nbsp;<em>O(1)</em>;</li>\n	<li>но поиск позиции вставки и удаления за&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</li>\n</ul>\n\n<p>В целом,&nbsp;<code>LinkedList</code>&nbsp;в абсолютных величинах проигрывает&nbsp;<code>ArrayList</code>&nbsp;и по потребляемой памяти, и по скорости выполнения операций.&nbsp; &nbsp;<code>LinkedList</code>&nbsp;предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(26,'Различие между интерфейсом и абстрактным классом',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс и абстрактный класс используются для достижения абстракции, но между ними существуют ключевые различия, связанные с их использованием и целями.</p>\n\n<p><strong>Интерфейс</strong></p>\n\n<p>Это контракт или соглашение, которое класс может реализовать. Определяют методы без их реализаций, оставляя классам, которые их реализуют, определять конкретные действия. В Java 8 и более поздних версиях интерфейсы могут содержать статические методы с реализацией и методы по умолчанию, которые имеют реализацию. Класс может реализовывать несколько интерфейсов, что поддерживает множественное наследование поведения.</p>\n\n<p><strong>Абстрактный класс</strong></p>\n\n<p>Это класс, не предназначенный для создания экземпляров, который может содержать как абстрактные методы (без реализации), так и методы с реализацией. Предназначен для того, чтобы быть базовым классом, от которого будут наследовать другие классы и реализовывать абстрактные методы. Класс может наследовать только один абстрактный класс, что ограничивает множественное наследование.</p>\n\n<p><strong>Основные различия</strong></p>\n\n<p>1. <strong>Наследование: </strong>Класс может реализовать множество интерфейсов, но наследовать только один абстрактный класс.<br />\n2. <strong>Методы: </strong>Интерфейсы могут содержать только объявления методов (до Java 8) и статические методы, а также методы по умолчанию (начиная с Java 8), тогда как абстрактные классы могут содержать как абстрактные методы, так и методы с реализацией.<br />\n3. <strong>Конструкторы:</strong> Абстрактные классы могут иметь конструкторы, интерфейсы &mdash; нет.<br />\n4. <strong>Поля:</strong> В интерфейсах все поля являются публичными, статическими и финальными по умолчанию, а абстрактные классы могут содержать поля с любым уровнем доступа и без ограничений на статичность или финализацию.<br />\n5. <strong>Использование:</strong> Абстрактные классы используются, когда несколько классов имеют общую реализацию, но также и свою уникальную реализацию некоторых методов. Интерфейсы идеально подходят для определения общего контракта для разнородных классов, которые не обязательно связаны друг с другом через иерархию наследования.</p>\n\n<p>Выбор между интерфейсом и абстрактным классом зависит от конкретной ситуации в проектировании программы. Если нужно определить общий контракт для классов, которые могут принадлежать к разным иерархиям наследования, следует использовать интерфейс. Если же требуется общая реализация для схожих классов, то лучше подойдет абстрактный класс.</p></p>\n                                               \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><ul>\n	<li>В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</li>\n	<li>Абстрактные классы используются только тогда, когда присутствует тип отношений &laquo;is a&raquo; (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</li>\n	<li>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как&nbsp;<code>public abstract</code>&nbsp;или (начиная с Java 8)&nbsp;<code>default</code>&nbsp;- методами с реализацией по-умолчанию, а поля -&nbsp;<code>public static final</code>.</li>\n	<li>Интерфейсы позволяют создавать структуры типов без иерархии.</li>\n	<li>Наследуясь от абстрактного, класс &laquo;растворяет&raquo; собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.</li>\n</ul>\n\n<p>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</p></p>\n                        ',1),(27,'Hash Code & Equals контракт','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`hashCode()`</strong> и <strong>`equals()`</strong> играют важную роль в работе с объектами, особенно когда речь идет о коллекциях, таких как <strong>`HashSet`</strong>, <strong>`HashMap`</strong>, и <strong>`Hashtable`</strong>. Они определены в классе <strong>`Object`</strong>, и поэтому доступны для переопределения всеми классами. Правильное переопределение этих методов важно для эффективной работы коллекций, которые используют хеширование.</p>\n\n<p>Контракт<strong> `hashCode()`</strong> и <strong>`equals()`</strong> - определяет, как эти методы должны взаимодействовать друг с другом:</p>\n\n<p>1. <strong>Согласованность:</strong> Если два объекта равны согласно методу <strong>`equals(Object obj)`</strong>, тогда вызов <strong>`hashCode()`</strong> на каждом из объектов должен возвращать одинаковое целое значение. Это не значит, что объекты, не равные друг другу, должны возвращать различные хеш-коды. Однако, разные хеш-коды могут помочь улучшить производительность хеш-таблиц.</p>\n\n<p>2. <strong>Обратное не требуется: </strong>Если <strong>`hashCode()`</strong> двух объектов возвращает одинаковое значение, это не обязательно означает, что объекты равны согласно <strong>`equals()`</strong>. Ситуация, когда разные объекты имеют одинаковые хеш-коды, называется коллизией.</p>\n\n<p>Переопределение <strong>`equals(Object obj)`</strong> используется для проверки равенства двух объектов. По умолчанию, этот метод проверяет равенство ссылок, что означает, что два объекта считаются равными, только если они указывают на одно и то же место в памяти. Переопределение метода<strong> `equals()` </strong>позволяет сравнивать объекты по содержанию.</p>\n\n<p>При переопределении <strong>`equals()`</strong>, убедитесь, что он:</p>\n\n<ul>\n	<li>Рефлексивен: для любого ненулевого ссылочного значения<strong> `x`</strong>, <strong>`x.equals(x)` </strong>должно возвращать <strong>`true`</strong>.</li>\n	<li>Симметричен: для любых ненулевых ссылочных значений <strong>`x`</strong> и <strong>`y`</strong>, <strong>`x.equals(y)`</strong> должно возвращать <strong>`true` </strong>тогда и только тогда, когда <strong>`y.equals(x)`</strong> возвращает<strong> `true`</strong>.</li>\n	<li>Транзитивен: для любых ненулевых ссылочных значений <strong>`x`</strong>, <strong>`y`</strong>, и <strong>`z`</strong>, если <strong>`x.equals(y)`</strong> возвращает<strong> `true` </strong>и <strong>`y.equals(z)`</strong> возвращает <strong>`true`</strong>, то и <strong>`x.equals(z)`</strong> должно возвращать <strong>`true`</strong>.</li>\n	<li>Консистентен: для любых ненулевых ссылочных значений <strong>`x`</strong> и <strong>`y`</strong>, многократные вызовы<strong> `x.equals(y)` </strong>должны последовательно возвращать <strong>`true`</strong> или последовательно возвращать <strong>`false`</strong>.</li>\n	<li>Для любого ненулевого ссылочного значения<strong> `x`</strong>, <strong>`x.equals(null)`</strong> должно возвращать <strong>`false`</strong>.</li>\n</ul>\n\n<p>Переопределение<strong> `hashCode()`</strong> возвращает хеш-код объекта, который используется хеш-таблицами для определения места хранения объекта. При переопределении <strong>`equals()`</strong>, необходимо также переопределить <strong>`hashCode()`</strong>, чтобы поддерживать общий контракт для методов<strong> `hashCode()`</strong> и <strong>`equals()`</strong>.</p>\n\n<p><strong>Пример:</strong></p>\n\n<pre>\n<code class=\"language-java\">public class Person {\n    private String name;\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n               Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}</code></pre>\n\n<p>В этом примере, <strong>`equals()`</strong> сравнивает объекты по <strong>`name`</strong> и <strong>`age`</strong>, а <strong>`hashCode()`</strong> использует эти же поля для генерации хеш-кода. Это обеспечивает соблюдение контракта между<strong> `equals()` </strong>и <strong>`hashCode()`</strong>.</p>\n\n<p>Правильное переопределение <strong>`equals()` </strong>и <strong>`hashCode()` </strong>критически важно для корректной работы коллекций, основанных на хеш-таблицах. Это обеспечивает эффективное распределение объектов в коллекции и корректное сравнение объектов по содержанию.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(28,'Разница между примитивом и ссылочным типом данных','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Данные классифицируются на примитивные типы и ссылочные типы, и между этими двумя категориями существует несколько ключевых различий.</p>\n\n<p><strong>Примитивные типы</strong></p>\n\n<p>Основные типы данных, которые включают <strong>`byte`</strong>, <strong>`short`</strong>, <strong>`int`</strong>, <strong>`long`</strong>,<strong> `float`</strong>, <strong>`double`</strong>, <strong>`boolean`</strong>, и <strong>`char`</strong>. Представляют собой простые значения и не содержат дополнительных методов для работы с ними.</p>\n\n<p>1. <strong>Хранение:</strong> Примитивные типы хранятся в стеке, и доступ к ним осуществляется напрямую, что делает их обработку быстрой.<br />\n2. <strong>Значение по умолчанию:</strong> У каждого примитивного типа есть значение по умолчанию, например, <strong>`0`</strong> для числовых типов, <strong>`false`</strong> для <strong>`boolean`</strong> и <strong>`\\u0000`</strong> для <strong>`char`</strong>.<br />\n3. <strong>Размер:</strong> Размер примитивных типов фиксирован. Например, <strong>`int` </strong>всегда занимает 4 байта в памяти.</p>\n\n<p><strong>Ссылочные типы</strong></p>\n\n<p>Включают в себя классы, интерфейсы, массивы и перечисления. Представляют собой ссылку на объект, а не сам объект. Ссылочные типы могут быть использованы для вызова методов и могут быть равны <strong>`null`</strong>.</p>\n\n<p>1. <strong>Хранение:</strong> Ссылочные типы хранятся в куче, а в стеке хранится только ссылка на объект в куче. Доступ к объектам осуществляется через ссылку, что может быть медленнее, чем прямой доступ к примитивам.<br />\n2. <strong>Значение по умолчанию:</strong> Значение по умолчанию для всех ссылочных типов &mdash; <strong>`null`</strong>.<br />\n3. <strong>Размер:</strong> Размер объекта ссылочного типа может быть разным и зависит от его структуры и данных, которые он содержит.</p>\n\n<p><strong>Основные различия</strong></p>\n\n<ul>\n	<li><strong>Хранение в памяти:</strong> Примитивы хранятся в стеке, а объекты ссылочных типов &mdash; в куче с ссылкой на них, хранящейся в стеке.</li>\n	<li><strong>Производительность:</strong> Обращение к примитивам обычно быстрее, чем к объектам, поскольку для примитивов не требуется разыменование ссылок.</li>\n	<li><strong>Использование:</strong> Примитивные типы идеально подходят для хранения простых значений, в то время как ссылочные типы используются для создания сложных структур данных и объектов.</li>\n	<li><strong>Методы:</strong> Ссылочные типы могут использовать методы для выполнения операций над объектами, тогда как примитивные типы не имеют методов.</li>\n	<li><strong>Nullability:</strong> Ссылочные типы могут быть <strong>`null`</strong>, указывая на отсутствие объекта, в то время как примитивные типы всегда имеют конкретное значение.</li>\n</ul>\n\n<p>Выбор между примитивным и ссылочным типом данных зависит от конкретной задачи и требований к производительности. В некоторых случаях, например, когда требуется максимальная эффективность и минимальное потребление памяти, предпочтительнее использовать примитивные типы. В других случаях, когда нужны сложные структуры данных или возможность указать на отсутствие значения (<strong>`null`</strong>), лучше использовать ссылочные типы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(29,'Что такое ACID','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.</p>\n\n<ul>\n	<li>A - Atomicity. Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие &laquo;отката&raquo; (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во &laquo;внешне исходное&raquo; состояние &mdash; со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)</li>\n	<li>C - Consistency &mdash; Согласованность. Транзакция, достигающая своего нормального завершения (EOT &mdash; end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.</li>\n</ul>\n\n<p>Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.</p>\n\n<p>Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.</p>\n\n<ul>\n	<li>I - Isolation &mdash; Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность &mdash; требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию.&nbsp;Уровни изоляции транзакций</li>\n	<li>D - Durability &mdash; Стойкость. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(30,'Stream в Java','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`Stream` </strong>&mdash; это абстракция, которая позволяет обрабатывать последовательности элементов (например, коллекции) в функциональном стиле. API был добавлен в Java 8 и представляет собой набор классов и интерфейсов в пакете<strong> `java.util.stream`</strong>. Основная цель &mdash; упростить работу с коллекциями данных, позволяя выполнять различные операции с элементами последовательности, такие как фильтрация, сортировка, преобразование, агрегирование и другие, без необходимости явно писать циклы и управлять итерациями.</p>\n\n<p><strong>Особенности:</strong></p>\n\n<p>1. <strong>Не изменяет исходные данные: </strong>Операции с потоками данных не модифицируют исходную коллекцию, что способствует функциональному подходу и неизменяемости данных.<br />\n2. <strong>Ленивая обработка:</strong> Большинство операций с потоками выполняются лениво, то есть вычисления начинаются только тогда, когда это необходимо для получения результата (например, при вызове терминальной операции).<br />\n3. <strong>Поддержка параллельной обработки:</strong> Позволяет легко выполнять операции над элементами коллекции параллельно, что может значительно ускорить обработку больших наборов данных на многопроцессорных системах.</p>\n\n<p>Основные операции:</p>\n\n<p>Операции с потоками данных делятся на промежуточные (intermediate) и терминальные (terminal).</p>\n\n<ul>\n	<li><strong>Промежуточные операции&nbsp;</strong>возвращают новый поток и включают фильтрацию (<strong>`filter`</strong>), преобразование (<strong>`map`</strong>), сортировку (<strong>`sorted`</strong>) и другие. Они используются для преобразования потока и могут быть объединены в цепочки.</li>\n	<li><strong>Терминальные операции</strong>&nbsp;возвращают результат определенного типа (например, коллекцию, значение, boolean) или выполняют действие (<strong>`forEach`</strong>). К терминальным операциям относятся <strong>`collect`</strong>, <strong>`reduce`</strong>, <strong>`count`</strong>,<strong> `findFirst`</strong>.</li>\n</ul>\n\n<p><strong>Пример использования:</strong></p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamExample {\n    public static void main(String[] args) {\n        List&lt;String&gt; strings = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n        // Фильтрация и преобразование списка строк в список их длин\n        List&lt;Integer&gt; lengths = strings.stream() // Создание потока\n                .filter(s -&gt; s.length() &gt; 5) // Фильтрация строк по длине\n                .map(String::length) // Преобразование строки в её длину\n                .collect(Collectors.toList()); // Сбор результатов в список\n\n        System.out.println(lengths); // Вывод: [6, 6]\n    }\n}</code></pre>\n\n<p><strong>`Stream`</strong> API обеспечивает мощный и гибкий инструментарий для работы с данными в декларативном стиле, позволяя сосредоточиться на операциях обработки данных, а не на управлении итерациями и хранением промежуточных результатов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс&nbsp;<code>java.util.Stream</code>&nbsp;представляет собой последовательность элементов, над которой можно производить различные операции.</p>\n\n<p>Операции над стримами бывают или&nbsp;<em>промежуточными (intermediate)</em>&nbsp;или&nbsp;<em>конечными (terminal)</em>. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.</p>\n\n<p>У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция, никаких действий на самом деле не происходит (похоже на создание объекта&nbsp;<code>Thread</code>&nbsp;или&nbsp;<code>Runnable</code>, без вызова&nbsp;<code>start()</code>).</p>\n\n<p>Стримы создаются на основе каких-либо источников, например классов из&nbsp;<code>java.util.Collection</code>.</p>\n\n<p>Ассоциативные массивы (maps), например,&nbsp;<code>HashMap</code>, не поддерживаются.</p>\n\n<p>Операции над стримами могут выполняться как последовательно, так и параллельно.</p>\n\n<p>Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.</p>\n\n<p>Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных&nbsp;<code>int</code>,&nbsp;<code>long</code>&nbsp;и&nbsp;<code>double</code>:&nbsp;<code>IntStream</code>,&nbsp;<code>LongStream</code>&nbsp;и&nbsp;<code>DoubleStream</code>. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:</p>\n\n<ul>\n	<li>используют специализированные лямбда-выражения, например,&nbsp;<code>IntFunction</code>&nbsp;или&nbsp;<code>IntPredicate</code>&nbsp;вместо&nbsp;<code>Function</code>&nbsp;и&nbsp;<code>Predicate</code>;</li>\n	<li>поддерживают дополнительные конечные операции&nbsp;<code>sum()</code>,&nbsp;<code>average()</code>,&nbsp;<code>mapToObj()</code>.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',9),(31,'Spring Scope',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В Spring Framework существует несколько областей видимости (scopes) для бинов, каждая из которых определяет жизненный цикл и видимость бина в контексте приложения. Вот основные из них:</p>\n\n<p>1. <strong>Singleton:</strong> Это область видимости по умолчанию. Бин с данной областью видимости создается один раз на каждый контейнер Spring IoC и кэшируется для последующих запросов. Все запросы на получение бина возвращают один и тот же экземпляр бина.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(\"singleton\")\n   public class MySingletonBean {\n   }</code></pre>\n\n<p>2. <strong>Prototype:</strong> Бин с данной областью видимости создается заново каждый раз, когда он запрашивается из контейнера. Это полезно, когда необходимы разные экземпляры бина для разных задач.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(\"prototype\")\n   public class MyPrototypeBean {\n   }</code></pre>\n\n<p>3. <strong>Request:</strong> Эта область видимости используется в веб-приложениях. Бин создается для каждого HTTP-запроса и уничтожается после обработки запроса. Бины с данной областью видимости доступны только в контексте одного HTTP-запроса.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyRequestBean {\n   }</code></pre>\n\n<p>4. <strong>Session:</strong> Бин с данной областью видимости создается для каждой пользовательской сессии. Бин живет в течение всей сессии и уничтожается, когда сессия завершается. Это полезно для хранения информации, специфичной для пользователя, в течение всего времени его сессии.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MySessionBean {\n   }</code></pre>\n\n<p>5. <strong>Application: </strong>Бин с данной областью видимости создается один раз для всего сервлет-контекста. Это полезно для данных, которые должны быть общими для всех пользователей и сессий в приложении.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"application\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyApplicationBean {\n   }</code></pre>\n\n<p>6. <strong>WebSocket: </strong>Бин с данной областью видимости создается для каждой сессии WebSocket. Это полезно для работы с данными, специфичными для каждой WebSocket-сессии.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"websocket\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyWebSocketBean {\n   }</code></pre>\n\n<p>Каждая из этих областей видимости предоставляет разные способы управления жизненным циклом бинов в приложении, позволяя выбирать наиболее подходящий вариант для конкретного случая.</p>\n\n<p>Spring предлагает разные области видимости для бинов, такие как Singleton, Prototype, Request, Session, Application и WebSocket, которые определяют, как и когда бины будут создаваться, жить и уничтожаться. Это позволяет управлять жизненным циклом бинов в соответствии с потребностями приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',3),(32,'Функциональный интерфейс',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Функциональный интерфейс &mdash; это интерфейс, который содержит только один абстрактный метод. Это позволяет использовать лямбда-выражения для создания его анонимных реализаций, делая код более лаконичным и читаемым. Функциональные интерфейсы являются основой для лямбда-выражений и методов ссылок, начиная с версии 8.</p>\n\n<p>Примером этого может служить интерфейс <strong>`java.util.function.Predicate&lt;T&gt;`</strong>, который принимает объект типа <strong>`T`</strong> и возвращает значение типа <strong>`boolean`</strong>. Вот пример использования:</p>\n\n<pre>\n<code class=\"language-java\">Predicate&lt;String&gt; isNotEmpty = s -&gt; !s.isEmpty();\nSystem.out.println(isNotEmpty.test(\"Hello\")); // Выведет true\nSystem.out.println(isNotEmpty.test(\"\")); // Выведет false</code></pre>\n\n<p>Чтобы явно указать, что интерфейс предназначен для использования как функциональный, используется аннотация <strong>`@FunctionalInterface`</strong>. Эта аннотация не обязательна (компилятор может определить функциональный интерфейс и без неё), но она помогает в документировании кода и обеспечивает проверку времени компиляции, гарантируя, что интерфейс содержит только один абстрактный метод.</p>\n\n<p><strong>Пример собственного интерфейса:</strong></p>\n\n<pre>\n<code class=\"language-java\">@FunctionalInterface\npublic interface SimpleFunction {\n    int apply(int value);\n}\n\n// Использование\nSimpleFunction triple = value -&gt; value * 3;\nSystem.out.println(triple.apply(5)); // Выведет 15</code></pre>\n\n<p>Важно отметить, что функциональный интерфейс может содержать также статические и default методы, не нарушая своей &quot;функциональности&quot;, поскольку они не считаются абстрактными методами.</p>\n\n<p>Функциональный интерфейс &mdash; это интерфейс с одним абстрактным методом, который позволяет использовать лямбда-выражения для более краткого и выразительного кода. Аннотация<strong> `@FunctionalInterface` </strong>помогает обеспечить, что интерфейс соответствует требованиям функционального интерфейса.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',9),(33,'ExecutorService','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`ExecutorService`</strong> &ndash; это интерфейс из пакета <strong>`java.util.concurrent`</strong>, который предоставляет фреймворк для асинхронного выполнения задач. Он позволяет управлять потоками и задачами без необходимости явно создавать и управлять потоками руками. Это делает код более читаемым, упрощает работу с многопоточностью и повышает производительность приложения.</p>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p>В многопоточных приложениях часто возникает необходимость выполнения задач параллельно или асинхронно. Вместо того чтобы каждый раз создавать новые потоки вручную, что может быть неэффективно и увеличивать сложность кода, <strong>`ExecutorService`</strong> предоставляет удобные методы для выполнения задач в уже существующем пуле потоков. Это позволяет повторно использовать потоки и управлять ими эффективно.</p>\n\n<p><strong>Как он используется?</strong></p>\n\n<p>Может быть создан через статические методы класса <strong>`Executors`</strong>, например, <strong>`newFixedThreadPool(int)`</strong>, <strong>`newCachedThreadPool()`</strong>, <strong>`newSingleThreadExecutor()`</strong>, которые позволяют создавать пулы потоков с фиксированным числом потоков, кэширующие пулы потоков (создают новые потоки по необходимости и переиспользуют старые, когда они освобождаются) и пулы для выполнения задач последовательно в одном потоке соответственно.</p>\n\n<p>После его создания, можно отправлять задачи на выполнение, используя методы <strong>`execute(Runnable)`</strong> для задач без результата или <strong>`submit(Callable&lt;T&gt;)`</strong> для задач, возвращающих результат. Он также предоставляет методы для управления состоянием выполнения, например, <strong>`shutdown()`</strong> для остановки приема новых задач и завершения уже запущенных.</p>\n\n<p>Пример использования</p>\n\n<pre>\n<code class=\"language-java\">ExecutorService executor = Executors.newFixedThreadPool(10); // Создаем пул из 10 потоков\n\nexecutor.submit(() -&gt; {\n    // Задача, выполняемая в одном из потоков пула\n    System.out.println(\"Асинхронная задача \" + Thread.currentThread().getName());\n});\n\nexecutor.shutdown(); // Завершаем работу ExecutorService после выполнения всех задач</code></pre>\n\n<p><strong>`ExecutorService`</strong> &ndash; это мощный инструмент для управления асинхронными задачами и потоками в Java. Он упрощает работу с многопоточностью, позволяя эффективно использовать системные ресурсы и упрощает код, делая его более читаемым и поддерживаемым.</p>\n\n<p><strong>`ExecutorService`</strong> помогает организовать выполнение задач в пуле потоков, управлять этими потоками и обрабатывать результаты выполнения задач.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(34,'SQL и NoSQL','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>SQL (Structured Query Language) и NoSQL относятся к разным типам систем управления базами данных, каждый из которых предлагает уникальные характеристики и преимущества для определенных случаев использования и требований к данным.</p>\n\n<p><strong>SQL (Реляционные БД):</strong></p>\n\n<ul>\n	<li><strong>Структура: </strong>Организованы в таблицы, состоящие из строк и столбцов. Все данные должны следовать заранее определенной схеме, что означает строгую структуру с четко определенными типами данных для каждого столбца.</li>\n	<li><strong>Связи:</strong> Поддерживают сложные запросы и операции с данными, включая присоединения таблиц (joins), транзакции, которые обеспечивают ACID-совместимость (атомарность, согласованность, изолированность, долговечность).</li>\n	<li><strong>Масштабируемость: </strong>Традиционно лучше подходят для вертикального масштабирования, что означает улучшение характеристик одного сервера (например, увеличение CPU, RAM).</li>\n	<li><strong>Примеры:</strong> MySQL, PostgreSQL, Oracle, Microsoft SQL Server.</li>\n</ul>\n\n<p><strong>NoSQL (Нереляционные БД):</strong></p>\n\n<ul>\n	<li><strong>Структура:</strong> Могут быть не только документо-ориентированными, но и ключ-значение, широкие столбцы, графовые базы данных. Они гибкие по отношению к структуре данных; схема данных может быть динамически изменена и не требует предварительного определения.</li>\n	<li><strong>Связи:</strong> Запросы обычно проще, и меньше поддержки для сложных операций с данными. ACID-транзакции поддерживаются не всеми данными системами.</li>\n	<li><strong>Масштабируемость: </strong>Разработаны с учетом горизонтального масштабирования, что означает добавление большего количества серверов или узлов в кластер для обработки большего объема данных и трафика.</li>\n	<li><strong>Примеры: </strong>MongoDB (документо-ориентированная), Redis (ключ-значение), Cassandra (широкие столбцы), Neo4j (графовые).</li>\n</ul>\n\n<p><strong>Основные различия:</strong><br />\n1. <strong>Схема данных:</strong> SQL требует строгой предварительной схемы, в то время как NoSQL более гибкий и позволяет хранить неструктурированные или полуструктурированные данные.<br />\n2. <strong>Типы запросов и операции с данными:</strong> SQL поддерживает сложные запросы и операции, NoSQL обеспечивает более быструю запись и чтение за счет более простых запросов.<br />\n3. <strong>Масштабируемость:</strong> SQL базы данных традиционно масштабируются вертикально, в то время как NoSQL базы данных разработаны для горизонтального масштабирования.<br />\n4. <strong>Транзакции: </strong>SQL базы данных обеспечивают строгую поддержку ACID-транзакций, в то время как в NoSQL подходы к транзакциям могут варьироваться, и не все из них поддерживают полную ACID-совместимость.</p>\n\n<p>Выбор между SQL и NoSQL зависит от конкретных требований к данным, предполагаемого объема и структуры данных, необходимости масштабирования и других факторов специфического проекта.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(35,'Лямбда',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Лямбда</strong>&nbsp;представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>\n\n<p>Основу лямбда-выражения составляет&nbsp;<em>лямбда-оператор</em>, который представляет стрелку&nbsp;<code>-&gt;</code>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.</p>\n\n<p>Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.</p>\n\n<pre>\n<code>interface Operationable {\n    int calculate(int x, int y);\n}\n\npublic static void main(String[] args) {\n    Operationable operation = (x, y) -&gt; x + y;     \n    int result = operation.calculate(10, 20);\n    System.out.println(result); //30\n}</code></pre>\n\n<p>По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.</p>\n\n<ul>\n	<li>\n	<p><em>Отложенное выполнение (deferred execution) лямбда-выражения</em>- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.</p>\n	</li>\n	<li>\n	<p><em>Параметры лямбда-выражения</em>&nbsp;должны соответствовать по типу параметрам метода функционального интерфейса:</p>\n\n	<pre>\n<code>operation = (int x, int y) -&gt; x + y;\n//При написании самого лямбда-выражения тип параметров разрешается не указывать:\n(x, y) -&gt; x + y;\n//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,\n() -&gt; 30 + 20;\n//Если метод принимает только один параметр, то скобки можно опустить:\nn -&gt; n * n;</code></pre>\n	</li>\n</ul>\n\n<ul>\n	<li><em>Конечные лямбда-выражения</em>&nbsp;не обязаны возвращать какое-либо значение.\n\n	<pre>\n<code>interface Printable {\n    void print(String s);\n}\n \npublic static void main(String[] args) {\n    Printable printer = s -&gt; System.out.println(s);\n    printer.print(\"Hello, world\");\n}</code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n	<li><em>Блочные лямбда-выражения</em>&nbsp;обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции&nbsp;<code>if</code>,&nbsp;<code>switch</code>, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор&nbsp;<code>return</code>:\n	<pre>\n<code>Operationable operation = (int x, int y) -&gt; {       \n    if (y == 0) {\n        return 0;\n    }\n    else {\n        return x / y;\n    }\n};</code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n	<li><em>Передача лямбда-выражения в качестве параметра метода</em>:\n	<pre>\n<code>interface Condition {\n    boolean isAppropriate(int n);\n}\n\nprivate static int sum(int[] numbers, Condition condition) {\n    int result = 0;\n    for (int i : numbers) {\n        if (condition.isAppropriate(i)) {\n            result += i;\n        }\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -&gt; n != 0));\n} </code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Lambda-выражения &mdash; это способ предоставления четкой и компактной формы для представления экземпляра функционального интерфейса. Функциональный интерфейс, напомню, это интерфейс с одним абстрактным методом. Эти выражения позволяют вам выполнять функциональное программирование, упрощая создание анонимных классов и делая код более читаемым и лаконичным.</p>\n\n<p>Данное выражение состоит из списка параметров, символа стрелки <strong>`-&gt;` </strong>и тела выражения. Тело может быть выражением или блоком кода. Если тело выражения состоит из одного выражения, фигурные скобки необязательны, и значение выражения автоматически возвращается. Если тело содержит блок кода, он должен быть заключен в фигурные скобки, и вам может потребоваться использовать <strong>`return`</strong> для возврата значения (если метод не <strong>`void`</strong>).</p>\n\n<p><strong>Пример его использования:</strong></p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Doe\", \"Sarah\");\n\n// Сортировка списка строк по длине с использованием lambda-выражения\nCollections.sort(names, (String a, String b) -&gt; a.length() - b.length());\n\nnames.forEach(name -&gt; System.out.println(name));</code></pre>\n\n<p>В этом примере мы сначала сортируем список имен по длине с помощью такого выражения, переданного в метод <strong>`Collections.sort()`</strong>. Затем мы используем еще одно lambda-выражение с методом<strong> `forEach` </strong>для вывода всех имен в списке. Это показывает, как они могут сделать код более выразительным и избавить от необходимости явного создания анонимных классов для реализации интерфейсов с одним методом.</p>\n\n<p>Lambda-выражения особенно полезны при работе с коллекциями и API потоков (Streams API), позволяя выполнять операции фильтрации, сортировки, преобразования и агрегирования коллекций данных с минимальным синтаксисом и усилиями.</p>\n\n<p>Lambda-выражения &mdash; это компактный способ представления функционального интерфейса, который упрощает код и делает его более читаемым, особенно при работе с коллекциями и потоками данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',9),(36,'Индексы в бд',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Индекс (index)</strong>&nbsp;&mdash; объект базы данных, создаваемый с целью повышения производительности выборки данных.</p>\n\n<p>Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.</p>\n\n<p>Преимущества</p>\n\n<ul>\n	<li>ускорение поиска и сортировки по определенному полю или набору полей.</li>\n	<li>обеспечение уникальности данных.</li>\n</ul>\n\n<p>Недостатки</p>\n\n<ul>\n	<li>требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.</li>\n	<li>замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.</li>\n</ul>\n\n<p>Индексы предпочтительней для:</p>\n\n<ul>\n	<li>Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;</li>\n	<li>Поля, по которому проводится сортировка данных;</li>\n	<li>Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;</li>\n	<li>Поля, которое объявлено первичным ключом (primary key);</li>\n	<li>Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.</li>\n</ul>\n\n<p>Использование индексов нецелесообразно для:</p>\n\n<ul>\n	<li>Полей, которые редко используются в запросах;</li>\n	<li>Полей, которые содержат всего два или три значения, например:&nbsp;<em>мужской</em>,&nbsp;<em>женский пол</em>&nbsp;или значения&nbsp;<em>&laquo;да&raquo;</em>,&nbsp;<em>&laquo;нет&raquo;</em>.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Индексы &mdash; это структуры данных, которые улучшают скорость операций выборки данных (SELECT), обновления (UPDATE) и удаления (DELETE), предоставляя быстрый доступ к данным. Они создаются на одном или нескольких полях таблиц базы данных и могут значительно сократить количество данных, которые нужно просканировать при выполнении запроса. Основная цель индекса &mdash; ускорить поиск и доступ к данным в таблице.</p>\n\n<p><strong>Как работают индексы:</strong><br />\n1. <strong>Без индекса: </strong>База данных должна просканировать всю таблицу, чтобы найти строки, соответствующие критериям запроса. Это называется полным сканированием таблицы и может быть очень медленным для больших таблиц.</p>\n\n<p>2. <strong>С индексом: </strong>База данных может использовать индекс для быстрого нахождения строк, соответствующих критериям запроса, без необходимости сканировать всю таблицу. Это значительно ускоряет операцию поиска.</p>\n\n<p><strong>Индексы могут быть различных типов, включая:</strong></p>\n\n<ul>\n	<li><strong>B-tree (B-дерево):</strong> Наиболее часто используемый тип, который поддерживает данные упорядоченными, что упрощает поиск, вставку, удаление и доступ к диапазонам данных.</li>\n	<li><strong>Hash (Хеш):</strong> Используется для поиска точных совпадений и не поддерживает упорядоченность или поиск по диапазону. Хеш-индексы обычно используются для таблиц с высокой частотой запросов по конкретным значениям.</li>\n	<li><strong>Full-text (Полнотекстовый):</strong> Особый тип, предназначенный для улучшения поиска по текстовым полям, позволяя выполнять поиск по словам внутри текстовых данных.</li>\n</ul>\n\n<p><strong>Создание индексов также имеет свои недостатки:</strong></p>\n\n<ul>\n	<li><strong>Производительность записи:</strong> При добавлении или обновлении данных в таблице все индексы, связанные с этой таблицей, также должны быть обновлены. Это может замедлить операции записи.</li>\n	<li><strong>Занимаемое пространство:</strong> Занимают дополнительное пространство в памяти или на диске.</li>\n</ul>\n\n<p>Их использованиетребует тщательного планирования и анализа. Необходимо учитывать, какие запросы чаще всего выполняются, и создавать индексы для тех столбцов, которые часто используются в условиях поиска.</p>\n\n<p>Индексы &mdash; это структуры данных, используемые базами данных для ускорения поиска и доступа к данным. Они могут значительно повысить производительность чтения, но влияют на производительность записи и занимают дополнительное пространство.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(37,'Нормализация баз данных','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><em>Нормализация</em>&nbsp;- это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>\n\n<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p></p>\n                        \n                        <p class=\"card-text\"><small class=\"text-muted\">Oct. 21, 2023, <a class=\"link-secondary link-offset-2 link-offset-3-hover link-underline link-underline-opacity-0 link-underline-opacity-75-hover\" target=\"_blank\"  href=\"https://github.com/enhorse/java-interview/blob/master/db.md#Что-такое-нормализация\">Источник</a></small></p>\n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><em>Нормализация</em>&nbsp;- это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>\n\n<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Нормализация баз данных &mdash; это процесс организации данных в БД для уменьшения избыточности и улучшения целостности данных. Этот процесс включает разделение больших таблиц на меньшие и связанные таблицы и определение отношений между ними для минимизации дублирования информации и зависимости данных. Нормализация помогает оптимизировать структуру БД, облегчая её расширение, обновление и поддержку.</p>\n\n<p><strong>Цели:</strong><br />\n1. <strong>Избежание избыточности данных:</strong> Уменьшение повторяющихся данных в таблицах.<br />\n2. <strong>Улучшение целостности данных:</strong> Обеспечение точности и надежности данных путем установления правил и ограничений.<br />\n3. <strong>Оптимизация запросов: </strong>Улучшение производительности базы данных за счет сокращения объема данных, обрабатываемых в запросах.</p>\n\n<p>Она обычно достигается путем применения серии &quot;нормальных форм&quot; &mdash; правил, которые должны быть применены к структуре базы данных. Существует несколько нормальных форм, каждая из которых решает определенные проблемы избыточности и зависимости данных. Наиболее часто используются первая (1NF), вторая (2NF), третья (3NF) и иногда четвертая (4NF) и пятая (5NF) нормальные формы.</p>\n\n<p>1. <strong>Первая нормальная форма (1NF):</strong> Требует, чтобы значения в каждой колонке таблицы были атомарными (неделимыми), и каждая колонка содержала значения только одного типа. Также требуется уникальность всех строк в таблице.</p>\n\n<p>2. <strong>Вторая нормальная форма (2NF):</strong> Достигается путем удаления данных, которые зависят только от части первичного ключа в таблицах с составным ключом.</p>\n\n<p>3. <strong>Третья нормальная форма (3NF):</strong> Требует, чтобы все данные в таблице были зависимы только от первичного ключа и устраняет транзитивные зависимости (когда одно поле зависит от другого поля, которое не является первичным ключом).</p>\n\n<p>4. <strong>Четвертая нормальная форма (4NF):</strong> Дополнительно устраняет многозначные зависимости, когда наличие двух или более независимых отношений в одной таблице вызывает избыточность.</p>\n\n<p>Применение ее улучшает структуру базы данных, но также важно найти баланс, поскольку излишняя нормализация может привести к сложности запросов и снижению производительности из-за необходимости множественных присоединений таблиц. В некоторых случаях для улучшения производительности чтения данных может потребоваться денормализация &mdash; процесс добавления избыточности обратно в базу данных.</p>\n\n<p>Нормализация баз данных &mdash; это процесс проектирования структуры базы данных для минимизации избыточности и улучшения целостности данных, что достигается путем разделения таблиц на более мелкие, связанные таблицы и определения отношений между ними.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(38,'Что такое bean','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Термин &quot;bean&quot; обозначает объект, который управляется Spring IoC (Inversion of Control) контейнером. Этот контейнер отвечает за создание, инициализацию, сборку и управление такими объектами. Beans являются основой приложения, построенного на Spring, и представляют собой компоненты, из которых состоит приложение. Они могут быть контроллерами, сервисами, репозиториями данных, компонентами для доступа к данным, конфигурационными классами и т. д.</p>\n\n<p>Создание и управление bean-компонентами обычно происходит через аннотации или XML-конфигурацию. Примеры аннотаций включают <strong>`@Component`</strong>, <strong>`@Service`</strong>, <strong>`@Repository`</strong>, <strong>`@Controller`</strong>, каждая из которых указывает на определенный тип или роль компонента в приложении. Контейнер автоматически обнаруживает такие аннотированные классы при запуске и регистрирует их в качестве бинов.</p>\n\n<p>Пример простого Spring bean, аннотированного как <strong>`@Service`</strong>:</p>\n\n<pre>\n<code class=\"language-java\">@Service\npublic class MyService {\n    public String sayHello() {\n        return \"Hello, Spring!\";\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`MyService`</strong> будет автоматически обнаружен Spring при сканировании пакетов и зарегистрирован в контексте приложения как bean. После регистрации он может быть внедрен и использован в других компонентах приложения через механизмы внедрения зависимостей (DI).</p>\n\n<p><strong>Ключевые аспекты работы с бинами:</strong></p>\n\n<ul>\n	<li><strong>Внедрение зависимостей (Dependency Injection):</strong> Этот контейнер внедряет объекты в бины автоматически, уменьшая связность между компонентами и упрощая их тестирование.</li>\n	<li><strong>Объявление бинов:</strong> Может осуществляться через аннотации на классах или явно в XML-конфигурации или Java-конфигурации.</li>\n	<li><strong>Управление жизненным циклом:</strong> Позволяет настраивать поведение бинов на различных этапах их жизненного цикла, например, при создании, после инициализации и перед уничтожением.</li>\n</ul>\n\n<p>bean &mdash; это объект, управляемый Spring IoC контейнером, который представляет собой компонент приложения. Beans могут быть автоматически обнаружены и созданы Spring, а также внедрены в другие компоненты, обеспечивая слабую связанность и высокую гибкость приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',3),(39,'Что такое deadlock','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Deadlock (взаимная блокировка) &mdash; это ситуация в многопоточном программировании, при которой два или более потока вечно ожидают друг друга, освободят ли они ресурсы, занятые в данный момент. Каждый из потоков держит замок (lock) на некотором ресурсе и ожидает получения замка на другом ресурсе, который в это время занят другим потоком. В результате ни один из потоков не может продолжить выполнение, поскольку каждый из них ждет освобождения ресурса, занятого другим потоком.</p>\n\n<p><strong>Пример:</strong></p>\n\n<p>Представьте ситуацию, где есть два потока и два ресурса (например, два файла или два объекта в памяти).</p>\n\n<ul>\n	<li>Поток 1 захватывает ресурс A и ждет освобождения ресурса B.</li>\n	<li>Поток 2 захватывает ресурс B и ждет освобождения ресурса A.</li>\n</ul>\n\n<p>В такой ситуации оба потока не могут продолжить выполнение, так как каждый из них ожидает освобождения ресурса, уже захваченного другим потоком. Это и есть deadlock.</p>\n\n<p>Чтобы избежать такой ситуации, нужно использовать стратегии, такие как:</p>\n\n<p>1. <strong>Предотвращение зацикливания:</strong> Все потоки должны запрашивать ресурсы в одном и том же порядке, даже если это означает, что некоторым потокам придется ждать дольше.<br />\n2. <strong>Использование тайм-аутов:</strong> Потоки могут пытаться захватить ресурс с тайм-аутом. Если ресурс не получен за отведенное время, поток откатывает все свои текущие захваты ресурсов и пытается заново захватить их.<br />\n3. <strong>Обнаружение взаимных блокировок:</strong> Система может активно обнаруживать циклы ожидания и прерывать один из потоков для разрешения блокировки.<br />\n4. <strong>Использование однопоточных моделей:</strong> В некоторых случаях можно избежать проблем с многопоточностью, используя асинхронное программирование или реактивные модели, где логика выполнения не блокируется ожиданием ресурсов.</p>\n\n<p>Deadlock &mdash; это состояние, когда два или более потока вечно ждут друг друга, освободят ли они занятые ресурсы, что приводит к остановке выполнения программы. Избежать этого можно с помощью правильного проектирования и стратегий управления доступом к ресурсам.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Взаимная блокировка (deadlock)</strong>&nbsp;- явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:</p>\n\n<ol>\n	<li>взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.</li>\n	<li>удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.</li>\n	<li>отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.</li>\n	<li>цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.</li>\n</ol>\n\n<p>Простейший способ избежать взаимной блокировки &ndash; не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(40,'Каким образом HashMap связан с Set\'ом',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`HashMap`</strong> и<strong> `Set` </strong>связаны друг с другом через использование коллекции <strong>`HashSet`</strong>. Он внутренне использует <strong>`HashMap` </strong>для хранения своих элементов. Основная идея этой связи заключается в том, что<strong> `HashSet` </strong>обеспечивает уникальность своих элементов с помощью хеш-таблицы, а <strong>`HashMap`</strong> предоставляет эту хеш-таблицу как основу для хранения данных.</p>\n\n<p><strong>Как HashSet использует HashMap</strong></p>\n\n<p>Когда вы добавляете элемент в него, этот элемент используется как ключ во внутреннем<strong> `HashMap`</strong>. Значением для этого ключа является предопределённый статический объект, общий для всех элементов (обычно <strong>`PRESENT`</strong>, просто маркер, который не используется). Это делается для оптимизации памяти и производительности, так как интерес представляет только наличие ключа (элемента в <strong>`HashSet`</strong>), а не значение, ассоциированное с этим ключом.</p>\n\n<pre>\n<code class=\"language-java\">public class HashSet&lt;E&gt;\n    extends AbstractSet&lt;E&gt;\n    implements Set&lt;E&gt;, Cloneable, java.io.Serializable\n{\n    private transient HashMap&lt;E,Object&gt; map;\n\n    // Предопределенный объект, используемый в качестве значения для всех ключей\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap&lt;&gt;();\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    // Другие методы...\n}</code></pre>\n\n<p>Преимущества этой связи</p>\n\n<ul>\n	<li><em><strong>Уникальность элементов:</strong></em> <strong>`HashSet` </strong>гарантирует, что каждый элемент будет уникальным, так как<strong> `HashMap` </strong>не допускает дублирования ключей.</li>\n	<li><em><strong>Высокая производительность: </strong></em>операции добавления, удаления и поиска в<strong> `HashSet`</strong> выполняются за константное время O(1) в среднем, благодаря хеш-таблице <strong>`HashMap`</strong>.</li>\n	<li><em><strong>Эффективное использование памяти:</strong></em> хранение значения <strong>`PRESENT` </strong>для всех элементов минимизирует потребление памяти, так как не требуется отдельно выделять память под значения элементов.</li>\n</ul>\n\n<p>Эта связь между<strong> `HashSet`</strong> и <strong>`HashMap`</strong> позволяет <strong>`HashSet` </strong>эффективно управлять уникальными элементами, используя хеш-таблицу, и предоставляет разработчикам мощный инструмент для создания коллекций, которые требуют уникальности элементов с высокой производительностью поиска, добавления и удаления.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(41,'Что такое процесс и поток',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Процесс</strong>&nbsp;&mdash; экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>\n\n<p>Для каждого процесса ОС создает так называемое &laquo;виртуальное адресное пространство&raquo;, к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.</p>\n\n<p><strong>Поток&nbsp;</strong>(thread) &mdash; определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Процесс и поток являются фундаментальными концепциями в операционных системах, связанными с выполнением программ.</p>\n\n<p><em><strong>Процесс</strong></em> - это экземпляр выполняющейся программы. Процесс имеет свое изолированное адресное пространство памяти, что означает, что они не могут напрямую взаимодействовать с адресным пространством друг друга. Каждый процесс предоставляет ресурсы, необходимые для выполнения программы, включая память, файловые дескрипторы, и другие ресурсы. Операционная система управляет ими, распределяя процессорное время и ресурсы между ними.</p>\n\n<p><em><strong>Поток</strong></em> - это единица выполнения в рамках процесса. Процесс может содержать несколько потоков, которые могут выполняться параллельно. Все они внутри процесса делят одно и то же адресное пространство памяти и ресурсы, что облегчает обмен данными и коммуникацию между ними, но также требует синхронизации для предотвращения конфликтов при доступе к общим ресурсам. Используются для реализации многозадачности в рамках одного процесса.</p>\n\n<p>Основные отличия между процессом и потоком:</p>\n\n<p>1. <em><strong>Изоляция:</strong></em> Процессы изолированы друг от друга, в то время как потоки внутри одного процесса делят общие ресурсы и адресное пространство.<br />\n2. <em><strong>Ресурсы: </strong></em>Процессы имеют отдельные наборы ресурсов, в то время как потоки делят ресурсы внутри процесса.<br />\n3. <em><strong>Создание и управление: </strong></em>Создание нового процесса обычно более затратно по ресурсам и времени, чем создание нового потока внутри существующего процесса.<br />\n4. <em><strong>Коммуникация: </strong></em>Коммуникация между процессами требует использования механизмов межпроцессного взаимодействия (IPC), таких как каналы, сокеты или общая память. Потоки внутри одного процесса могут обмениваться данными более просто, поскольку у них есть доступ к общей памяти.<br />\n5. <em><strong>Влияние на производительность: </strong></em>Потоки могут эффективно использовать процессорное время, выполняясь параллельно, что может улучшить производительность программы. Создание и управление большим количеством процессов может быть более затратным для системы.</p>\n\n<p>Процесс &ndash; это более тяжеловесная структура, представляющая собой запущенную программу с собственным адресным пространством, в то время как поток &ndash; это более легковесная единица выполнения, работающая в рамках процесса и делающая возможной многозадачность внутри одной программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',5),(42,'HashMap',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`HashMap`</strong> &mdash; это структура данных, которая хранит элементы в виде пар ключ-значение. Она использует хеш-таблицу для эффективного поиска, вставки и удаления элементов. Ключи в ней уникальны, а значения могут дублироваться. Один из ключевых аспектов ее использования заключается в возможности доступа к значениям очень быстро по их ключам.</p>\n\n<p><strong>Как работает HashMap</strong></p>\n\n<p>Когда пара ключ-значение добавляется в нее, ключ проходит через хеш-функцию, которая вычисляет индекс в массиве, где должно быть хранится значение. Этот процесс позволяет ей эффективно находить значение по ключу, обеспечивая доступ за константное время O(1) в идеальном случае. Однако, в случае коллизий хеш-функций (когда разные ключи имеют одинаковый хеш-код и, следовательно, могут быть отнесены к одному и тому же индексу массива), она использует структуру данных &quot;связный список&quot; или &quot;красно-черное дерево&quot; (начиная с Java 8) для хранения всех пар ключ-значение, относящихся к одному индексу. Это немного замедляет процесс поиска до O(log n) для красно-черного дерева в худшем случае.</p>\n\n<p><strong>Особенности HashMap:</strong></p>\n\n<ul>\n	<li><em><strong>Не гарантирует порядка элементов:</strong></em> Порядок хранения элементов не гарантирован, и при добавлении новых элементов порядок может измениться.</li>\n	<li><em><strong>null значения:</strong></em> Позволяет использовать<strong> `null`</strong> как ключ и как значение, но только один <strong>`null`</strong> ключ, в то время как значений<strong> `null`</strong> может быть много.</li>\n	<li><em><strong>Несинхронизированность:</strong></em> По умолчанию не является потокобезопасной. Если несколько потоков одновременно доступают к ней и хотя бы один из потоков изменяет карту, это должно быть синхронизировано внешним образом.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">import java.util.HashMap;\n\npublic class Example {\n    public static void main(String[] args) {\n        // Создание HashMap\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n\n        // Добавление элементов в HashMap\n        map.put(\"Ключ1\", 100);\n        map.put(\"Ключ2\", 200);\n        map.put(\"Ключ3\", 300);\n\n        // Получение значения по ключу\n        int value = map.get(\"Ключ2\"); // 200\n\n        // Проверка наличия ключа или значения\n        boolean keyExists = map.containsKey(\"Ключ1\"); // true\n        boolean valueExists = map.containsValue(300); // true\n\n        // Удаление элемента\n        map.remove(\"Ключ3\");\n    }\n}</code></pre>\n\n<p><br />\n<strong>`HashMap`</strong> является одной из наиболее часто используемых структур данных из-за её гибкости и высокой производительности для операций поиска, вставки и удаления.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(43,'Паттерны проектирования','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Паттерны проектирования &mdash; это проверенные решения для часто встречающихся проблем, с которыми разработчики сталкиваются при проектировании и разработке ПО. Они представляют собой шаблоны для решения задач проектирования в рамках данного контекста. Паттерны помогают сделать систему более гибкой, модульной и адаптируемой к изменениям.</p>\n\n<p>Их обычно делят на три основные категории:</p>\n\n<p>1. <strong>Порождающие (Creational Patterns)</strong></p>\n\n<ul>\n	<li>Эти паттерны обеспечивают механизмы создания объектов, повышая гибкость и повторное использование существующего кода.</li>\n	<li><em><strong>Одиночка (Singleton): </strong></em>Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.</li>\n	<li><em><strong>Фабричный метод (Factory Method):</strong></em> Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемых объектов.</li>\n	<li><em><strong>Абстрактная фабрика (Abstract Factory):</strong></em> Позволяет создавать семейства связанных объектов, не специфицируя их конкретные классы.</li>\n	<li><em><strong>Строитель (Builder): </strong></em>Позволяет создавать сложные объекты пошагово.</li>\n	<li><em><strong>Прототип (Prototype):</strong></em> Позволяет копировать объекты, не вдаваясь в подробности их реализации.</li>\n</ul>\n\n<p>2. <strong>Структурные (Structural Patterns)</strong></p>\n\n<ul>\n	<li><em><strong>Структурные паттерны</strong></em> описывают способы сборки объектов и классов в более крупные структуры, при этом сохраняя гибкость и эффективность структур.</li>\n	<li><em><strong>Адаптер (Adapter):</strong></em> Позволяет объектам с несовместимыми интерфейсами работать вместе.</li>\n	<li><strong><em>Мост (Bridge):</em> </strong>Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.</li>\n	<li><em><strong>Компоновщик (Composite):</strong></em> Позволяет считать единичные объекты и составные объекты единообразно.</li>\n	<li><em><strong>Декоратор (Decorator): </strong></em>Позволяет динамически добавлять новые функции объектам, помещая их в оболочку из других объектов.</li>\n	<li><em><strong>Фасад (Facade):</strong></em> Предоставляет упрощенный интерфейс к сложной системе классов, библиотеке или фреймворку.</li>\n	<li><em><strong>Приспособленец (Flyweight): </strong></em>Эффективно поддерживает большое количество мелких объектов.</li>\n	<li><em><strong>Заместитель (Proxy):</strong></em> Предоставляет заменитель или местозаполнитель для другого объекта, чтобы контролировать доступ к нему.</li>\n</ul>\n\n<p>3. <strong>Поведенческие (Behavioral Patterns)</strong></p>\n\n<ul>\n	<li><em><strong>Поведенческие паттерны</strong></em> регулируют алгоритмы и ответственности между объектами, делают взаимодействие между объектами более гибким.</li>\n	<li><em><strong>Цепочка обязанностей (Chain of Responsibility):</strong></em> Позволяет передавать запросы последовательно по цепочке обработчиков.</li>\n	<li><em><strong>Команда (Command):</strong></em> Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать и т.д.</li>\n	<li><strong><em>Итератор (Iterator):</em> </strong>Предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления.</li>\n	<li><strong><em>Посредник (Mediator):</em> </strong>Уменьшает сложность взаимодействия между объектами, предоставляя централизованное место для управления ими.</li>\n	<li><strong><em>Хранитель (Memento):</em> </strong>Позволяет сохранять и восстанавливать предыдущее состояние объекта без раскрытия подробностей его реализации.</li>\n	<li><em><strong>Наблюдатель (Observer):</strong> </em>Позволяет объектам получать уведомления об изменении состояния других объектов.</li>\n	<li><em><strong>Состояние (State):</strong></em> Позволяет объекту изменять свое поведение при изменении его внутреннего состояния.</li>\n	<li><em><strong>Стратегия (Strategy):</strong></em> Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.</li>\n	<li><em><strong>Шаблонный метод (Template Method):</strong> </em>Определяет скелет алгоритма, позволяя подклассам переопределять некоторые шаги алгоритма, не изменяя его структуру.</li>\n	<li><em><strong>Посетитель (Visitor): </strong></em>Позволяет добавлять новые операции к объектам без изменения классов этих объектов.</li>\n</ul>\n\n<p>Каждый паттерн решает свою уникальную задачу в контексте проектирования ПО, облегчая разработку и поддержку сложных систем.&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',6),(44,'Участки памяти в JVM',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Java Virtual Machine (JVM) управляет системной памятью через различные участки (регионы), каждый из которых выполняет свою роль в процессе выполнения программы. Основные участки памяти следующие:</p>\n\n<p>1. <em><strong>Куча (Heap):</strong></em> Это центральный репозиторий для хранения объектов и экземпляров классов во время выполнения программы. Куча делится на несколько подучастков, таких как Young Generation (молодое поколение), Old Generation (старое поколение) и, иногда, Permanent Generation (PermGen) или Metaspace (начиная с Java 8), в зависимости от ее версии. Сборка мусора (Garbage Collection) активно управляет этой областью памяти, автоматически освобождая пространство, занимаемое объектами, на которые больше нет ссылок.</p>\n\n<p>2. <em><strong>Стек методов (Method Area/Stack):</strong></em> В стеке хранятся локальные переменные, частичные результаты вычислений и информация о вызовах методов для каждого потока выполнения. Каждый поток имеет свой собственный стек, и он создается в момент, когда поток начинает выполнение. Стек методов работает по принципу LIFO (последним пришел &mdash; первым ушел).</p>\n\n<p>3. <em><strong>Куча постоянных (Permanent Generation/Metaspace): </strong></em>Эта область используется для хранения метаданных классов и методов, строковых литералов и других констант класса. Был заменен на Metaspace, который использует нативную память для хранения метаданных классов, что позволяет улучшить производительность и уменьшить вероятность возникновения ошибки <strong>`OutOfMemoryError`</strong> из-за переполнения PermGen.</p>\n\n<p>4. <em><strong>Программный счетчик (Program Counter Register):</strong></em> Этот участок памяти содержит адрес текущей инструкции, которая выполняется в данный момент. Как и стек методов, для каждого потока выполнения существует свой собственный программный счетчик.</p>\n\n<p>5. <em><strong>Нативный стек (Native Stack):</strong></em> Эта область памяти используется для выполнения нативного кода, написанного на других языках программирования, а не на Java. Нативный стек работает аналогично стеку методов, но предназначен для обработки вызовов нативных методов.</p>\n\n<p>Эти участки памяти играют ключевую роль в выполнении программ и управлении ресурсами. JVM оптимизирует использование этих областей для повышения производительности и эффективности работы программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',1),(45,'Полиморфизм','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Полиморфизм</strong>&nbsp;&ndash; это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</p>\n\n<p>Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).</p>\n\n<p><em>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля &ndash; джойстик.</em></p>\n\n<p><em>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.</em></p>\n\n<p><em>Полиморфная переменная</em>, это переменная, которая может принимать значения разных типов, а&nbsp;<em>полиморфная функция</em>, это функция, у которой хотя бы один аргумент является полиморфной переменной. Выделяют два вида полиморфных функций:</p>\n\n<ul>\n	<li><em>ad hoc</em>, функция ведет себя по разному для разных типов аргументов (например, функция&nbsp;<code>draw()</code>&nbsp;&mdash; рисует по разному фигуры разных типов);</li>\n	<li><em>параметрический</em>, функция ведет себя одинаково для аргументов разных типов (например, функция&nbsp;<code>add()</code>&nbsp;&mdash; одинаково кладет в контейнер элементы разных типов).</li>\n</ul>\n\n<p>Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.</p>\n\n<p>Пример:</p>\n\n<p>Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:</p>\n\n<pre>\n<code>public class User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public void callAnotherUser(int number, AbstractPhone phone) {\n// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!\n        phone.call(number);\n    }\n}</code></pre>\n\n<p>Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:</p>\n\n<pre>\n<code>public class ThomasEdisonPhone extends AbstractPhone {\n\n    public ThomasEdisonPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вращайте ручку\");\n        System.out.println(\"Сообщите номер абонента, сэр\");\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}</code></pre>\n\n<p>Обычный стационарный телефон:</p>\n\n<pre>\n<code>public class Phone extends AbstractPhone {\n\n    public Phone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вызываю номер\" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}</code></pre>\n\n<p>И, наконец, крутой видеотелефон:</p>\n\n<pre>\n<code>public class VideoPhone extends AbstractPhone {\n\n    public VideoPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Подключаю видеоканал для абонента \" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"У вас входящий видеовызов...\" + inputNumber);\n    }\n}</code></pre>\n\n<p>Создадим объекты в методе main() и протестируем метод callAnotherUser:</p>\n\n<pre>\n<code>AbstractPhone firstPhone = new ThomasEdisonPhone(1879);\nAbstractPhone phone = new Phone(1984);\nAbstractPhone videoPhone=new VideoPhone(2018);\nUser user = new User(\"Андрей\");\nuser.callAnotherUser(224466,firstPhone);\n// Вращайте ручку\n//Сообщите номер абонента, сэр\nuser.callAnotherUser(224466,phone);\n//Вызываю номер 224466\nuser.callAnotherUser(224466,videoPhone);\n//Подключаю видеоканал для абонента 224466</code></pre>\n\n<p>Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма &ndash; выбор реализации в процессе выполнения программы.</p>\n\n<p>В примерах классов телефонов, приведенных выше, мы использовали переопределение методов &ndash; прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути, это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы.</p>\n\n<p>Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Полиморфизм &mdash; это принцип, позволяющий объектам с одинаковым интерфейсом иметь различную реализацию. Этот термин происходит от греческих слов, означающих &quot;много форм&quot;. В контексте ООП, полиморфизм позволяет одному и тому же методу работать по-разному в зависимости от контекста, в котором он вызывается, или от объекта, к которому он применяется.</p>\n\n<p>1. <em><strong>Статический (компиляционный) полиморфизм: </strong></em>Реализуется с помощью перегрузки методов и операторов. При перегрузке методов методы в одном классе имеют одинаковое имя, но различаются количеством и типом параметров. Компилятор определяет, какой метод вызывать, исходя из аргументов вызова метода.</p>\n\n<p>&nbsp; &nbsp;Пример:</p>\n\n<pre>\n<code class=\"language-java\">   public class Example {\n       public void display(int a) {\n           System.out.println(\"Число: \" + a);\n       }\n       public void display(String a) {\n           System.out.println(\"Строка: \" + a);\n       }\n   }</code></pre>\n\n<p>2. <em><strong>Динамический (выполнения) полиморфизм:</strong></em> Реализуется с помощью переопределения методов. В этом случае подклассы имеют методы, которые имеют такое же имя и сигнатуру, как и в суперклассе, но реализация методов может отличаться. Какой метод будет вызван, определяется во время выполнения программы, основываясь на типе объекта.</p>\n\n<p>&nbsp; &nbsp;Пример:</p>\n\n<pre>\n<code class=\"language-java\">   class Animal {\n       void sound() {\n           System.out.println(\"Животное издает звук\");\n       }\n   }\n   class Dog extends Animal {\n       @Override\n       void sound() {\n           System.out.println(\"Собака лает\");\n       }\n   }\n\n   Использование:\n   Animal myAnimal = new Dog();\n   myAnimal.sound(); // Выведет: Собака лает</code></pre>\n\n<p><strong>Зачем нужен полиморфизм?</strong></p>\n\n<ul>\n	<li><em><strong>Гибкость и расширяемость кода: </strong></em>Позволяет писать более обобщенный код, который может работать с объектами разных классов. Это упрощает добавление новых классов, которые могут использоваться существующим кодом без его изменения.</li>\n	<li><em><strong>Уменьшение связности:</strong></em> Помогает снизить зависимость между компонентами системы, поскольку компоненты могут взаимодействовать друг с другом через общие интерфейсы, не заботясь о конкретной реализации.</li>\n	<li><em><strong>Сокрытие реализации: </strong></em>Клиентский код может использовать интерфейс без знания о внутренней реализации объекта, что повышает безопасность и модульность программы.</li>\n</ul>\n\n<p>Полиморфизм является ключевым элементом объектно-ориентированного программирования, обеспечивая гибкость и возможности для масштабирования и модификации программ без значительного переписывания кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(46,'final vs. finally vs. finalize','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Модификатор&nbsp;<code>final</code>:</p>\n\n<ul>\n	<li>Класс не может иметь наследников;</li>\n	<li>Метод не может быть переопределен в классах наследниках;</li>\n	<li>Поле не может изменить свое значение после инициализации;</li>\n	<li>Локальные переменные не могут быть изменены после присвоения им значения;</li>\n	<li>Параметры методов не могут изменять своё значение внутри метода.</li>\n</ul>\n\n<p>Оператор&nbsp;<code>finally</code>&nbsp;гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке&nbsp;<code>try-catch</code>.</p>\n\n<p>Метод&nbsp;<code>finalize()</code>&nbsp;вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>\npublic class MainClass {\n\n	public static void main(String args[]) {\n		TestClass a = new TestClass();\n		System.out.println(\"result of a.a() is \" + a.a());\n		a = null;\n		System.gc(); // Принудительно зовём сборщик мусора\n		a = new TestClass();\n		System.out.println(\"result of a.a() is \" + a.a());\n		System.out.println(\"!!! done\");\n	}\n\n}</code></pre>\n\n<pre>\n<code>public class TestClass {\n\n	public int a() {\n		try {\n			System.out.println(\"!!! a() called\");\n			throw new Exception(\"\");\n		} catch (Exception e) {\n			System.out.println(\"!!! Exception in a()\");\n			return 2;\n		} finally {\n			System.out.println(\"!!! finally in a() \");\n		}\n	}\n\n	@Override\n	protected void finalize() throws Throwable {\n		System.out.println(\"!!! finalize() called\");\n		super.finalize();\n	}\n}</code></pre>\n\n<p>Результат выполнения:</p>\n\n<pre>\n<code>!!! a() called\n!!! Exception in a()\n!!! finally in a() \nresult of a.a() is 2\n!!! a() called\n!!! Exception in a()\n!!! finally in a() \n!!! finalize() called\nresult of a.a() is 2\n!!! done</code></pre>\n\n<p>&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевые слова <strong>`final`</strong>,<strong> `finally`</strong>, и <strong>`finalize` </strong>имеют совершенно разные цели и контексты использования, хотя на первый взгляд могут показаться похожими из-за схожести их названий.</p>\n\n<p><strong>final</strong></p>\n\n<p>Это модификатор, который может быть использован с переменными, методами и классами.</p>\n\n<ul>\n	<li>Когда он применяется к переменной, это означает, что переменная может быть присвоена только один раз и её значение не может быть изменено после присваивания.</li>\n	<li>Когда он используется с методом, это предотвращает переопределение метода в подклассах.</li>\n	<li>Когда он применяется к классу, это означает, что класс не может быть наследован.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">final int x = 100; // переменная, которую нельзя изменить\npublic final void myMethod() {} // метод, который нельзя переопределить\npublic final class MyFinalClass {} // класс, от которого нельзя наследоваться</code></pre>\n\n<p><strong>finally</strong></p>\n\n<p>Это блок кода, который используется вместе с блоками <strong>`try`</strong> и <strong>`catch` </strong>для обработки исключений. Блок<strong> `finally` </strong>выполняется всегда после выполнения блока <strong>`try`/`catch`</strong>, независимо от того, было ли выброшено исключение или нет. Это идеальное место для кода очистки, например, для закрытия файловых потоков или освобождения других ресурсов.</p>\n\n<pre>\n<code class=\"language-java\">try {\n    // код, который может вызвать исключение\n} catch (Exception e) {\n    // обработка исключения\n} finally {\n    // код, который выполняется всегда\n}</code></pre>\n\n<p><strong>finalize</strong></p>\n\n<p>Это метод класса <strong>`Object`</strong>, который вызывается сборщиком мусора перед тем, как объект будет уничтожен. Этот метод можно переопределить в классе для реализации очистки ресурсов или других операций перед уничтожением объекта. Однако его использование не рекомендуется из-за его непредсказуемости и малой эффективности, а также потому, что он может вызвать задержку в сборке мусора.</p>\n\n<pre>\n<code class=\"language-java\">@Override\nprotected void finalize() throws Throwable {\n    try {\n        // очистка ресурсов\n    } finally {\n        super.finalize();\n    }\n}</code></pre>\n\n<ul>\n	<li><em><strong>`final`</strong> </em>используется для создания констант, предотвращения наследования классов и переопределения методов.</li>\n	<li><em><strong>`finally`</strong></em> гарантирует выполнение кода после блока<strong> `try`/`catch`</strong>, обычно для очистки ресурсов.</li>\n	<li><strong><em>`finalize`</em> </strong>предназначен для очистки перед уничтожением объекта, но его использование не рекомендуется.</li>\n</ul>\n\n<p>Каждое из этих ключевых слов имеет уникальное применение и важно в контексте разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(47,'Чем singleton отличается от prototype',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Singleton и Prototype относятся к категории порождающих шаблонов проектирования. Они решают разные проблемы и имеют разные применения в разработке программного обеспечения.</p>\n\n<p><strong>Singleton</strong> предназначен для обеспечения того, чтобы класс имел только один экземпляр во всем приложении и предоставлял глобальную точку доступа к этому экземпляру. Это достигается за счет того, что конструктор класса делается приватным, а создание экземпляра класса осуществляется через статический метод, который проверяет, существует ли уже экземпляр этого класса, и если нет, то создает его. Часто используется для управления ресурсами, такими как соединение с базой данных, где необходимо использовать только одно соединение на всё приложение.</p>\n\n<pre>\n<code class=\"language-java\">public class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}</code></pre>\n\n<p><strong>Prototype</strong>, напротив, используется для создания новых объектов, копированием существующего объекта-прототипа. Это полезно, когда создание экземпляра класса является ресурсоемким процессом или когда требуется создать копию объекта, сохраняя его состояние. Это часто достигается с помощью реализации интерфейса<strong> `Cloneable`</strong> и переопределения метода <strong>`clone()`</strong>.</p>\n\n<pre>\n<code class=\"language-java\">public class Prototype implements Cloneable {\n    private String field;\n\n    public Prototype(String field) {\n        this.field = field;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}</code></pre>\n\n<p><strong>Основные отличия:</strong></p>\n\n<ul>\n	<li><em><strong>Цель использования: </strong></em>Singleton гарантирует, что класс имеет только один экземпляр, в то время как Prototype предназначен для создания новых объектов путем копирования существующего объекта.</li>\n	<li><em><strong>Метод создания объекта:</strong></em> В Singleton объект создается через статический метод, контролирующий его экземпляр, в Prototype новый объект создается копированием (клонированием) существующего.</li>\n	<li><em><strong>Применение:</strong></em> Singleton часто используется для управления доступом к ресурсам, которые должны быть единственными в приложении, например, соединение с базой данных. Prototype используется, когда нужно избежать затрат на создание объекта с нуля, вместо этого копируя существующий объект.</li>\n</ul>\n\n<p>Основное отличие между Singleton и Prototype заключается в их цели и способе создания объектов: Singleton обеспечивает единственность экземпляра класса, в то время как Prototype фокусируется на создании новых объектов путем копирования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',6),(48,'Race condition','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Race condition (условие гонки) &mdash; это ситуация в многопоточной или распределенной системе, когда порядок выполнения операций влияет на результат работы программы, и этот порядок не может быть гарантирован. То есть, результат выполнения программы становится непредсказуемым из-за соревнования между потоками за доступ к общим ресурсам.</p>\n\n<p><strong>Часто возникают в следующих случаях:</strong></p>\n\n<ul>\n	<li><em><strong>Доступ к общим данным: </strong></em>Если два или более потока читают и пишут в одну и ту же переменную без должной синхронизации, конечное значение переменной может зависеть от того, в каком порядке потоки выполняют свои операции.</li>\n	<li><em><strong>Зависимость от порядка выполнения:</strong></em> Когда корректность выполнения программы зависит от порядка выполнения операций между потоками, без явного контроля этого порядка.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Counter {\n    private int count = 0;\n\n    public void increment() {\n        count++; // Несмотря на кажущуюся атомарность, операция не атомарна и состоит из трех шагов: чтение, инкремент, запись\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class RaceConditionDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(counter.getCount()); // Ожидаемый результат 2000, но может быть меньше из-за условия гонки\n    }\n}</code></pre>\n\n<p>В этом примере, хотя каждый поток пытается увеличить счетчик на 1000, итоговый результат может быть меньше 2000 из-за них. Это происходит потому, что операция инкремента (<strong>`count++`</strong>) не атомарна и может быть прервана между чтением значения <strong>`count` </strong>и записью обновленного значения обратно в память. В результате, несколько потоков могут прочитать одно и то же значение <strong>`count`</strong> перед тем, как другие потоки успеют его обновить.</p>\n\n<p><strong>Решение проблемы</strong></p>\n\n<p>Для предотвращения этого используются механизмы синхронизации, такие как блокировки (<strong>`synchronized`</strong> блоки), мьютексы, семафоры и другие средства для контроля доступа к общим ресурсам. Эти механизмы гарантируют, что только один поток может выполнять критический участок кода, который взаимодействует с общим ресурсом, в любой момент времени.</p>\n\n<pre>\n<code class=\"language-java\">public synchronized void increment() {\n    count++;\n}</code></pre>\n\n<p>Добавление <strong>`synchronized`</strong> к методу<strong> `increment()`</strong> гарантирует, что в каждый момент времени только один поток может выполнить этот метод, что предотвращает условия гонки в данном случае.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(49,'Жизненный цикл Spring Beans',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Каждый бин (компонент) проходит через жизненный цикл, который начинается с его создания и заканчивается уничтожением. Этот цикл включает в себя ряд этапов, на которых он предоставляет различные точки для настройки поведения бина. Вот основные этапы жизненного цикла:</p>\n\n<p>1. <em><strong>Инстанцирование бина: </strong></em>Создает экземпляр бина из класса определения бина.</p>\n\n<p>2. <em><strong>Заполнение свойств бина:</strong></em> Внедряет значения и ссылки на другие бины в свойства текущего бина, используя конфигурацию, заданную в XML, аннотациях или конфигурации.</p>\n\n<p>3. Вызов методов жизненного цикла `BeanNameAware`, `BeanClassLoaderAware`, `BeanFactoryAware` и т.д.: Если бин реализует один из Aware интерфейсов, он вызывает соответствующие методы, передавая экземпляру бина ссылку на контекст, фабрику бинов и т.д.</p>\n\n<p>4. <em><strong>Post-Processing Bean: </strong></em>Перед инициализацией бина, он дает возможность BeanPostProcessor&#39;ам обработать объект. Это может быть использовано для проксирования бинов или для иной предварительной обработки.</p>\n\n<p>5. <em><strong>Вызов метода инициализации:</strong></em> Если для бина определен метод инициализации (через аннотацию <strong>`@PostConstruct`</strong>, интерфейс <strong>`InitializingBean` </strong>или атрибут<strong> `init-method`</strong> в XML-конфигурации), он вызывает его после того, как все свойства бина были установлены.</p>\n\n<p>6. <em><strong>Готовность к использованию: </strong></em>После вызова метода инициализации бин полностью инициализирован и готов к использованию в приложении.</p>\n\n<p>7. <em><strong>Вызов метода уничтожения: </strong></em>Когда контекст приложения закрывается, и бины должны быть уничтожены, он вызывает метод уничтожения для бинов, которые определяют его (через аннотацию <strong>`@PreDestroy`</strong>, интерфейс <strong>`DisposableBean`</strong> или атрибут <strong>`destroy-method`</strong> в XML-конфигурации).</p>\n\n<p>Эти этапы обеспечивают гибкое управление жизненным циклом бинов, позволяя разработчикам выполнять необходимые действия на каждом этапе, такие как инициализация ресурсов перед использованием бина или очистка ресурсов перед уничтожением бина. Управление жизненным циклом бинов &mdash; ключевая особенность Spring, которая способствует созданию чистого, хорошо структурированного и легко поддерживаемого приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(50,'Идея многопоточности',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Идея многопоточности заключается в параллельном выполнении нескольких задач в рамках одного приложения для более эффективного использования ресурсов компьютера, особенно процессорного времени, и для улучшения отзывчивости программы.</p>\n\n<p>В однопоточном приложении в любой момент времени выполняется только одна задача. Если эта задача включает в себя ожидание (например, ввод пользователя или чтение данных с диска), процессорное время не используется эффективно. Она же позволяет одновременно выполнять другие задачи во время ожидания, тем самым повышая производительность и отзывчивость приложения.</p>\n\n<p>Основные преимущества:</p>\n\n<ul>\n	<li><em><strong>Повышение производительности:</strong></em> Приложения могут выполнять несколько задач одновременно, что особенно эффективно на многоядерных или многопроцессорных системах, где потоки могут физически выполняться параллельно.</li>\n	<li><em><strong>Отзывчивость приложения: </strong></em>В интерактивных приложениях, таких как графические пользовательские интерфейсы, многопоточность позволяет приложению оставаться отзывчивым к действиям пользователя, даже когда выполняются тяжелые задачи в фоновом режиме.</li>\n	<li><em><strong>Эффективное использование ресурсов: </strong></em>Приложения могут более эффективно использовать доступные системные ресурсы, распределяя задачи между потоками, которые затем могут выполняться параллельно.</li>\n</ul>\n\n<p>Однако она также вводит сложность в разработку программного обеспечения, поскольку разработчикам необходимо учитывать вопросы синхронизации доступа к общим ресурсам, управления состоянием потоков и потенциальных проблем с безопасностью потоков, таких как гонки за данные (race conditions), взаимные блокировки (deadlocks) и проблемы с последовательностью операций.</p>\n\n<p>Примером многопоточности может служить создание потоков через наследование от класса<strong> `Thread`</strong> или реализацию интерфейса <strong>`Runnable`</strong>:</p>\n\n<pre>\n<code class=\"language-java\">class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Поток запущен.\");\n    }\n}\n\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Поток запущен через Runnable.\");\n    }\n}\n\npublic class ThreadExample {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        t1.start();\n\n        Thread t2 = new Thread(new MyRunnable());\n        t2.start();\n    }\n}</code></pre>\n\n<p>В этом примере создаются и запускаются два потока, каждый из которых выполняет свою задачу параллельно основному потоку программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(51,'TreeSet и HashSet',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`TreeSet`</strong> и <strong>`HashSet`</strong> являются двумя разными типами коллекций, которые используются для хранения уникальных элементов. Основное различие между ними заключается в их внутренней реализации и порядке хранения элементов, что влияет на скорость выполнения операций добавления, удаления и поиска элементов.</p>\n\n<p><strong>HashSet</strong></p>\n\n<p>Основан на хеш-таблице. Это означает, что он использует функцию хеширования для определения места хранения элемента в коллекции. Основные характеристики:</p>\n\n<ul>\n	<li><strong>Не гарантирует порядок элементов: </strong>Порядок элементов в нем может меняться со временем и не соответствует порядку добавления.</li>\n	<li><strong>Быстрое выполнение операций: </strong>Добавление, удаление и поиск элемента в нем происходит за постоянное время O(1), предполагая, что хеш-функция равномерно распределяет элементы. Однако, плохое хеширование может привести к ухудшению производительности до O(n) в худшем случае.</li>\n	<li><strong>Использование:</strong> Предпочтительнее использовать, когда важна производительность и не требуется упорядоченность элементов.</li>\n</ul>\n\n<p><strong>TreeSet</strong></p>\n\n<p>Реализует интерфейс<strong> `SortedSet`</strong> и хранит элементы в отсортированном порядке по возрастанию. Внутренне он основан на красно-чёрном дереве. Основные характеристики:</p>\n\n<ul>\n	<li><strong>Гарантирует порядок элементов: </strong>Элементы в нем автоматически сортируются, что позволяет легко получить доступ к самым маленьким или самым большим элементам.</li>\n	<li><strong>Время выполнения операций: </strong>Операции добавления, удаления и поиска в нем выполняются за логарифмическое время O(log n), что медленнее, чем в <strong>`HashSet`</strong>.</li>\n	<li><strong>Использование: </strong>Подходит для случаев, когда необходимо поддерживать упорядоченность элементов, например, для вывода элементов в отсортированном порядке или для выполнения диапазонных поисков.</li>\n</ul>\n\n<p>Основное различие между <strong>`HashSet`</strong> и <strong>`TreeSet`</strong> заключается в способе хранения и упорядочивания элементов. <strong>`HashSet` </strong>предлагает более высокую производительность для базовых операций за счёт использования хеш-таблицы, но не гарантирует порядок элементов. <strong>`TreeSet` </strong>обеспечивает упорядоченное хранение элементов и поддерживает дополнительные операции с отсортированными наборами, но операции с элементами выполняются медленнее.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(52,'Что такое исключение','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Исключение</u> &mdash; это событие (обычно ошибочная ситуация), которое прерывает нормальное выполнение инструкций программы. Они используются для обработки ошибок и других исключительных ситуаций в коде, позволяя программе реагировать на них и, если возможно, восстанавливаться после ошибок, вместо того чтобы просто завершаться с ошибкой.</p>\n\n<p><strong>Зачем они нужны?</strong></p>\n\n<p>Предоставляют способ отделить код обработки ошибок от основного потока выполнения программы. Это улучшает читаемость и поддерживаемость кода, позволяя разработчикам организовать обработку ошибок более эффективно. Использование исключений помогает в следующем:</p>\n\n<p><strong>1. Улучшение читаемости кода:</strong> Поскольку обработка ошибок вынесена в отдельные блоки, основной код становится чище и проще для понимания.<br />\n<strong>2. Простота в обработке ошибок: </strong>Позволяют собирать информацию об ошибке и передавать её выше по стеку вызовов, до тех пор, пока не будет найден подходящий обработчик.<br />\n<strong>3. Разделение логики программы и обработки ошибок: </strong>Это помогает избежать смешивания кода программы с проверками на ошибки, делая программу более модульной.</p>\n\n<p><strong>Как они работают?</strong></p>\n\n<p>Делятся на две основные категории: проверяемые (checked) и непроверяемые (unchecked) исключения.&nbsp;</p>\n\n<ul>\n	<li><strong>Проверяемые исключения</strong>&nbsp;являются теми, которые должны явно обрабатываться в программе. Они являются подклассами <strong>`Exception`</strong>, за исключением класса <strong>`RuntimeException`</strong> и его подклассов.&nbsp;</li>\n	<li><strong>Непроверяемые исключения</strong>&nbsp;включают в себя ошибки (<strong>`Error`</strong>) и исключения времени выполнения (<strong>`RuntimeException`</strong>). Они обычно указывают на ошибки программирования, такие как неправильное использование API или попытки обращения к объекту через ссылку<strong> `null`</strong>.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Example {\n    public static void main(String[] args) {\n        try {\n            int result = 10 / 0; // Это вызовет ArithmeticException\n        } catch (ArithmeticException e) {\n            System.out.println(\"Произошла арифметическая ошибка: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Этот блок выполняется всегда после try/catch\");\n        }\n    }\n}</code></pre>\n\n<p>В этом примере деление на ноль вызывает исключение<strong> `ArithmeticException`</strong>, которое затем перехватывается и обрабатывается в блоке<strong> `catch`</strong>. Блок <strong>`finally`</strong> выполняется независимо от того, возникло исключение или нет, предоставляя возможность для выполнения любых необходимых операций по очистке.</p>\n\n<p><u>Исключение</u> &mdash; это механизм для обработки ошибок и других исключительных ситуаций, который позволяет программе реагировать на проблемы и продолжать выполнение, вместо того чтобы полностью останавливаться. Использование исключений делает код более читаемым, упрощает обработку ошибок и помогает отделять основную логику программы от обработки исключительных ситуаций.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(53,'Инкапсуляция',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Инкапсуляция &mdash; это один из четырех основных принципов ООП, наряду с наследованием, полиморфизмом и абстракцией. Она заключается в сокрытии внутренних данных класса от внешнего мира и предоставлении доступа к этим данным только через методы этого класса. Это делается для того, чтобы обеспечить контроль над тем, как внешний мир взаимодействует с внутренним состоянием объекта, а также для того, чтобы изменения в одной части программы не влияли на другие части.</p>\n\n<p><strong>Зачем нужна инкапсуляция?</strong></p>\n\n<p>1. <em><strong>Защита данных:</strong></em> предотвращает непосредственный доступ к внутреннему состоянию объекта, что может помочь избежать некорректного использования или изменения данных.<br />\n2. <em><strong>Гибкость и модифицируемость:</strong></em> изменения в реализации класса (например, изменение типа данных поля) не влияют на код, который использует этот класс, если доступ к полям осуществляется через методы.<br />\n3. <em><strong>Упрощение интерфейса:</strong></em> пользователю класса предоставляются только необходимые для взаимодействия методы, что упрощает использование класса и снижает риск ошибок.</p>\n\n<p><strong>Как реализуется инкапсуляция?</strong></p>\n\n<p>Обычно достигается с помощью модификаторов доступа: <strong>`private`</strong>,<strong> `public`</strong>, <strong>`protected` </strong>и без модификатора (по умолчанию). Самым строгим является <strong>`private`</strong>, который ограничивает доступ к полю или методу так, что обращаться к нему можно только изнутри класса.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Account {\n    private double balance; // Скрытие поля balance\n\n    public Account(double initialBalance) {\n        if (initialBalance &gt; 0) {\n            balance = initialBalance;\n        }\n    }\n\n    // Метод для добавления средств на счет\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        }\n    }\n\n    // Метод для получения текущего баланса\n    public double getBalance() {\n        return balance;\n    }\n}</code></pre>\n\n<p>В этом примере поле <strong>`balance`</strong> сокрыто от прямого доступа извне класса <strong>`Account`</strong>, а взаимодействие с ним происходит через методы<strong> `deposit`</strong> и <strong>`getBalance`</strong>. Это позволяет контролировать корректность данных (например, добавление на счет отрицательной суммы).</p>\n\n<p>Инкапсуляция &mdash; это сокрытие внутренних данных класса и предоставление контролируемого доступа к этим данным через методы класса. Это обеспечивает безопасность данных, упрощает интерфейс и повышает гибкость кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(54,'Что такое ORM',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>ORM (Object-Relational Mapping, объектно-реляционное отображение) &mdash; это техника, используемая для преобразования данных между несовместимыми типами систем, в частности между объектно-ориентированными языками программирования и реляционными базами данных. ORM предоставляет абстрактный API, который позволяет вам работать с базой данных с использованием объектно-ориентированных подходов, вместо того чтобы писать SQL-запросы.</p>\n\n<p><strong>Ключевые принципы ORM:</strong></p>\n\n<p>1. <em><strong>Отображение таблиц данных на классы:</strong> </em>В нем каждая таблица в базе данных обычно отображается на класс в программе. Это позволяет работать с записями таблицы как с объектами указанного класса.</p>\n\n<p>2. <em><strong>Отображение столбцов таблиц на атрибуты класса: </strong></em>Столбцы таблицы в базе данных отображаются на атрибуты класса, что позволяет обращаться к данным записи прямо через свойства объекта.</p>\n\n<p>3. <strong><em>Управление связями между данными:</em> </strong>Автоматически управляет отношениями между данными, такими как один-ко-многим, многие-ко-многим, позволяя разработчикам легко настраивать и использовать связанные данные.</p>\n\n<p>4. <strong><em>Автоматизация запросов к базе данных:</em> </strong>Позволяет выполнять запросы к базе данных, используя методы и функции высокого уровня, автоматически преобразуя их в SQL-запросы и обратно, что сокращает необходимость в ручной работе с SQL.</p>\n\n<p><strong>Преимущества использования:</strong></p>\n\n<ul>\n	<li><em><strong>Продуктивность разработки: </strong></em>Можно сосредоточиться на логике приложения, а не на деталях реализации базы данных.</li>\n	<li><em><strong>Уменьшение количества кода:</strong></em> Генерирует многие стандартные SQL-запросы автоматически, что уменьшает количество необходимого для написания кода.</li>\n	<li><em><strong>Безопасность: </strong></em>Большинство таких фреймворков автоматически обрабатывают проблемы безопасности, такие как SQL-инъекции.</li>\n	<li><em><strong>Переносимость:</strong></em> Запросы, сгенерированные им, могут быть независимы от конкретной СУБД, что упрощает миграцию между разными базами данных.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><em><strong>Сложность:</strong></em> Может добавить сложность в проект, особенно в случаях, когда требуется настройка производительности или обработка сложных запросов.</li>\n	<li><em><strong>Производительность:</strong></em> В некоторых случаях автоматически генерируемые запросы могут быть менее оптимизированы, чем ручно написанные SQL-запросы.</li>\n</ul>\n\n<p>Примеры популярных ORM фреймворков включают Hibernate, JPA (Java Persistence API), MyBatis и другие. Они обеспечивают разработчикам инструменты для эффективной работы с базой данных в объектно-ориентированном стиле.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(55,'Чем отличается операция map от flatMap','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Операции <strong>`map`</strong> и<strong> `flatMap` </strong>являются важными концепциями в функциональном программировании и широко используются во многих языках программирования, в контексте работы с коллекциями и потоками данных (streams). Хотя обе операции применяют функцию к элементам потока или коллекции, между ними есть ключевые отличия в поведении и результате выполнения.</p>\n\n<p><strong>Операция map</strong></p>\n\n<p>Применяет заданную функцию к каждому элементу коллекции или потока и возвращает новую коллекцию или поток, состоящий из результатов применения этой функции. Важно отметить, что при ее использовании количество элементов во входной и выходной коллекции (или потоке) остается неизменным.</p>\n\n<pre>\n<code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);\nList&lt;Integer&gt; squaredNumbers = numbers.stream()\n                                       .map(n -&gt; n * n)\n                                       .collect(Collectors.toList());\n// squaredNumbers будет содержать [1, 4, 9, 16]</code></pre>\n\n<p><br />\n<strong>Операция flatMap</strong></p>\n\n<p>Также применяет заданную функцию к каждому элементу коллекции или потока, но с одним существенным отличием: ожидается, что функция для каждого элемента вернет поток (или коллекцию) элементов, а<strong> `flatMap`</strong> &quot;сплющивает&quot; все эти потоки (или коллекции) в один поток. Таким образом, его удобно использовать, когда результатом применения функции является коллекция или поток, и вы хотите получить плоский список всех элементов, а не коллекцию коллекций.</p>\n\n<pre>\n<code class=\"language-java\">List&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(\n    Arrays.asList(1, 2),\n    Arrays.asList(3, 4, 5)\n);\nList&lt;Integer&gt; flatList = listOfLists.stream()\n                                    .flatMap(Collection::stream)\n                                    .collect(Collectors.toList());\n// flatList будет содержать [1, 2, 3, 4, 5]</code></pre>\n\n<p><strong>Основные отличия:</strong></p>\n\n<ul>\n	<li><em><strong>Результат:</strong></em> <strong>`map`</strong> преобразует каждый элемент коллекции отдельно и возвращает коллекцию того же размера. <strong>`flatMap` </strong>может преобразовывать каждый элемент в несколько элементов и &quot;сплющивает&quot; результат в одну коллекцию, что может изменить количество элементов в итоговой коллекции.</li>\n	<li><em><strong>Использование:</strong></em><strong> `map`</strong> используется для простых преобразований элементов, а <strong>`flatMap`</strong> &mdash; для преобразований, при которых каждый элемент может быть представлен несколькими элементами в результате.</li>\n</ul>\n\n<p>Выбор между <strong>`map`</strong> и <strong>`flatMap`</strong> зависит от конкретной задачи и желаемой структуры выходных данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',9),(56,'В чем разница между DI и IoC','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Dependency Injection (DI) и Inversion of Control (IoC) &mdash; это два тесно связанных принципа в программировании, особенно в контексте разработки. Хотя эти термины часто используются как взаимозаменяемые, они описывают разные, хотя и взаимосвязанные концепции.</p>\n\n<p><strong>Inversion of Control (IoC)</strong></p>\n\n<p>Это широкий принцип проектирования, при котором управление программой переходит от традиционного выполнения программы к фреймворку или контейнеру. В контексте объектно-ориентированного программирования IoC означает, что объекты не создают или не ищут зависимости (другие объекты) самостоятельно. Вместо этого, какие-то внешние средства (например, фреймворк или контейнер) отвечают за создание этих зависимостей и их предоставление объектам.</p>\n\n<p>Цель &mdash; уменьшить связанность между компонентами программы, делая её более модульной, гибкой и поддерживаемой. IoC достигается различными способами, одним из которых является Dependency Injection.</p>\n\n<p><strong>Dependency Injection (DI)</strong></p>\n\n<p>Это конкретный шаблон реализации IoC, при котором зависимости объекта (например, ссылки на другие объекты) предоставляются ему извне. Он может быть реализован разными способами, включая конструкторы, сеттеры или интерфейсы.</p>\n\n<p>Он упрощает управление зависимостями между объектами, позволяя легко изменять их во время выполнения или для целей тестирования. Благодаря ему, объекты становятся менее зависимыми от конкретных реализаций своих зависимостей и больше ориентированными на интерфейсы.</p>\n\n<p><strong>Основные различия:</strong></p>\n\n<ul>\n	<li><em><strong>IoC</strong></em> &mdash; это более общий принцип, который описывает подход к дизайну, при котором управление программой инвертировано по сравнению с традиционным подходом. IoC можно реализовать разными способами, включая, но не ограничиваясь, Dependency Injection.</li>\n	<li><em><strong>DI</strong></em> &mdash; это метод реализации IoC, который конкретизирует, как зависимости предоставляются объектам. DI является одним из способов достижения принципа IoC.</li>\n</ul>\n\n<p>IoC реализуется через IoC контейнер, который управляет объектами (бинами) и их зависимостями с использованием DI. Это обеспечивает легкость в управлении жизненным циклом объектов и их взаимосвязями, делая приложения легче для разработки, тестирования и поддержки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(57,'Почему синглтон называют антипаттерном','  <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Синглтон (Singleton) часто упоминается как антипаттерн по нескольким причинам, связанным с его использованием и влиянием на дизайн ПО. Хотя он предназначен для обеспечения глобального доступа к единственному экземпляру класса, его применение может привести к различным проблемам:</p>\n\n<p>1. <em><strong>Тестирование:</strong></em> Может затруднять модульное тестирование, поскольку использование глобального состояния означает, что тесты могут влиять друг на друга через изменения его состояния. Это делает тесты менее независимыми и предсказуемыми.</p>\n\n<p>2. <em><strong>Управление зависимостями: </strong></em>Скрывает зависимости классов, использующих его, что затрудняет понимание, тестирование и изменение кода, так как связи между компонентами не являются явными.</p>\n\n<p>3. <em><strong>Гибкость использования: </strong></em>Ограничивает гибкость, так как он фиксирует решение использовать один и только один экземпляр класса. В будущем может возникнуть необходимость в использовании нескольких экземпляров, и изменение синглтона на поддержку этой возможности может быть затруднительным.</p>\n\n<p>4. <em><strong>Многопоточность: </strong></em>В многопоточных приложениях необходимо тщательно управлять созданием единственного его экземпляра, чтобы избежать одновременного создания нескольких экземпляров. Это требует дополнительной синхронизации, которая может снизить производительность.</p>\n\n<p>5. <em><strong>Расширяемость и наследование: </strong></em>Как правило, сложно расширять через наследование, и любые изменения в его реализации могут повлиять на всё приложение.</p>\n\n<p>Из-за этих проблем рекомендуется обдумывать применение синглтона и рассматривать альтернативы, такие как использование паттернов проектирования &quot;Фабрика&quot; (Factory), &quot;Внедрение зависимостей&quot; (Dependency Injection, DI) и &quot;Сервис-локатор&quot; (Service Locator), которые могут предложить большую гибкость, лучшее управление зависимостями и более простое тестирование.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',6),(58,'Hashcode','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Хеш-код</u> &mdash; это целое число, которое возвращается методом<strong> `hashCode()`</strong>, определённым в классе <strong>`Object`</strong>, являющемся родительским для всех классов. Этот метод предназначен для возвращения целочисленного значения, представляющего хеш-код объекта. Он используется для оптимизации хранения и поиска объектов, например, в хеш-таблицах, таких как<strong> `HashMap`</strong>, <strong>`HashSet`</strong>, <strong>`HashTable`</strong>.</p>\n\n<p><strong>Как он работает</strong></p>\n\n<p>Помогает в быстром поиске объектов в коллекциях. Когда объект добавляется в хеш-таблицу, его хеш-код используется для определения того, в каком &quot;сегменте&quot; (или &quot;ячейке&quot;) таблицы он должен быть размещён. При поиске объекта его хеш-код снова вычисляется, чтобы найти, в каком сегменте таблицы он может находиться, что значительно ускоряет процесс поиска по сравнению с последовательным перебором всех элементов.</p>\n\n<p><strong>Важность</strong></p>\n\n<p>Корректная реализация методов <strong>`hashCode()`</strong> и <strong>`equals()` </strong>важна для правильной работы хеш-основанных коллекций. Контракт между<strong> `hashCode()`</strong> и <strong>`equals()` </strong>устанавливает следующие правила:</p>\n\n<p>1. Если два объекта равны согласно методу<strong> `equals(Object)`</strong>, то вызов метода <strong>`hashCode()` </strong>должен возвращать одинаковое целое значение для этих объектов.<br />\n2. Если метод <strong>`hashCode()`</strong> возвращает разные целые значения для двух объектов, это не обязательно означает, что объекты не равны.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Person {\n    private String name;\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n               Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`hashCode()`</strong> и<strong> `equals()`</strong> переопределены таким образом, что <strong>`Person` </strong>с одинаковыми <strong>`name`</strong> и <strong>`age` </strong>будет иметь одинаковый хеш-код и считаться равным. Это позволяет использовать объекты <strong>`Person`</strong> в качестве ключей в <strong>`HashMap`</strong> или элементов в<strong> `HashSet` </strong>с ожидаемым поведением.</p>\n\n<p>Метод <strong>`hashCode()`</strong> играет ключевую роль в управлении доступом к объектам в хеш-таблицах. Правильная реализация<strong> `hashCode()` </strong>и <strong>`equals()` </strong>обеспечивает эффективное и корректное использование объектов в качестве ключей в хеш-картах и элементов в множествах.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(59,'Ключевое слово final',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевое слово <strong>`final` </strong>используется для обозначения окончательности: оно может применяться к переменным, методам и классам, придавая им соответствующие свойства неизменяемости, непереопределяемости и ненаследуемости.</p>\n\n<p><strong>Применение к переменным</strong></p>\n\n<p>Это означает, что её значение не может быть изменено после инициализации. В случае примитивных типов данных значение этой переменной будет оставаться неизменным, а в случае ссылочных типов данных нельзя будет изменить ссылку на объект, хотя состояние самого объекта изменить можно (если он не immutable).</p>\n\n<pre>\n<code class=\"language-java\">final int MAX_VALUE = 10;\n// MAX_VALUE = 15; // Это вызовет ошибку компиляции</code></pre>\n\n<p><strong>Применение к методам</strong></p>\n\n<p>ЭЭто означает, что метод не может быть переопределен в подклассах. Это используется для сохранения алгоритма метода от изменений, гарантируя, что поведение метода останется неизменным во всех производных классах.</p>\n\n<pre>\n<code class=\"language-java\">public final void showNumber() {\n    System.out.println(\"Номер\");\n}</code></pre>\n\n<p><strong>Применение к классам</strong></p>\n\n<p>Это означает, что класс не может иметь подклассов. Таким образом, класс будет всегда использоваться в его первоначальном виде, без возможности расширения его функционала через наследование. Это полезно, когда нужно обеспечить безопасность или предотвратить изменения в определенной части кода.</p>\n\n<pre>\n<code class=\"language-java\">public final class MyFinalClass {\n    // Класс не может быть наследован\n}</code></pre>\n\n<p><strong>Почему и когда использовать ?</strong></p>\n\n<p>1. <em><strong>Безопасность:</strong></em> Использование его с переменными может предотвратить непреднамеренное изменение данных.<br />\n2. <em><strong>Проектирование классов и методов:</strong></em> Классы и методы гарантируют, что поведение не будет изменено в производных классах, что может быть важно для сохранения неизменяемости логики программы.<br />\n3. <em><strong>Оптимизация: </strong></em>Компилятор и виртуальная машина Java могут использовать его для оптимизации выполнения программы, поскольку заранее известно, что некоторые вещи не изменятся.</p>\n\n<p>Ключевое слово `final` используется для обозначения неизменяемости переменных, непереопределяемости методов и ненаследуемости классов. Оно помогает улучшить безопасность, проектирование и производительность программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(60,'Нормальные формы в SQL','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В теории реляционных БД существует несколько нормальных форм, каждая из которых представляет собой определенный уровень нормализации данных. Она помогает уменьшить избыточность данных и улучшить их структуру, что облегчает их обслуживание и повышает эффективность базы данных. Вот основные нормальные формы:</p>\n\n<p>1. <em><strong>Первая нормальная форма (1NF): </strong></em>Требует, чтобы значения в каждом столбце таблицы были атомарными (неделимыми), и чтобы в таблице был уникальный идентификатор (ключ).</p>\n\n<p>2. <em><strong>Вторая нормальная форма (2NF): </strong></em>Достигается, когда таблица находится в 1NF, и все атрибуты (не ключевые поля) полностью зависят от первичного ключа.</p>\n\n<p>3. <em><strong>Третья нормальная форма (3NF): </strong></em>Таблица должна быть во 2NF, и все её атрибуты должны быть зависимы только от первичного ключа, а не от других не ключевых атрибутов.</p>\n\n<p>4. <em><strong>Нормальная форма Бойса-Кодда (BCNF): </strong></em>Усиление 3NF, требующее, чтобы каждый детерминант был кандидатом в ключи. Это помогает разрешить некоторые проблемы, которые могут оставаться после применения 3NF.</p>\n\n<p>5. <em><strong>Четвертая нормальная форма (4NF):</strong></em> Требует, чтобы таблица была в BCNF и не содержала многозначных зависимостей, кроме зависимостей, обусловленных первичным ключом.</p>\n\n<p>6. <em><strong>Пятая нормальная форма (5NF):</strong></em> Таблица должна быть в 4NF, и все её объединения должны быть без потерь, то есть любые две таблицы, полученные в результате декомпозиции, должны успешно соединяться обратно в исходную таблицу без потери данных.</p>\n\n<p>7. <em><strong>Доменно-ключевая нормальная форма (DKNF):</strong></em> Достигается, когда таблица имеет только ограничения домена и ключей, исключая любые другие виды логических зависимостей.</p>\n\n<p>Существуют и другие, менее известные и редко используемые нормальные формы, такие как шестая нормальная форма (6NF), предназначенная для определенных типов временных баз данных. Однако на практике большинство баз данных нормализуются до третьей или, реже, до четвертой нормальной формы, поскольку дальнейшая нормализация может привести к ухудшению производительности и усложнению структуры базы данных без значительного прироста в эффективности управления данными.<br />\n&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(61,'JOIN SQL',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Существует несколько видов операций соединения (JOIN), которые позволяют объединять строки из двух или более таблиц на основе связанных между ними столбцов. Вот его основные виды:</p>\n\n<p><strong>INNER JOIN</strong></p>\n\n<ul>\n	<li>Возвращает строки, когда существует хотя бы одно совпадение в обеих таблицах. Если в одной из таблиц нет совпадений, строки из этой таблицы не включаются в результат.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nINNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>LEFT JOIN (или LEFT OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает все строки из левой таблицы и совпавшие строки из правой таблицы. Если совпадений в правой таблице нет, результат будет содержать NULL в столбцах правой таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nLEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>RIGHT JOIN (или RIGHT OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает все строки из правой таблицы и совпавшие строки из левой таблицы. Если совпадений в левой таблице нет, результат будет содержать NULL в столбцах левой таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nRIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>FULL JOIN (или FULL OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает строки, когда существует хотя бы одно совпадение в любой из таблиц. Если нет совпадений, результат будет содержать NULL как в столбцах левой, так и в столбцах правой таблицы для этих строк.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nFULL JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>CROSS JOIN</strong></p>\n\n<ul>\n	<li>Возвращает декартово произведение всех строк из левой таблицы на все строки из правой таблицы. Этот тип соединения не требует указания условия соединения и может привести к очень большому объему результата, если таблицы содержат много строк.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nCROSS JOIN Customers;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n\n<ul>\n	<li>Не является отдельным типом, а скорее методикой, при которой таблица соединяется сама с собой, как бы будучи двумя разными таблицами. Это полезно для выполнения операций сравнения внутри одной и той же таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2\nFROM Customers A, Customers B\nWHERE A.CustomerID &lt; B.CustomerID;</code></pre>\n\n<p>Каждый тип JOIN используется в зависимости от требуемых в запросе данных и логики их соединения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(62,'Модификаторы доступа','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Модификаторы доступа</u> &mdash; это ключевые слова, которые устанавливают уровень доступа к классам, методам, конструкторам и переменным. Они определяют, откуда именно можно обращаться к элементам программы, обеспечивая тем самым инкапсуляцию и безопасность данных.</p>\n\n<p>Существует четыре основных модификаторов:</p>\n\n<p>1.<strong> `private`:</strong> Самый строгий уровень доступа. Элементы, объявленные как `private`, доступны только внутри того класса, где они были объявлены.<br />\n&nbsp; &nbsp;<br />\n2. <strong>`default` (без модификатора): </strong>Если модификатор доступа не указан, то элемент доступен всем классам в том же пакете. Вне пакета эти элементы недоступны.<br />\n&nbsp; &nbsp;<br />\n3. <strong>`protected`: </strong>Элементы с модификатором <strong>`protected` </strong>доступны внутри того же пакета, а также в подклассах, даже если они находятся в других пакетах.<br />\n&nbsp; &nbsp;<br />\n4. <strong>`public`:</strong> Элементы, объявленные как <strong>`public`</strong>, доступны из любого места программы.</p>\n\n<p>Применение:</p>\n\n<p>Используются для управления доступом к компонентам класса (полям, методам, конструкторам) и к самим классам. Они помогают скрыть внутреннее состояние объекта и реализацию методов, тем самым обеспечивая инкапсуляцию и сокрытие деталей реализации.&nbsp;</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Example {\n    private int privateVar = 10; // Доступен только внутри класса Example\n    int defaultVar = 20;         // Доступен классам в том же пакете\n    protected int protectedVar = 30; // Доступен в том же пакете и в подклассах\n    public int publicVar = 40;       // Доступен из любого места программы\n}</code></pre>\n\n<p><strong>Зачем они нужны?</strong></p>\n\n<p>Использование их важно по нескольким причинам:</p>\n\n<ul>\n	<li><strong>Инкапсуляция: </strong>Ограничивает доступ к данным и методам класса, позволяя скрыть детали реализации и изменять их без влияния на другие части программы.</li>\n	<li><strong>Безопасность:</strong> Предотвращает непреднамеренный доступ или изменение важных данных программы.</li>\n	<li><strong>Организация кода: </strong>Помогает организовать код, делая его более читаемым и удобным для поддержки.</li>\n</ul>\n\n<p>Модификаторы доступа позволяют контролировать уровень доступа к различным элементам программы, обеспечивая тем самым безопасность, инкапсуляцию и упорядоченность кода. Они играют важную роль в ООП, позволяя создавать более безопасные и легко поддерживаемые приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(63,'Оптимистичная и пессимистичная блокировки','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Оптимистичная и пессимистичная блокировки</u> &mdash; это два подхода к управлению доступом к данным в многопоточных приложениях или в системах управления базами данных (СУБД), где требуется координация доступа к ресурсам для предотвращения конфликтов и обеспечения целостности данных.</p>\n\n<p><strong>Пессимистичная блокировка</strong></p>\n\n<p>Предполагает, что конфликты при доступе к данным вероятны, и применяет стратегии блокировки для предотвращения одновременного изменения данных несколькими потоками или транзакциями. При использовании пессимистичного подхода транзакция блокирует данные в момент их чтения или записи и удерживает блокировку до завершения транзакции, не позволяя другим транзакциям изменять данные до момента освобождения блокировки.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Простота реализации и понимания.</li>\n	<li>Гарантия отсутствия конфликтов при изменении данных.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Высокий риск взаимоблокировок.</li>\n	<li>Ограниченная масштабируемость и производительность из-за длительного удержания блокировок.</li>\n</ul>\n\n<p><strong>Оптимистичная блокировка</strong></p>\n\n<p>Исходит из предположения, что конфликты при доступе к данным случаются редко, и не блокирует данные на время чтения. Вместо этого она позволяет нескольким транзакциям одновременно читать и подготавливать изменения данных, но перед фиксацией изменений проверяет, не были ли изменены данные другими транзакциями с момента последнего чтения. Если данные были изменены, транзакция откатывается и может быть повторена.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Уменьшает вероятность взаимоблокировок.</li>\n	<li>Улучшает масштабируемость и производительность за счет уменьшения времени удержания блокировок.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Сложнее в реализации и может потребовать дополнительных проверок и механизмов отката.</li>\n	<li>Возможность необходимости повторения транзакций, что может увеличить количество работы в системах с высокой конкуренцией.</li>\n</ul>\n\n<p>Выбор между оптимистичной и пессимистичной блокировками зависит от характера приложения, частоты конфликтов при доступе к данным и требований к производительности и масштабируемости. Пессимистичная блокировка подходит для сценариев с высокой конкуренцией за ресурсы, где важно гарантировать целостность данных в каждый момент времени. Оптимистичная блокировка эффективна в системах, где конфликты редки, и предпочтение отдается максимальной производительности и масштабируемости.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(64,'Что такое монитор','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Монитор</strong>, мьютекс (mutex) &ndash; это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.</p>\n\n<p>Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 &ndash; ресурс свободен. Если не 0 &ndash; ресурс занят. Можно встать в очередь и ждать его освобождения.</p>\n\n<p>В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он так: любой нестатический&nbsp;<code>synchronized</code>-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на&nbsp;<code>this</code>). Если это удалось &ndash; метод исполняется. Если нет &ndash; поток останавливается и ждет, пока монитор будет отпущен.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В контексте многопоточного программирования, монитор &mdash; это механизм синхронизации, который используется для управления доступом к объекту из разных потоков. Каждый объект имеет связанный с ним монитор, который помогает в реализации блоков синхронизации, позволяя контролировать, когда поток может войти в блок кода, изменяющий состояние объекта.</p>\n\n<p><strong>Как он работает?</strong></p>\n\n<p>Когда поток входит в синхронизированный блок кода (обозначенный ключевым словом <strong>`synchronized`</strong>), он захватывает монитор объекта. В это время любой другой поток, который пытается войти в синхронизированный блок кода, использующий тот же монитор, будет заблокирован и вынужден ждать, пока монитор не будет освобождён.</p>\n\n<p>После завершения работы в синхронизированном блоке, поток освобождает монитор, позволяя другим потокам захватить его и войти в синхронизированный блок кода.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}</code></pre>\n\n<p>В этом примере, методы <strong>`increment`</strong> и<strong> `getCount`</strong> синхронизированы по объекту <strong>`Counter`</strong>. Это означает, что одновременно только один поток может выполнять один из этих методов. Если один поток уже выполняет <strong>`increment`</strong>, другой поток, пытающийся выполнить<strong> `increment`</strong> или <strong>`getCount`</strong>, будет заблокирован до тех пор, пока первый поток не завершит выполнение метода и не освободит монитор объекта.</p>\n\n<p><strong>Почему это важно?</strong></p>\n\n<p>Мониторы важны для обеспечения потокобезопасности, когда несколько потоков работают с общими данными. Без должной синхронизации возможны конфликты и непредсказуемое поведение программы из-за одновременных изменений данных разными потоками. Мониторы помогают предотвратить такие проблемы, гарантируя, что только один поток может изменять данные в один момент времени.</p>\n\n<p><u>Монитор</u> &mdash; это механизм синхронизации, который позволяет управлять доступом к объектам в многопоточной среде, обеспечивая безопасность и целостность данных при их изменении разными потоками. Использование мониторов позволяет разработчикам писать более надежные и потокобезопасные программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',5),(65,'Чем отличается where от having','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`WHERE`</strong> и <strong>`HAVING` </strong>используются для фильтрации записей, но они применяются на разных этапах выполнения запроса и имеют разные цели.</p>\n\n<p><strong>WHERE</strong></p>\n\n<p>Применяется до агрегации данных. Это значит, что фильтрация происходит непосредственно на строках исходной таблицы или результата объединения таблиц, до того как произойдет любая операция группировки (<strong>`GROUP BY`</strong>) или агрегирования (<strong>`SUM`</strong>,<strong> `COUNT`</strong>, <strong>`AVG`</strong> и т.д.).<br />\nИспользуется для фильтрации строк, которые будут включены в результаты группировки или в финальный набор данных, если группировка не используется.<br />\nНе может использоваться для фильтрации агрегированных значений.</p>\n\n<p>Пример использования:</p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nWHERE salary &gt; 1000\nGROUP BY employee_id;</code></pre>\n\n<p>В этом примере он фильтрует строки, где зарплата больше 1000, до того, как произойдет агрегация данных по<strong> `employee_id`</strong>.</p>\n\n<p><strong>HAVING</strong></p>\n\n<p>Применяется после агрегации данных. Это означает, что фильтрация происходит уже на агрегированных результатах, полученных после применения <strong>`GROUP BY` </strong>и агрегатных функций.<br />\nИспользуется для фильтрации групп в результате запроса с группировкой.<br />\nМожет использоваться только с<strong> `GROUP</strong></p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nGROUP BY employee_id\nHAVING SUM(salary) &gt; 10000;</code></pre>\n\n<p><strong>BY`</strong> или для фильтрации результатов, полученных с помощью агрегатных функций.</p>\n\n<p>Пример использования:</p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nGROUP BY employee_id\nHAVING SUM(salary) &gt; 10000;</code></pre>\n\n<p>В этом примере он фильтрует группы, где суммарная зарплата по<strong> `employee_id`</strong> больше 10000, после того как данные были сгруппированы и агрегированы.</p>\n\n<p>Основные отличия</p>\n\n<ul>\n	<li><em><strong>Момент применения:</strong></em> <strong>`WHERE`</strong> применяется до агрегации, <strong>`HAVING`</strong> &mdash; после.</li>\n	<li><em><strong>Цель использования:</strong></em> <strong>`WHERE` </strong>фильтрует строки, <strong>`HAVING`</strong> фильтрует группы или агрегированные значения.</li>\n	<li><em><strong>Условия использования:</strong></em> <strong>`WHERE` </strong>может использоваться в любом запросе,<strong> `HAVING` </strong>обычно используется с<strong> `GROUP BY` </strong>или для фильтрации агрегированных значений.</li>\n</ul>\n\n<p>Эти различия делают <strong>`WHERE`</strong> и<strong> `HAVING` </strong>специализированными инструментами для разных этапов и целей фильтрации данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',10),(66,'Что такое hibernate',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Hibernate &mdash; это популярный фреймворк для объектно-реляционного отображения (ORM). Он предоставляет прозрачный слой для маппинга (отображения) объектно-ориентированных моделей данных на традиционные реляционные базы данных. Он облегчает разработку приложений, автоматизируя и скрывая многие сложности, связанные с взаимодействием с базой данных, такие как установление соединения, выполнение SQL-запросов и обработка результатов.</p>\n\n<p><strong>Основные особенности Hibernate:</strong></p>\n\n<p>1. <em><strong>Упрощение разработки:</strong></em> Автоматизирует большую часть кода, который традиционно необходимо писать вручную для работы с базой данных, такого как SQL-запросы и обработка JDBC-результата. Это позволяет разработчикам сосредоточиться на бизнес-логике приложения.</p>\n\n<p>2. <em><strong>Поддержка объектно-реляционного отображения:</strong></em> Предоставляет богатые возможности для маппинга сложных иерархий объектов Java в реляционные таблицы базы данных, включая наследование, композицию, ассоциации (один-к-одному, один-ко-многим, многие-ко-многим).</p>\n\n<p>3. <em><strong>Независимость от базы данных: </strong></em>Обеспечивает независимость от конкретной СУБД, благодаря чему те же самые объектные модели и бизнес-логика могут использоваться с различными базами данных без изменения кода.</p>\n\n<p>4. <em><strong>Кэширование:</strong></em> Предлагает мощные механизмы кэширования первого и второго уровней, что может значительно улучшить производительность приложения за счет уменьшения количества запросов к базе данных.</p>\n\n<p>5. <em><strong>Управление транзакциями и сессиями:</strong></em> Управляет сессиями и транзакциями, обеспечивая гибкость и надежность в обработке данных.</p>\n\n<p>6. <em><strong>HQL и Criteria API:</strong></em> Hibernate Query Language (HQL) &mdash; это объектно-ориентированный язык запросов, аналогичный SQL, но работающий с объектами, а не с таблицами. Criteria API предоставляет программный способ составления запросов через вызовы методов, что делает код более читаемым и безопасным от SQL-инъекций.</p>\n\n<p>7. <em><strong>Аннотации и XML:</strong></em> Позволяет настраивать маппинг как с использованием XML-файлов, так и через аннотации в коде, что упрощает конфигурацию и делает её более наглядной.</p>\n\n<p>Hibernate значительно упрощает разработку Java EE-приложений, автоматизируя рутинную работу по взаимодействию с базой данных и позволяя сосредоточиться на создании сложной логики приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(67,'String pool',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Пул строк (String Pool) &mdash; это специальная область в куче (Heap), предназначенная для хранения уникальных экземпляров строковых литералов. JVM создает пул строк для экономии памяти и увеличения скорости выполнения программы за счет повторного использования объектов типа<strong> `String`</strong>.</p>\n\n<p><strong>Как работает пул строк?</strong></p>\n\n<p>Когда в коде создается строка через строковый литерал (например,<strong> `String s = &quot;Hello&quot;;`</strong>), JVM сначала проверяет пул строк. Если строка с таким же значением уже присутствует в пуле, то новый объект не создается. Вместо этого переменной <strong>`s` </strong>присваивается ссылка на уже существующий объект в пуле. Если же такой строки в пуле нет, JVM создает новый объект строки в пуле и возвращает ссылку на него.</p>\n\n<p>Это поведение отличается от создания строк через оператор<strong> `new`</strong> (например, <strong>`String s = new String(&quot;Hello&quot;);`</strong>). В этом случае в куче всегда создается новый объект <strong>`String`</strong>, независимо от того, содержится ли такая же строка в пуле строк или нет.</p>\n\n<p>Примеры</p>\n\n<pre>\n<code class=\"language-java\">String s1 = \"Hello\"; // Создается в пуле строк, если такой строки еще нет\nString s2 = \"Hello\"; // Не создается новый объект, s2 ссылается на тот же объект, что и s1\nString s3 = new String(\"Hello\"); // Создается новый объект вне пула строк\n\nSystem.out.println(s1 == s2); // true, т.к. s1 и s2 указывают на один и тот же объект в пуле строк\nSystem.out.println(s1 == s3); // false, т.к. s3 указывает на другой объект вне пула строк</code></pre>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p>Помогает оптимизировать использование памяти и повысить производительность приложений:</p>\n\n<ul>\n	<li><em><strong>Экономия памяти:</strong></em> Поскольку строки, созданные как литералы, разделяются и хранятся в пуле, это сокращает общее количество создаваемых объектов <strong>`String`</strong>, экономя память.</li>\n	<li><em><strong>Повышение скорости: </strong></em>Проверка наличия строки в пуле и повторное использование существующих строковых объектов может быть быстрее, чем создание новых объектов.</li>\n</ul>\n\n<p><strong>Как поместить строку в пул строк?</strong></p>\n\n<p>Можно использовать метод<strong> `intern()`</strong> класса<strong> `String`</strong>. Если строка, вызывающая метод <strong>`intern()`</strong>, еще не находится в пуле, то она добавляется туда, а затем возвращается ссылка на эту строку из пула. Если строка уже присутствует в пуле, то просто возвращается ссылка на уже существующую строку.</p>\n\n<p>Пул строк &mdash; это механизм для оптимизации использования памяти и повышения производительности за счет повторного использования уникальных строковых литералов. Он позволяет избежать создания множественных копий одинаковых строковых объектов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(68,'Почему Map стоит особняком в иерархии коллекций','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс <strong>`Map` </strong>занимает особое место в иерархии коллекций и, строго говоря, не является частью Collection Framework. Основная причина этого заключается в том, что он работает с парами &quot;ключ-значение&quot;, а не с индивидуальными элементами, как это делают коллекции, такие как <strong>`List`</strong>,<strong> `Set`</strong>, и т.д., которые хранят только объекты.</p>\n\n<p>Основные отличия от других коллекций:</p>\n\n<p>1. <em><strong>Пары ключ-значение:</strong></em> Хранит данные в виде пар &quot;ключ-значение&quot;, где каждый ключ уникален, и каждому ключу соответствует ровно одно значение. В коллекциях, таких как<strong> `List` </strong>или<strong> `Set`</strong>, хранятся только отдельные объекты.</p>\n\n<p>2. <em><strong>Уникальные ключи:</strong></em> В отличие от списков, где элементы могут дублироваться, в нем каждый ключ уникален, и попытка вставить в него новую пару &quot;ключ-значение&quot; с уже существующим ключом приведет к замене старого значения новым.</p>\n\n<p>3. <em><strong>Доступ к элементам: </strong></em>Доступ к его элементам осуществляется по ключу, а не по индексу. В коллекциях, таких как <strong>`List`</strong>, доступ к элементам осуществляется по индексу.</p>\n\n<p>4. <em><strong>Не реализует интерфейс `Collection`: </strong></em>Поскольку он работает с парами &quot;ключ-значение&quot; и имеет уникальные операции и поведение, не совместимые с интерфейсом<strong> `Collection`</strong>, он не включается в иерархию коллекций как его часть.</p>\n\n<p>5. <em><strong>Итерация:</strong> </em>Итерация по нему отличается от итерации по другим коллекциям. Для перебора его элементов можно использовать набор ключей (keySet()), коллекцию значений (values()) или набор пар &quot;ключ-значение&quot; (entrySet()).</p>\n\n<p>6. <em><strong>Функциональность:</strong></em> Предоставляет уникальные методы, такие как<strong> `put()`</strong>, <strong>`get()`</strong>, <strong>`remove()`</strong> по ключу, которые не имеют прямых аналогов в других типах коллекций.</p>\n\n<p>Из-за этих особенностей <strong>`Map`</strong> считается отдельной частью структуры данных, предназначенной для работы с ассоциативными массивами, где каждому ключу соответствует значение. Это делает<strong> `Map`</strong> идеальным инструментом для таких задач, как представление словарей, кэширование объектов и других ситуаций, где необходимо эффективно находить объект по уникальному идентификатору.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(69,'Зачем нужен Spring Framework','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Spring Framework &mdash; это мощный и гибкий фреймворк для разработки приложений. Он предоставляет широкий спектр функциональности, который делает разработку более простой и удобной. Вот основные причины, по которым Spring Framework стал настолько популярен среди разработчиков:</p>\n\n<p>1. <strong>Упрощение разработки</strong></p>\n\n<p>Он упрощает создание сложных приложений, предоставляя шаблоны проектирования и кода для решения общих задач, таких как управление транзакциями, работа с базой данных, обработка веб-запросов и многое другое.</p>\n\n<p>2. <strong>Dependency Injection (DI) и Inversion of Control (IoC)</strong></p>\n\n<p>Он реализует эти принципы через свой IoC контейнер, что упрощает управление зависимостями между объектами. Это позволяет разработчикам создавать более модульные и легко тестируемые приложения.</p>\n\n<p>3. <strong>Обширная поддержка данных</strong></p>\n\n<p>Фреймворк предлагает мощную поддержку для работы с базами данных, включая интеграцию с JPA (Java Persistence API), Hibernate и другими ORM (Object-Relational Mapping) технологиями. Он упрощает доступ к данным и уменьшает количество необходимого бойлерплейта.</p>\n\n<p>4. <strong>Транзакционное управление</strong></p>\n\n<p>Предоставляет декларативное управление транзакциями, позволяя разработчикам легко управлять транзакциями на уровне методов с помощью аннотаций.</p>\n\n<p>5.<strong> Модульность</strong></p>\n\n<p>Состоит из множества модулей, которые можно независимо использовать в зависимости от потребностей проекта. Это делает его легко адаптируемым к любым типам проектов.</p>\n\n<p>6. <strong>Интеграция</strong></p>\n\n<p>Обеспечивает интеграцию с другими фреймворками и библиотеками, такими как JMS (Java Message Service), JMX (Java Management Extensions), электронной почтой, тасками, планированием и многим другим.</p>\n\n<p>7. <strong>Поддержка веб-разработки</strong></p>\n\n<p>MVC (Model-View-Controller) предоставляет платформу для создания веб-приложений на стороне сервера, включая RESTful приложения, обеспечивая гибкость и мощные возможности.</p>\n\n<p>8. <strong>Безопасность</strong></p>\n\n<p>Spring Security предлагает комплексные решения для аутентификации, авторизации, защиты от распространенных атак, таких как сессионный хайджекинг, кросс-сайтовый скриптинг и т.д.</p>\n\n<p>9. <strong>Облачные и микросервисные архитектуры</strong></p>\n\n<p>Spring Boot и Spring Cloud предлагают решения для упрощения разработки микросервисных архитектур и облегчения развертывания приложений в облаке.</p>\n\n<p>Spring Framework снимает множество распространенных проблем, с которыми можно столкнуться, и позволяет сосредоточиться на бизнес-логике приложения, что делает его одним из самых популярных и широко используемых фреймворков для разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(70,'Что такое Spring контекст',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Spring контекст, известный как Spring ApplicationContext, является центральным интерфейсом, обеспечивающим конфигурацию приложения и доступ к его компонентам (бинам). Этот контекст представляет собой расширенную форму IoC (Inversion of Control) контейнера, который управляет инстанцированием, конфигурацией и сборкой бинов в приложении.</p>\n\n<p>Основные функции Spring контекста:</p>\n\n<p>1. <em><strong>Управление бинами: </strong></em>Автоматически создает и управляет жизненным циклом всех бинов, определенных в конфигурации приложения. Эти бины могут быть сконфигурированы через XML, аннотации или Java-конфигурацию.</p>\n\n<p>2. <em><strong>Внедрение зависимостей:</strong></em> Управляет внедрением зависимостей между бинами, позволяя разработчикам создавать более модульные и тестируемые приложения.</p>\n\n<p>3. <em><strong>Предоставление ресурсов:</strong></em> Предоставляет доступ к файловым ресурсам, таким как текстовые и свойства файлы, облегчая их использование в приложении.</p>\n\n<p>4. <em><strong>Поддержка интернационализации:</strong></em> Позволяет использовать ресурсы для локализации, поддерживая мультиязычность в приложении.</p>\n\n<p>5. <em><strong>Публикация событий:</strong></em> Предоставляет возможность публиковать и слушать события в приложении, что позволяет компонентам взаимодействовать между собой асинхронно.</p>\n\n<p>6. <em><strong>Прозрачная работа с технологиями предприятия:</strong></em> Облегчает работу с JNDI, EJB, валидацией, задачами и планированием, а также предоставляет интеграцию с веб-технологиями.</p>\n\n<p>Примеры:</p>\n\n<ul>\n	<li><strong>Через XML конфигурацию:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    &lt;beans&gt;\n        &lt;bean id=\"myBean\" class=\"com.example.MyClass\"/&gt;\n    &lt;/beans&gt;</code></pre>\n\n<ul>\n	<li><strong>Через аннотации:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    @Component\n    public class MyComponent {\n        // Класс, который будет автоматически зарегистрирован как бин\n    }</code></pre>\n\n<ul>\n	<li><strong>Через Java-конфигурацию:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    @Configuration\n    public class AppConfig {\n        @Bean\n        public MyBean myBean() {\n            return new MyBean();\n        }\n    }</code></pre>\n\n<p>Запуск:</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nMyClass myClass = ctx.getBean(\"myBean\", MyClass.class);</code></pre>\n\n<p>Или для Java-конфигурации:</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\nMyBean myBean = ctx.getBean(MyBean.class);</code></pre>\n\n<p>Spring контекст играет ключевую роль в разработке приложений, обеспечивая инфраструктурную поддержку и управление зависимостями, что делает разработку проще и более эффективной.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(71,'Что такое итератор и зачем он нужен',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Итератор</u> &mdash; это объект, который позволяет поочерёдно обходить элементы коллекции без раскрытия её внутреннего представления (структуры). Они используются для работы с различными структурами данных, такими как списки, множества и очереди. Основное предназначение &mdash; предоставить универсальный способ доступа к элементам коллекции, а также возможность их удаления в процессе итерации.</p>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p><strong>1. Абстракция: </strong>Скрывает детали реализации коллекции, предоставляя простой интерфейс для её перебора. Это позволяет использовать один и тот же способ обхода для коллекций с различными внутренними структурами.</p>\n\n<p><strong>2. Безопасность:</strong> Использование его для изменения коллекции во время итерации (например, удаление элементов) является безопасным. При попытке модифицировать коллекцию напрямую во время итерации может возникнуть <strong>`ConcurrentModificationException`</strong>, но многие реализации итераторов предоставляют метод <strong>`remove()`</strong>, который позволяет безопасно удалять элементы.</p>\n\n<p><strong>3. Универсальность: </strong>Итераторы предоставляют единый способ работы с различными типами коллекций, что упрощает написание гибкого и переиспользуемого кода.</p>\n\n<p><strong>Как он работает?</strong></p>\n\n<p>Предоставляет как минимум три метода:</p>\n\n<ul>\n	<li><strong>`hasNext()`: </strong>возвращает <strong>`true`</strong>, если итератор имеет ещё элементы.</li>\n	<li><strong>`next()`:</strong> возвращает следующий элемент коллекции и переводит курсор итератора на одну позицию вперёд.</li>\n	<li><strong>`remove()`:</strong> удаляет последний элемент, который был возвращён итератором с помощью метода <strong>`next()`</strong>, из коллекции.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Java\");\nlist.add(\"Python\");\nlist.add(\"C++\");\n\nIterator&lt;String&gt; iterator = list.iterator();\nwhile(iterator.hasNext()) {\n    String element = iterator.next();\n    System.out.println(element);\n    // Можно безопасно удалять элементы с помощью итератора\n    if(\"Python\".equals(element)) {\n        iterator.remove();\n    }\n}</code></pre>\n\n<p><u>Итератор</u> &mdash; это механизм для безопасного и универсального обхода элементов коллекций, позволяющий избежать проблем с изменением коллекции во время итерации и скрывающий внутреннее устройство коллекции. Он необходим для реализации стандартного способа перебора элементов без необходимости знать, как устроена коллекция, и предоставляет безопасный способ её модификации в процессе обхода.</p></p>\n                        \n                        \n                    </div>\n                </div>',7),(72,'Чем rebase отличается от merge?','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`rebase`</strong> и <strong>`merge` </strong>являются двумя различными способами интеграции изменений из одной ветки git в другую. Оба метода используются для синхронизации изменений, но они делают это по-разному и служат разным целям.</p>\n\n<p><strong>Merge (слияние)</strong></p>\n\n<p>Используется для объединения изменений из одной ветки в другую. При выполнении слияния git создает новый коммит, который является &quot;коммитом слияния&quot; и имеет двух родителей &mdash; каждый из родительских коммитов представляет собой последние изменения в каждой из сливаемых веток.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>История коммитов сохраняет время и порядок всех изменений.</li>\n	<li>Коммиты слияния явно указывают на то, что произошло слияние двух веток.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>История коммитов может стать сложной и запутанной из-за большого количества коммитов слияния, особенно в проектах с активной разработкой и многими ветками.</li>\n</ul>\n\n<p><strong>Rebase (перебазирование)</strong></p>\n\n<p>Переносит коммиты из одной ветки на вершину другой ветки, изменяя базовый коммит. Это создает линейную историю, как если бы все изменения были выполнены последовательно, даже если они разрабатывались параллельно.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Создает чистую, линейную историю коммитов, что облегчает понимание последовательности изменений.</li>\n	<li>Упрощает процесс обзора истории изменений перед вливанием в основную ветку.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Может создать проблемы с сохранностью истории, если он выполняется на коммитах, уже опубликованных в общедоступном репозитории, так как это изменяет историю коммитов.</li>\n	<li>Требует большей осторожности и понимания процесса, поскольку может привести к потере изменений при неправильном использовании.</li>\n</ul>\n\n<p><strong>В чем разница?</strong></p>\n\n<p>Основное отличие между<strong> `merge`</strong> и<strong> `rebase`</strong> заключается в том, как они интегрируют изменения. <strong>`Merge`</strong> сохраняет историю ветвления и слияния, в то время как <strong>`rebase` </strong>создает линейную историю, как если бы все изменения были сделаны последовательно в одной ветке. Выбор между<strong> `merge` </strong>и<strong> `rebase`</strong> зависит от предпочтений команды и требований к управлению историей изменений в проекте.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',2),(73,'Что делает ключевое слово transient',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевое слово<strong> `transient` </strong>используется для указания, что переменная класса не должна быть сериализована. Сериализация &mdash; это процесс преобразования состояния объекта в последовательность байтов для сохранения или передачи данных. Этот процесс используется, например, при сохранении объекта на диск или при передаче объекта по сети. Когда переменная объявлена как<strong> `transient`</strong>, она пропускается механизмом сериализации, и её значение не сохраняется вместе с объектом.</p>\n\n<p><strong>Зачем его использовать:</strong></p>\n\n<p>1. <em><strong>Конфиденциальность данных:</strong></em> Если какие-то данные в объекте являются конфиденциальными или не должны быть сохранены (например, пароли или личная информация), их можно пометить как<strong> `transient`</strong>, чтобы предотвратить их сохранение.</p>\n\n<p>2. <em><strong>Не сериализуемые объекты:</strong></em> Если объект содержит поля, которые не поддерживают сериализацию (например, потоки), эти поля могут быть объявлены как <strong>`transient`</strong>, чтобы обеспечить возможность сериализации остальной части объекта.</p>\n\n<p>3. <em><strong>Экономия места: </strong></em>Исключение ненужных данных из процесса сериализации может сократить объём занимаемого места и ускорить процесс сохранения/загрузки.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">import java.io.*;\n\npublic class User implements Serializable {\n    private String name;\n    private transient String password; // Пароль не будет сериализован\n\n    public User(String name, String password) {\n        this.name = name;\n        this.password = password;\n    }\n\n    // Геттеры и сеттеры\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"username\", \"secretPassword\");\n        \n        // Здесь может быть код для сериализации объекта user\n    }\n}</code></pre>\n\n<p>В этом примере, если объект<strong> `User` </strong>будет сериализован, значение поля <strong>`password` </strong>сохранено не будет из-за модификатора<strong> `transient`</strong>, тогда как<strong> `name`</strong> будет сохранён.</p>\n\n<p>Использование ключевого слова<strong> `transient`</strong> важно для контроля над процессом сериализации, позволяя разработчикам точно определять, какие данные объекта должны быть сериализованы, а какие должны оставаться конфиденциальными или просто не участвовать в сериализации.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(74,'Методе clone','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Метод <strong>`clone()`</strong> используется для создания копии существующего объекта. Он определён в классе<strong> `Object` </strong>и может быть переопределён в пользовательских классах для реализации более глубокого или специфического клонирования, в отличие от поверхностного копирования, предоставляемого реализацией по умолчанию.</p>\n\n<p><strong>Особенности метода:</strong></p>\n\n<ul>\n	<li><em><strong>Поверхностное копирование: </strong></em>Он выполняет поверхностное копирование объекта. Это означает, что копируются только значения примитивных полей и ссылки на объекты, но не сами объекты, на которые эти ссылки указывают. Если объект содержит ссылки на другие объекты, то в копии эти ссылки будут указывать на те же объекты, что и в оригинале.</li>\n	<li><em><strong>Класс должен реализовать интерфейс `Cloneable`: </strong></em>Чтобы объект класса мог быть клонирован с использованием метода <strong>`clone()`</strong>, этот класс должен реализовать интерфейс<strong> `Cloneable`</strong>. Интерфейс<strong> `Cloneable`</strong> не содержит методов и служит маркером, указывающим, что класс разрешает клонирование. Если объект класса, который не реализует <strong>`Cloneable`</strong>, пытается использовать метод <strong>`clone()`</strong>, будет выброшено исключение <strong>`CloneNotSupportedException`</strong>.</li>\n	<li><em><strong>Переопределение метода `clone()`:</strong></em> Для реализации глубокого клонирования или специфической логики клонирования метод <strong>`clone()` </strong>может быть переопределён. При переопределении рекомендуется вызывать <strong>`super.clone()` </strong>для получения объекта, а затем выполнять копирование внутренних объектов или выполнение дополнительных действий.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Sheep implements Cloneable {\n    private String name;\n\n    public Sheep(String name) {\n        this.name = name;\n    }\n\n    // Геттеры и сеттеры\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\npublic class CloneExample {\n    public static void main(String[] args) {\n        Sheep original = new Sheep(\"Dolly\");\n        Sheep copy = null;\n        try {\n            copy = (Sheep) original.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(original != copy); // Выведет true, так как это разные объекты\n        System.out.println(original.getClass() == copy.getClass()); // Выведет true, так как тип один и тот же\n        System.out.println(original.equals(copy)); // Результат зависит от реализации метода equals()\n    }\n}</code></pre>\n\n<p>Метод <strong>`clone()` </strong>позволяет создавать копии объектов, но его использование требует осторожности, особенно при работе с объектами, содержащими ссылки на другие объекты (глубокое и поверхностное клонирование). Необходимость реализации интерфейса<strong> `Cloneable` </strong>и обработки исключения <strong>`CloneNotSupportedException`</strong> делает использование метода <strong>`clone()` </strong>менее удобным по сравнению с другими подходами к клонированию, такими как конструкторы копирования или фабричные методы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(75,'В чём отличие Supplier\'а от Consumer\'а','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`Supplier`</strong> и<strong> `Consumer`</strong> являются функциональными интерфейсами, введёнными в Java 8 в рамках Stream API и пакета<strong> `java.util.function`</strong>. Они оба используются в лямбда-выражениях, методах ссылках и потоках данных, но служат разным целям и имеют противоположные действия.</p>\n\n<p><strong>Supplier</strong></p>\n\n<p>Представляет собой функциональный интерфейс, который поставляет результат заданного типа <strong>`T`</strong>. Интерфейс не принимает никаких аргументов, но возвращает значение типа <strong>`T`</strong>. Это может быть полезно, когда вам нужно лениво генерировать или поставлять значения, например, при создании новых объектов или выполнении операций, результат которых необходимо вернуть.</p>\n\n<p><strong>Пример использования Supplier:</strong></p>\n\n<pre>\n<code class=\"language-java\">Supplier&lt;String&gt; stringSupplier = () -&gt; \"Hello, World!\";\nSystem.out.println(stringSupplier.get()); // Выводит \"Hello, World!\"</code></pre>\n\n<p><strong>Consumer</strong></p>\n\n<p>Это функциональный интерфейс, предназначенный для выполнения операции над объектом типа <strong>`T`</strong>. Он принимает один аргумент и не возвращает результат (возвращаемый тип<strong> `void`</strong>). Это полезно, когда вам нужно выполнить какое-либо действие или операцию над объектом, например, напечатать его, изменить его состояние и т.д., без возвращения какого-либо значения.</p>\n\n<p>Пример использования Consumer:</p>\n\n<pre>\n<code class=\"language-java\">Consumer&lt;String&gt; stringConsumer = s -&gt; System.out.println(s);\nstringConsumer.accept(\"Hello, World!\"); // Выводит \"Hello, World!\"</code></pre>\n\n<p>Основное отличие между <strong>`Supplier`</strong> и<strong> `Consumer` </strong>заключается в их назначении и способе работы:</p>\n\n<ul>\n	<li><em><strong>Supplier&nbsp;</strong></em>используется для получения или генерации данных без каких-либо входных параметров. Он &laquo;поставляет&raquo; данные.</li>\n	<li><em><strong>Consumer&nbsp;</strong></em>используется для выполнения операций над данными, которые он принимает в качестве параметров, и не возвращает никакого результата. Он &laquo;потребляет&raquo; данные.</li>\n</ul>\n\n<p><strong>`Supplier`</strong> и<strong> `Consumer`</strong> представляют две разные операции: поставку данных и их потребление соответственно, что делает их важными компонентами для реализации функционального стиля программирования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',9),(76,'Что такое строка в Java',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Строка представляет собой последовательность символов и является объектом класса <strong>`String`</strong>. Они неизменяемы (immutable), что означает, что однажды созданный объект <strong>`String` </strong>не может быть изменён. Если вам нужно изменить строку, на самом деле создаётся новый объект <strong>`String` </strong>с изменённым содержимым.</p>\n\n<p><strong>Основные особенности строк:</strong></p>\n\n<ul>\n	<li><em><strong>Неизменяемость:</strong></em> Как только она создана, её содержимое не может быть изменено. Любые операции, кажущиеся изменяющими строку, на самом деле создают новый объект <strong>`String`</strong>.</li>\n	<li><em><strong>String Pool:</strong></em> Для экономии памяти использует механизм &quot;пула строк&quot; (String Pool). Это специальная область в куче (Heap), где хранятся все уникальные литералы строк, используемые в программе. Если строка уже существует в пуле, Java использует ту же ссылку, вместо создания нового объекта<strong> `String`</strong>.</li>\n	<li><em><strong>Кодировка: </strong></em>Строки в Java кодируются в UTF-16, где каждый символ (в основном) занимает 2 байта.</li>\n</ul>\n\n<p><strong>Создание строк:</strong></p>\n\n<p>Их можно создавать разными способами, например:</p>\n\n<pre>\n<code class=\"language-java\">String s1 = \"Hello\"; // Создание строки через литерал - строка помещается в пул строк\nString s2 = new String(\"Hello\"); // Явное создание нового объекта строки - не использует пул строк</code></pre>\n\n<p><strong>Работа со строками:</strong></p>\n\n<p>Класс <strong>`String`</strong> предоставляет множество методов для работы со строками, включая поиск подстроки, сравнение строк, преобразование регистра, конкатенацию (слияние строк) и многое другое.</p>\n\n<p>Примеры некоторых операций со строками:</p>\n\n<pre>\n<code class=\"language-java\">String str = \"Java\";\nString upperStr = str.toUpperCase(); // Преобразует все символы в верхний регистр\nboolean startsWithJ = str.startsWith(\"J\"); // Проверяет, начинается ли строка с символа \"J\"\nString combined = str + \" Programming\"; // Конкатенация строк</code></pre>\n\n<p><strong>Важно помнить:</strong></p>\n\n<ul>\n	<li>Использование оператора<strong> `+` </strong>для многократной конкатенации строк в цикле может быть неэффективным по производительности из-за создания множества временных объектов <strong>`String`</strong>. В таких случаях рекомендуется использовать <strong>`StringBuilder` </strong>или<strong> `StringBuffer`</strong>.</li>\n	<li>Для сравнения строк по содержимому следует использовать метод <strong>`equals()`</strong>, а не оператор <strong>`==`</strong>, который сравнивает ссылки на объекты.</li>\n</ul>\n\n<p>Строки &mdash; мощный инструмент для работы с текстовыми данными, поддерживающий широкий спектр операций и обеспечивающий удобство и безопасность использования благодаря своей неизменяемости.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(77,'С чем работает Garbage Collector','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Garbage Collector (GC) работает с управлением памятью в куче (Heap), автоматически освобождая память, занятую объектами, которые больше не используются программой. Он является частью среды выполнения Java (JRE) и играет критическую роль в управлении памятью, делая разработку менее подверженной ошибкам, связанным с утечками памяти и неправильным управлением памятью, типичными для языков программирования, где требуется ручное управление памятью (например, C или C++).</p>\n\n<p><strong>Принцип работы</strong></p>\n\n<p>Осуществляет поиск объектов в куче, на которые нет активных ссылок из доступного программе контекста. Объект считается &quot;доступным для сбора мусора&quot; (eligible for garbage collection), если на него не существует ни одной ссылки из активных частей программы. После определения таких объектов GC автоматически освобождает память, занятую ими, делая её доступной для новых объектов.</p>\n\n<p><strong>Как он работает:</strong></p>\n\n<p>1. <em><strong>Маркировка (Marking): </strong></em>Идентифицирует все объекты, доступные для приложения, начиная с &quot;корней&quot; (root objects), таких как локальные переменные и активные потоки, и отмечает все объекты, до которых можно дойти по ссылкам.</p>\n\n<p>2. <em><strong>Удаление (Sweeping):</strong></em> После маркировки всех достижимых объектов, GC удаляет все недостижимые объекты, тем самым освобождая память.</p>\n\n<p><strong>Стратегии сборки мусора</strong></p>\n\n<p>Существует несколько алгоритмов сборки мусора, каждый из которых имеет свои особенности и оптимизирован под разные типы приложений:</p>\n\n<ul>\n	<li><em><strong>Serial Garbage Collector: </strong></em>Простейший, используется в приложениях с ограниченными ресурсами.</li>\n	<li><em><strong>Parallel Garbage Collector&nbsp;</strong></em>(также известный как Throughput Collector): Использует несколько потоков для ускорения сборки мусора, подходит для многопроцессорных систем.</li>\n	<li><em><strong>Concurrent Mark Sweep (CMS) Garbage Collector: </strong></em>Минимизирует паузы, вызванные сборкой мусора, за счет выполнения большей части работы параллельно с выполнением программы.</li>\n	<li><em><strong>G1 Garbage Collector: </strong></em>Предназначен для систем с большим объемом памяти, позволяет более точно управлять временем пауз, вызванных сборкой мусора.</li>\n</ul>\n\n<p>Garbage Collector обеспечивает автоматическое управление памятью, освобождая от необходимости явно освобождать память от неиспользуемых объектов. Это повышает надежность программ и уменьшает риск ошибок, связанных с управлением памятью. Однако наличие его не исключает необходимости внимательного управления ресурсами, особенно в приложениях с высокими требованиями к производительности и времени отклика.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(78,'В чем идея Stream API',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Идея Stream API заключается в предоставлении мощного и гибкого инструмента для обработки последовательностей данных (коллекций, массивов или любых других источников данных) в декларативном стиле. Он был введен и стал ключевым элементом в поддержке функционального программирования.</p>\n\n<p><strong>Основные концепции:</strong></p>\n\n<p>1. <em><strong>Обработка данных в стиле функционального программирования: </strong></em>Позволяет применять функции к последовательностям данных без изменения исходных данных, что делает код более читабельным, кратким и легко поддерживаемым.</p>\n\n<p>2. <em><strong>Ленивость выполнения:</strong></em> Операции с потоками данных выполняются лениво, то есть вычисления начинаются только тогда, когда это необходимо для получения конечного результата, например, при вызове терминальных операций.</p>\n\n<p>3. <em><strong>Параллелизм: </strong></em>Упрощает параллельную обработку данных, позволяя легко распараллелить выполнение операций над данными для повышения производительности, используя многопоточность.</p>\n\n<p><strong>Ключевые возможности и операции:</strong></p>\n\n<ul>\n	<li><em><strong>Промежуточные операции&nbsp;(Intermediate operations):</strong></em> такие как <strong>`filter()`</strong>,<strong> `map()`</strong>,<strong> `sorted()`</strong>, которые преобразуют поток и возвращают новый поток с результатами для дальнейшей обработки. Эти операции не выполняются немедленно и ожидают вызова терминальной операции.</li>\n	<li><em><strong>Терминальные операции&nbsp;(Terminal operations): </strong></em>такие как <strong>`forEach()`</strong>, <strong>`collect()`</strong>, <strong>`reduce()`</strong>, которые выполняются немедленно и завершают поток, возвращая результат или выполняя некоторое действие с элементами потока.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; strings = Arrays.asList(\"one\", \"two\", \"three\", \"four\");\nList&lt;String&gt; filtered = strings.stream() // Создание потока данных\n    .filter(s -&gt; s.startsWith(\"t\")) // Промежуточная операция: фильтрация\n    .collect(Collectors.toList()); // Терминальная операция: сборка в список\n\nSystem.out.println(filtered); // Вывод: [two, three]</code></pre>\n\n<p>Stream API представляет собой мощный инструмент для обработки коллекций и других форм последовательностей данных, позволяя писать более чистый, выразительный и эффективный код. Благодаря поддержке ленивого выполнения и возможности легкой параллелизации, она является важным инструментом для современной разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',9),(79,'Можно ли переопределить статические методы',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Статические методы не подлежат переопределению в том смысле, в каком обычно используется термин &quot;переопределение&quot; для методов экземпляра. Переопределение подразумевает, что вызов метода на объекте будет определяться типом этого объекта во время выполнения программы. Однако статические методы привязаны к классу, а не к инстанции класса, и выбор конкретного метода для вызова происходит во время компиляции, а не выполнения программы, и основывается на типе переменной, через которую производится вызов.</p>\n\n<p>Тем не менее, статические методы могут быть &quot;скрыты&quot; в подклассах. Если подкласс определяет статический метод с той же сигнатурой, что и статический метод в суперклассе, то метод подкласса &quot;скрывает&quot; метод суперкласса. Это не считается переопределением в строгом смысле, поскольку это не влияет на процесс выбора метода для вызова &mdash; он по-прежнему определяется во время компиляции исходя из типа ссылки, а не типа объекта.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">class Parent {\n    static void test() {\n        System.out.println(\"Метод из Parent\");\n    }\n}\n\nclass Child extends Parent {\n    static void test() {\n        System.out.println(\"Метод из Child\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Parent parent = new Parent();\n        Parent childAsParent = new Child();\n        Child child = new Child();\n\n        parent.test(); // Выводит: Метод из Parent\n        childAsParent.test(); // Выводит: Метод из Parent, несмотря на то, что объект типа Child\n        child.test(); // Выводит: Метод из Child\n    }\n}</code></pre>\n\n<p>В этом примере, несмотря на то что переменная <strong>`childAsParent`</strong> ссылается на объект типа <strong>`Child`</strong>, вызывается статический метод класса <strong>`Parent`</strong>, потому что тип данной переменной &mdash;<strong> `Parent`</strong>, и решение о том, какой метод вызвать, принимается во время компиляции на основе типа переменной.</p>\n\n<p>Хотя статические методы не могут быть переопределены в том же смысле, что и методы экземпляра, они могут быть скрыты в подклассах. Это поведение отличается от переопределения и важно понимать различие, чтобы избежать путаницы при работе с наследованием и статическими методами.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(80,'Какие методы располагаются в интерфейсе','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В интерфейсе могут располагаться различные типы методов, начиная с Java 8, когда в язык были добавлены новые возможности, такие как default методы и static методы. До Java 8 интерфейсы могли содержать только абстрактные методы. Ниже представлены типы методов, которые могут быть объявлены в интерфейсе:</p>\n\n<p>1. <strong>Абстрактные методы</strong></p>\n\n<p>Это методы без тела, предназначенные для переопределения в классах, которые реализуют интерфейс. Абстрактные методы представляют собой контракт, который должен быть выполнен классом-реализатором. Все методы в интерфейсе неявно являются <strong>`public abstract`</strong>, даже если явно не указаны эти модификаторы.</p>\n\n<pre>\n<code class=\"language-java\">void myMethod();</code></pre>\n\n<p>2. <strong>Default методы (начиная с Java 8)</strong></p>\n\n<p>Позволяют определять реализацию метода непосредственно в интерфейсе. Классы, реализующие интерфейс, могут переопределять эти методы, но это не обязательно. Default методы были введены для обеспечения обратной совместимости, позволяя добавлять новые методы в интерфейсы без нарушения существующих реализаций.</p>\n\n<pre>\n<code class=\"language-java\">default void defaultMethod() {\n    // Реализация\n}</code></pre>\n\n<p>3. <strong>Static методы (начиная с Java 8)</strong></p>\n\n<p>Позволяют определять методы с реализацией, которые могут быть вызваны без создания экземпляра класса, реализующего интерфейс. Эти методы нельзя переопределить в реализующем интерфейс классе.</p>\n\n<pre>\n<code class=\"language-java\">static void staticMethod() {\n    // Реализация\n}</code></pre>\n\n<p>4. <strong>Private методы (начиная с Java 9)</strong></p>\n\n<p>Позволяют определять вспомогательные методы, которые предназначены для использования в default или static методах внутри того же интерфейса. Эти методы не могут быть вызваны извне интерфейса или реализующих его классов.</p>\n\n<pre>\n<code class=\"language-java\">private void privateMethod() {\n    // Реализация\n}</code></pre>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public interface MyInterface {\n    // Абстрактный метод\n    void abstractMethod();\n    \n    // Default метод\n    default void defaultMethod() {\n        System.out.println(\"Default implementation\");\n    }\n    \n    // Static метод\n    static void staticMethod() {\n        System.out.println(\"Static implementation\");\n    }\n    \n    // Private метод (используется внутри интерфейса)\n    private void privateMethod() {\n        System.out.println(\"Private helper method\");\n    }\n}</code></pre>\n\n<p>Интерфейсы могут содержать абстрактные методы, которые обязательны для реализации, а начиная с Java 8, также могут включать default методы с реализацией, static методы, доступные для вызова на уровне интерфейса, и private методы для внутреннего использования. Эти возможности делают интерфейсы более гибкими и мощным.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(81,'try with resourses','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Оператор<strong> `try-with-resources`</strong> &mdash; это конструкция обеспечивает автоматическое управление ресурсами, в частности, автоматическое закрытие ресурсов после их использования. Ресурсом может быть любой объект, который реализует интерфейс <strong>`AutoCloseable`</strong> или <strong>`Closeable`</strong>, например, потоки ввода/вывода (<strong>`InputStream`</strong>,<strong> `OutputStream`</strong>), соединения с базой данных и т.д.</p>\n\n<p><strong>Как работает</strong></p>\n\n<p>Конструкция<strong> `try-with-resources` </strong>автоматически закрывает ресурсы, объявленные в скобках после оператора <strong>`try`</strong>, независимо от того, завершилось ли выполнение блока <strong>`try`</strong> нормально или было выброшено исключение. Это упрощает код и делает его более надежным, поскольку не требуется явно вызывать метод<strong> `close()`</strong> в блоке<strong> `finally`</strong>.</p>\n\n<p><strong>Пример без `try-with-resources`</strong></p>\n\n<p>До Java 7 для закрытия ресурсов требовалось явно использовать блок <strong>`finally`</strong>, чтобы гарантировать закрытие ресурса:</p>\n\n<pre>\n<code class=\"language-java\">InputStream input = null;\ntry {\n    input = new FileInputStream(\"file.txt\");\n    // Чтение из файла\n} catch (IOException ex) {\n    ex.printStackTrace();\n} finally {\n    if (input != null) {\n        try {\n            input.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n\n<p><strong>Пример с `try-with-resources`</strong></p>\n\n<p>С Java 7 и новее можно использовать его для упрощения кода:</p>\n\n<pre>\n<code class=\"language-java\">try (InputStream input = new FileInputStream(\"file.txt\")) {\n    // Чтение из файла\n} catch (IOException ex) {\n    ex.printStackTrace();\n}</code></pre>\n\n<p>В этом примере ресурс <strong>`InputStream`</strong> будет автоматически закрыт после выполнения блока<strong> `try`</strong>, даже если в процессе чтения файла будет выброшено исключение. Это сокращает код и делает его более читабельным и безопасным, поскольку уменьшает риск утечки ресурсов.</p>\n\n<p><strong>Преимущества `try-with-resources`</strong></p>\n\n<p>1. <em><strong>Автоматическое закрытие ресурсов:</strong></em> Гарантирует, что каждый ресурс будет закрыт после использования, что помогает предотвратить утечки ресурсов.<br />\n2. <em><strong>Упрощение кода:</strong></em> Уменьшает объем кода, необходимого для закрытия ресурсов, и повышает его читабельность.<br />\n3. <em><strong>Улучшение управления исключениями: </strong></em>Позволяет более эффективно управлять исключениями, связанными с работой ресурсов.</p>\n\n<p>Оператор <strong>`try-with-resources` </strong>упрощает работу с ресурсами, автоматизируя их закрытие и уменьшая риск возникновения ошибок, связанных с неправильным управлением ресурсами. Это делает код более надежным и читабельным.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(82,'Может ли примитивный тип данных попасть в кучу','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Примитивные типы данных обычно хранятся на стеке (Stack), когда они определены как локальные переменные внутри методов или как часть вызова метода. Однако, примитивные типы могут &quot;попасть&quot; в кучу (Heap), когда они используются как часть объекта или обёрнуты в обёрточные классы (<strong>`Integer`</strong>, <strong>`Long`</strong>, <strong>`Double` </strong>и т.д.), которые являются объектами и хранятся в куче.</p>\n\n<p><strong>Обёртки примитивных типов</strong></p>\n\n<p>Предоставляет обёрточные классы для каждого примитивного типа, позволяя использовать примитивные значения как объекты. Например,<strong> `int`</strong> можно обернуть в <strong>`Integer`</strong>,<strong> `double`</strong> в <strong>`Double`</strong> и так далее. Когда примитивный тип данных обёрнут в такой класс, он может храниться в куче как часть объекта.</p>\n\n<p><strong>Примитивные типы как часть объектов</strong></p>\n\n<p>Когда он используется как поле объекта, само значение примитива будет храниться в куче вместе с остальной частью объекта. Например, если у вас есть класс<strong> `Person`</strong> с полем<strong> `int age`</strong>, то значение <strong>`age`</strong> будет храниться в куче вместе с объектом <strong>`Person`</strong>.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Person {\n    int age; // Примитивный тип данных внутри объекта, хранящегося в куче\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Integer number = 5; // Обёрнутый примитивный тип, хранящийся в куче\n        Person person = new Person(); // Объект, хранящийся в куче, с примитивным полем\n        person.age = 25; // Примитивное значение age хранится в куче вместе с объектом person\n    }\n}</code></pre>\n\n<p>В этом примере<strong> `number`</strong> (обёрнутый<strong> `int`</strong>) и<strong> `person`</strong> (объект с примитивным полем <strong>`age`</strong>) хранятся в куче.</p>\n\n<p>Хотя примитивные типы данных обычно ассоциируются с хранением на стеке, они могут храниться в куче, если являются частью объекта или обёрнуты в соответствующие обёрточные классы. Это позволяет примитивным типам участвовать в динамическом управлении памятью и объектно-ориентированных структурах данных, сохраняя при этом эффективность работы с данными.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(83,'Что такое Parallel Stream','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Parallel Stream является частью Java Stream API, который представлен. Это мощное средство для выполнения параллельной обработки данных, позволяя разработчикам легко писать многопоточный код. Он использует ForkJoinPool, который по умолчанию создаёт столько рабочих потоков, сколько у вас ядер процессора, для разделения задачи на подзадачи и их параллельной обработки, а затем объединения результатов. Это позволяет значительно ускорить выполнение операций с большими объёмами данных за счёт распараллеливания вычислений.</p>\n\n<p><strong>Как он работает</strong></p>\n\n<p>Когда вы вызываете метод<strong> `parallelStream()`</strong> на коллекции или используете метод<strong> `parallel()` </strong>на потоке данных, Java автоматически старается распараллелить выполнение операций над этим потоком данных. Однако степень ускорения, которую можно получить, сильно зависит от количества данных, типа выполняемых операций и доступных системных ресурсов.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>```java\nList&lt;String&gt; strings = Arrays.asList(\"one\", \"two\", \"three\", \"four\");\nList&lt;String&gt; result = strings.parallelStream()\n                             .map(String::toUpperCase)\n                             .collect(Collectors.toList());\n```</code></pre>\n\n<p>В этом примере <strong>`parallelStream()`</strong> используется для создания параллельного потока из списка строк, каждая строка преобразуется в верхний регистр с помощью метода <strong>`map`</strong>, а результат собирается обратно в список.</p>\n\n<p><strong>Важные моменты:</strong></p>\n\n<ul>\n	<li><strong>Не всегда быстрее:</strong> Параллельная обработка не всегда быстрее последовательной из-за накладных расходов на разделение данных на части и их последующее слияние. Для небольших объёмов данных или операций с низкой вычислительной сложностью использование параллельных потоков может даже ухудшить производительность.</li>\n	<li><strong>Побочные эффекты: </strong>При использовании параллельных потоков следует избегать операций, имеющих побочные эффекты (например, изменение состояния внешних переменных), так как это может привести к непредсказуемому поведению.</li>\n	<li><strong>Порядок выполнения:</strong> Порядок выполнения операций в параллельных потоках не гарантируется, что может быть важно для некоторых операций, зависящих от порядка обработки элементов.</li>\n</ul>\n\n<p><u>Parallel Stream</u> &mdash; это мощный инструмент для ускорения обработки больших объёмов данных за счёт параллельного выполнения операций. Однако его эффективность зависит от множества факторов, и его использование требует понимания особенностей параллельной обработки данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(84,'JVM, JDK, JRE',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>JVM (Java Virtual Machine), JDK (Java Development Kit) и JRE (Java Runtime Environment)</u> &mdash; это три основных компонента экосистемы, каждый из которых играет свою роль в разработке, выполнении и распространении приложений.</p>\n\n<p><strong>JVM (Java Virtual Machine)</strong></p>\n\n<p>Это виртуальная машина, которая выполняет байт-код. Байт-код &mdash; это промежуточное представление кода, которое получается после компиляции исходного кода. JVM делает Java платформенно независимым языком, поскольку позволяет запускать программы на любой операционной системе, для которой существует соответствующая реализация . Главная задача &mdash; обеспечить исполнение приложений с высокой производительностью и безопасностью, предоставляя при этом управление памятью, сборку мусора и другие службы выполнения.</p>\n\n<p><strong>JRE (Java Runtime Environment)</strong></p>\n\n<p>Включает в себя JVM и библиотеки классов Java, необходимые для выполнения приложений. Он представляет собой минимально необходимый набор инструментов для запуска Java-приложений, но не содержит инструменты для разработки, такие как компилятор или отладчик. Он предназначен для конечных пользователей, которым нужно только запускать Java-приложения без разработки собственного кода.</p>\n\n<p><strong>JDK (Java Development Kit)</strong></p>\n\n<p>Является полным набором инструментов и включает в себя JRE, компилятор Java (javac), средства для упаковки и развертывания приложений (jar), документацию, примеры и другие утилиты, необходимые для разработки приложений. Он позволяет программистам компилировать и тестировать свои приложения перед их запуском на JRE.</p>\n\n<p>Взаимосвязь между ними</p>\n\n<ul>\n	<li><strong>JVM&nbsp;</strong>является сердцем Java, поскольку обеспечивает выполнение байт-кода на любой платформе.</li>\n	<li><strong>JRE&nbsp;</strong>содержит JVM и библиотеки классов, необходимые для выполнения Java-приложений.</li>\n	<li><strong>JDK&nbsp;</strong>включает в себя JRE и дополнительные инструменты, необходимые для разработки и тестирования Java-приложений.</li>\n</ul>\n\n<p>В совокупности, JVM, JRE и JDK образуют полную экосистему для разработки, тестирования и запуска приложений, обеспечивая платформенную независимость, высокую производительность и безопасность исполнения кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(85,'Преимущества и недостатки ООП',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Преимущества:</p>\n\n<ul>\n	<li>Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.</li>\n	<li>Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.</li>\n	<li>Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.</li>\n	<li>Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.</li>\n	<li>Возможность создавать расширяемые системы.</li>\n	<li>Использование полиморфизма оказывается полезным при:\n	<ul>\n		<li>Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.</li>\n		<li>Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.</li>\n		<li>Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.</li>\n		<li>Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.</li>\n	</ul>\n	</li>\n	<li>Повторное использование кода:\n	<ul>\n		<li>Сокращается время на разработку, которое может быть отдано другим задачам.</li>\n		<li>Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.</li>\n		<li>Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.</li>\n		<li>Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>Недостатки:</p>\n\n<ul>\n	<li>В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.</li>\n	<li>Код для обработки сообщения иногда &laquo;размазан&raquo; по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).</li>\n	<li>Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.</li>\n	<li>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).</li>\n	<li>Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Объектно-ориентированное программирование (ООП), процедурное и функциональное программирование &mdash; три основных парадигмы программирования, каждая из которых имеет свои преимущества и недостатки. Понимание этих различий помогает выбрать наиболее подходящий подход для конкретного проекта или задачи.</p>\n\n<p><strong>Объектно-ориентированное программирование (ООП)</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Модульность: </strong>Облегчает разбиение программы на небольшие, управляемые части (классы и объекты), что упрощает разработку и тестирование.<br />\n<strong>2. Повторное использование кода: </strong>Наследование позволяет создавать новые классы на основе существующих, что способствует повторному использованию кода.<br />\n<strong>3. Скрытие данных: </strong>Инкапсуляция позволяет скрыть детали реализации класса и предотвращает непреднамеренное изменение данных.<br />\n<strong>4. Расширяемость: </strong>Полиморфизм и наследование обеспечивают гибкость в добавлении новой функциональности и модификации существующей без изменения существующего кода.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Сложность: </strong>Может вносить дополнительную сложность в проектирование и реализацию программы.<br />\n<strong>2. Производительность: </strong>Создание объектов и выполнение методов может потреблять больше времени и памяти, чем в процедурном программировании.<br />\n<strong>3. Кривая обучения: </strong>Освоение принципов ООП и их эффективное применение может потребовать значительного времени и опыта.</p>\n\n<p><strong>Процедурное</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Простота: </strong>Легче понять и использовать для начинающих программистов, поскольку оно следует прямолинейной логике выполнения программы.<br />\n<strong>2. Производительность: </strong>Программы, написанные в процедурном стиле, могут быть более быстрыми и эффективными по памяти, так как они напрямую управляют структурами данных и операциями.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Трудности в управлении сложными программами: </strong>Может стать трудно управляемым при работе с большими и сложными программами.<br />\n<strong>2. Ограниченное повторное использование кода: </strong>Отсутствие наследования и инкапсуляции затрудняет повторное использование кода.</p>\n\n<p><strong>Функциональное</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Непеременность данных: </strong>Использует неизменяемые данные, что упрощает разработку конкурентных программ и повышает их надежность.<br />\n<strong>2. Повторное использование кода: </strong>Функции высшего порядка и функции как объекты первого класса облегчают создание выразительных и модульных программ.<br />\n<strong>3. Простота тестирования: </strong>Функции в нем легко тестировать изолированно благодаря отсутствию побочных эффектов.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Кривая обучения: </strong>Концепции, такие как чистые функции, рекурсия и монады, могут быть непривычными и сложными для понимания новичками.<br />\n<strong>2. Производительность: </strong>Интенсивное использование рекурсии и создание большого количества временных неизменяемых структур данных может привести к снижению производительности в некоторых случаях.</p>\n\n<p>Выбор между ООП, процедурным и функциональным программированием зависит от конкретных требований проекта, предпочтений и специфики задач, которые предстоит решить. Каждый из этих подходов имеет свои сильные и слабые стороны, и в некоторых проектах может быть целесообразным комбинировать их для достижения оптимальных результатов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(86,'Что такое mock в тестирование',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>&quot;mock&quot; (подделка, макет)</u> &mdash; это объект, который имитирует поведение реального компонента в контролируемом окружении. Такие объекты часто используются в модульном тестировании для имитации взаимодействия между компонентами программы, позволяя тестировать каждый компонент изолированно от остальных. Это особенно полезно в ситуациях, когда реальные объекты трудно настроить, они медленно работают или их использование в тестах может привести к нежелательным побочным эффектам (например, изменение данных в базе данных).</p>\n\n<p>Ключевые аспекты:</p>\n\n<ul>\n	<li><strong>Изоляция тестируемого компонента: </strong>Объекты позволяют изолировать тестируемый компонент от его зависимостей, что обеспечивает точность тестирования и помогает точно определить причины возникновения ошибок.</li>\n	<li><strong>Контроль взаимодействий: </strong>С помощью него объектов можно точно определить, как тестируемый компонент взаимодействует с его зависимостями, включая проверку вызовов методов, передачу аргументов и возвращаемые значения.</li>\n	<li><strong>Тестирование в различных сценариях: </strong>Объекты позволяют легко настраивать различные условия тестирования, например, имитируя различные ситуации ошибок или исключительных состояний, которые могут быть трудно воспроизвести с реальными объектами.</li>\n	<li><strong>Ускорение тестирования: </strong>Поскольку такие объекты имитируют только необходимые аспекты реальных объектов, они могут существенно ускорить выполнение тестов по сравнению с использованием реальных компонентов, особенно если последние медленно работают или требуют сложной настройки.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>```java\nimport static org.mockito.Mockito.*;\n\npublic class SomeTest {\n    @Test\n    public void testSomeMethod() {\n        // Создание mock объекта\n        MyDependency myMock = mock(MyDependency.class);\n        \n        // Настройка поведения mock объекта\n        when(myMock.someMethod()).thenReturn(\"expected value\");\n        \n        // Создание экземпляра тестируемого класса с mock зависимостью\n        MyClass myClass = new MyClass(myMock);\n        \n        // Вызов тестируемого метода\n        String result = myClass.useDependency();\n        \n        // Проверка результата\n        assertEquals(\"expected value\", result);\n        \n        // Проверка взаимодействия с mock объектом\n        verify(myMock).someMethod();\n    }\n}\n```</code></pre>\n\n<p>В этом примере используется mock объект для зависимости<strong> `MyDependency`</strong> класса <strong>`MyClass`</strong>, что позволяет тестировать поведение<strong> `MyClass` </strong>в изоляции от реализации <strong>`MyDependency`</strong>, предоставляя при этом контролируемое окружение для проверки взаимодействий и результатов выполнения.</p>\n\n<p>Mock объекты являются важным инструментом при написании модульных тестов. Они облегчают тестирование, позволяя точно и изолированно проверять поведение компонентов программы в различных сценариях.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',8),(87,'Физическая и логическая транзакция','<h1>Разница между физической и логической транзакцией</h1>\n    \n    <h2>Физическая транзакция</h2>\n    <p>\n        <strong>Физическая транзакция</strong> относится к реальному обмену данными между системой и внешним миром. Это может быть, например, запись данных на диск, чтение данных из базы данных или передача данных по сети. Физические транзакции связаны с аппаратными ресурсами и их использованием.\n    </p>\n    <ul>\n        <li>Пример: Запись данных на жесткий диск.</li>\n        <li>Характеристики: Зависит от физических ограничений оборудования (скорость диска, пропускная способность сети и т.д.).</li>\n    </ul>\n\n    <h2>Логическая транзакция</h2>\n    <p>\n        <strong>Логическая транзакция</strong> — это абстрактное понятие, которое описывает набор операций, выполняемых как единое целое. Логические транзакции обеспечивают целостность данных и их согласованность. Они не зависят от физической реализации и могут включать в себя несколько физических транзакций.\n    </p>\n    <ul>\n        <li>Пример: Перевод денег с одного счета на другой в банковской системе.</li>\n        <li>Характеристики: Обеспечивает атомарность, согласованность, изолированность и долговечность (ACID).</li>\n    </ul>\n\n    <h2>Основные отличия</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Аспект</th>\n            <th>Физическая транзакция</th>\n            <th>Логическая транзакция</th>\n        </tr>\n        <tr>\n            <td>Определение</td>\n            <td>Реальный обмен данными с физическими устройствами.</td>\n            <td>Абстрактный набор операций, выполняемых как единое целое.</td>\n        </tr>\n        <tr>\n            <td>Зависимость</td>\n            <td>Зависит от аппаратных ресурсов.</td>\n            <td>Не зависит от физической реализации.</td>\n        </tr>\n        <tr>\n            <td>Пример</td>\n            <td>Запись данных на диск.</td>\n            <td>Перевод денег между счетами.</td>\n        </tr>\n        <tr>\n            <td>Цель</td>\n            <td>Обеспечение физического взаимодействия с данными.</td>\n            <td>Обеспечение целостности и согласованности данных.</td>\n        </tr>\n    </table>',4),(88,'Query Derivation','<h2>Что такое Query Derivation?</h2>\n    <p>\n        <strong>Query Derivation</strong> (производство запросов) — это процесс автоматического создания или преобразования запросов к базе данных на основе определенных правил, условий или метаданных. Этот подход часто используется в системах, где требуется динамическое формирование запросов, например, в ORM (Object-Relational Mapping), аналитических системах или системах с гибкими фильтрами.\n    </p>\n\n    <h2>Основные цели Query Derivation</h2>\n    <ul>\n        <li><strong>Автоматизация:</strong> Упрощение процесса создания запросов, особенно в сложных системах.</li>\n        <li><strong>Гибкость:</strong> Возможность динамически формировать запросы на основе входных данных или условий.</li>\n        <li><strong>Оптимизация:</strong> Генерация эффективных запросов, учитывающих структуру базы данных и индексы.</li>\n        <li><strong>Безопасность:</strong> Минимизация риска SQL-инъекций за счет автоматического экранирования и валидации.</li>\n    </ul>\n\n    <h2>Как работает Query Derivation?</h2>\n    <p>\n        Процесс Query Derivation обычно включает следующие шаги:\n    </p>\n    <ol>\n        <li><strong>Анализ входных данных:</strong> Система анализирует входные параметры, такие как фильтры, сортировки или условия.</li>\n        <li><strong>Применение правил:</strong> На основе предопределенных правил или метаданных система формирует структуру запроса.</li>\n        <li><strong>Генерация SQL:</strong> Создается SQL-запрос, который соответствует входным данным и правилам.</li>\n        <li><strong>Оптимизация:</strong> Запрос может быть оптимизирован для повышения производительности.</li>\n        <li><strong>Выполнение:</strong> Сгенерированный запрос выполняется в базе данных.</li>\n    </ol>\n\n    <h2>Пример использования Query Derivation</h2>\n    <p>\n        Рассмотрим пример использования Query Derivation в ORM, таком как Hibernate (Java) или Entity Framework (C#):\n    </p>\n    <pre>\n        <code>\n// Пример на C# с использованием Entity Framework\nvar query = dbContext.Users\n    .Where(u => u.Age > 18)\n    .OrderBy(u => u.LastName)\n    .Select(u => new { u.FirstName, u.LastName });\n\n// Сгенерированный SQL-запрос:\n// SELECT FirstName, LastName FROM Users WHERE Age > 18 ORDER BY LastName;\n        </code>\n    </pre>\n    <p>\n        В этом примере Query Derivation автоматически преобразует LINQ-запрос в SQL-запрос, который выполняется в базе данных.\n    </p>\n\n    <h2>Преимущества Query Derivation</h2>\n    <ul>\n        <li><strong>Упрощение разработки:</strong> Разработчикам не нужно вручную писать SQL-запросы.</li>\n        <li><strong>Гибкость:</strong> Легко адаптировать запросы под изменяющиеся требования.</li>\n        <li><strong>Безопасность:</strong> Автоматическое экранирование данных снижает риск SQL-инъекций.</li>\n        <li><strong>Поддержка сложных сценариев:</strong> Возможность создания сложных запросов с несколькими условиями и соединениями.</li>\n    </ul>\n\n    <h2>Недостатки Query Derivation</h2>\n    <ul>\n        <li><strong>Производительность:</strong> Автоматически сгенерированные запросы могут быть менее эффективными, чем ручная оптимизация.</li>\n        <li><strong>Ограничения:</strong> Некоторые сложные запросы могут быть недоступны через Query Derivation.</li>\n        <li><strong>Зависимость от инструментов:</strong> Необходимость использования ORM или других инструментов, поддерживающих Query Derivation.</li>\n    </ul>\n\n    <h2>Где используется Query Derivation?</h2>\n    <ul>\n        <li><strong>ORM-системы:</strong> Hibernate, Entity Framework, Django ORM.</li>\n        <li><strong>Аналитические системы:</strong> Динамическое формирование запросов для отчетов.</li>\n        <li><strong>Системы с фильтрами:</strong> Например, интернет-магазины с фильтрами товаров.</li>\n        <li><strong>API для работы с данными:</strong> GraphQL, REST API с поддержкой фильтрации.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Query Derivation — это мощный инструмент для автоматизации и упрощения работы с базами данных. Он позволяет разработчикам сосредоточиться на бизнес-логике, не углубляясь в детали SQL-запросов. Однако важно учитывать его ограничения и при необходимости использовать ручную оптимизацию запросов.\n    </p>',4),(89,'Аннотации в спринг','<h1>Аннотации в Spring: Подробное руководство</h1>\n\n    <h2>Введение</h2>\n    <p>\n        Аннотации в Spring Framework — это мощный инструмент, который позволяет упростить конфигурацию приложения, уменьшить количество boilerplate-кода и сделать код более читаемым. Они используются для управления жизненным циклом компонентов, внедрения зависимостей, настройки транзакций, обработки HTTP-запросов и многого другого.\n    </p>\n\n    <h2>Основные категории аннотаций Spring</h2>\n    <p>\n        Аннотации в Spring можно разделить на несколько категорий:\n    </p>\n    <ul>\n        <li><strong>Аннотации для конфигурации и управления компонентами</strong></li>\n        <li><strong>Аннотации для внедрения зависимостей (DI)</strong></li>\n        <li><strong>Аннотации для работы с базами данных и транзакциями</strong></li>\n        <li><strong>Аннотации для веб-приложений (Spring MVC)</strong></li>\n        <li><strong>Аннотации для аспектно-ориентированного программирования (AOP)</strong></li>\n        <li><strong>Аннотации для тестирования</strong></li>\n    </ul>\n\n    <h2>1. Аннотации для конфигурации и управления компонентами</h2>\n    <p>\n        Эти аннотации используются для определения и настройки компонентов Spring.\n    </p>\n    <ul>\n        <li><strong>@Component</strong>: Указывает, что класс является компонентом Spring. Это общая аннотация для любых bean-компонентов.</li>\n        <li><strong>@Service</strong>: Указывает, что класс является сервисом (бизнес-логика). Это специализированная версия @Component.</li>\n        <li><strong>@Repository</strong>: Указывает, что класс является репозиторием (доступ к данным). Это специализированная версия @Component.</li>\n        <li><strong>@Controller</strong>: Указывает, что класс является контроллером (веб-слой). Это специализированная версия @Component.</li>\n        <li><strong>@Configuration</strong>: Указывает, что класс содержит конфигурацию Spring (определение bean-компонентов).</li>\n        <li><strong>@Bean</strong>: Используется в классах с аннотацией @Configuration для определения bean-компонентов.</li>\n        <li><strong>@Scope</strong>: Определяет область видимости bean-компонента (например, singleton, prototype).</li>\n        <li><strong>@Lazy</strong>: Указывает, что bean-компонент должен быть создан только при первом обращении.</li>\n        <li><strong>@Primary</strong>: Указывает, что данный bean-компонент должен быть выбран по умолчанию, если существует несколько кандидатов.</li>\n    </ul>\n\n    <h2>2. Аннотации для внедрения зависимостей (DI)</h2>\n    <p>\n        Эти аннотации используются для внедрения зависимостей в компоненты.\n    </p>\n    <ul>\n        <li><strong>@Autowired</strong>: Автоматически внедряет зависимость. Может использоваться на полях, конструкторах и методах.</li>\n        <li><strong>@Qualifier</strong>: Уточняет, какой именно bean-компонент должен быть внедрен, если существует несколько кандидатов.</li>\n        <li><strong>@Value</strong>: Внедряет значения из properties-файлов или других источников.</li>\n        <li><strong>@Required</strong>: Указывает, что зависимость обязательна (используется редко).</li>\n    </ul>\n\n    <h2>3. Аннотации для работы с базами данных и транзакциями</h2>\n    <p>\n        Эти аннотации используются для управления транзакциями и работы с базами данных.\n    </p>\n    <ul>\n        <li><strong>@Transactional</strong>: Указывает, что метод или класс должен выполняться в рамках транзакции.</li>\n        <li><strong>@Repository</strong>: Указывает, что класс является репозиторием (см. выше).</li>\n        <li><strong>@Query</strong>: Позволяет определить пользовательский запрос к базе данных (используется в Spring Data JPA).</li>\n        <li><strong>@Modifying</strong>: Указывает, что запрос изменяет данные (используется с @Query).</li>\n        <li><strong>@Entity</strong>: Указывает, что класс является сущностью JPA.</li>\n        <li><strong>@Table</strong>: Указывает таблицу, с которой связана сущность.</li>\n        <li><strong>@Id</strong>: Указывает первичный ключ сущности.</li>\n        <li><strong>@GeneratedValue</strong>: Указывает стратегию генерации первичного ключа.</li>\n    </ul>\n\n    <h2>4. Аннотации для веб-приложений (Spring MVC)</h2>\n    <p>\n        Эти аннотации используются для обработки HTTP-запросов и управления веб-слоем.\n    </p>\n    <ul>\n        <li><strong>@Controller</strong>: Указывает, что класс является контроллером (см. выше).</li>\n        <li><strong>@RestController</strong>: Указывает, что класс является REST-контроллером (сочетание @Controller и @ResponseBody).</li>\n        <li><strong>@RequestMapping</strong>: Сопоставляет HTTP-запросы с методами контроллера.</li>\n        <li><strong>@GetMapping</strong>: Сокращение для @RequestMapping(method = RequestMethod.GET).</li>\n        <li><strong>@PostMapping</strong>: Сокращение для @RequestMapping(method = RequestMethod.POST).</li>\n        <li><strong>@PutMapping</strong>: Сокращение для @RequestMapping(method = RequestMethod.PUT).</li>\n        <li><strong>@DeleteMapping</strong>: Сокращение для @RequestMapping(method = RequestMethod.DELETE).</li>\n        <li><strong>@PathVariable</strong>: Извлекает значение из URL-пути.</li>\n        <li><strong>@RequestParam</strong>: Извлекает значение из параметров запроса.</li>\n        <li><strong>@RequestBody</strong>: Связывает тело HTTP-запроса с объектом.</li>\n        <li><strong>@ResponseBody</strong>: Указывает, что возвращаемое значение метода должно быть сериализовано в тело HTTP-ответа.</li>\n        <li><strong>@ExceptionHandler</strong>: Обрабатывает исключения в контроллере.</li>\n        <li><strong>@CrossOrigin</strong>: Разрешает кросс-доменные запросы.</li>\n    </ul>\n\n    <h2>5. Аннотации для аспектно-ориентированного программирования (AOP)</h2>\n    <p>\n        Эти аннотации используются для работы с аспектами и перехватом вызовов методов.\n    </p>\n    <ul>\n        <li><strong>@Aspect</strong>: Указывает, что класс является аспектом.</li>\n        <li><strong>@Before</strong>: Выполняет код перед вызовом метода.</li>\n        <li><strong>@After</strong>: Выполняет код после вызова метода.</li>\n        <li><strong>@Around</strong>: Оборачивает вызов метода.</li>\n        <li><strong>@AfterReturning</strong>: Выполняет код после успешного завершения метода.</li>\n        <li><strong>@AfterThrowing</strong>: Выполняет код, если метод выбрасывает исключение.</li>\n        <li><strong>@Pointcut</strong>: Определяет точку среза (где применяется аспект).</li>\n    </ul>\n\n    <h2>6. Аннотации для тестирования</h2>\n    <p>\n        Эти аннотации используются для написания тестов.\n    </p>\n    <ul>\n        <li><strong>@SpringBootTest</strong>: Загружает контекст Spring для интеграционных тестов.</li>\n        <li><strong>@WebMvcTest</strong>: Тестирует только веб-слой (MVC).</li>\n        <li><strong>@DataJpaTest</strong>: Тестирует только слой доступа к данным (JPA).</li>\n        <li><strong>@MockBean</strong>: Создает mock-объект для тестирования.</li>\n        <li><strong>@Test</strong>: Указывает, что метод является тестовым.</li>\n        <li><strong>@BeforeEach</strong>: Выполняет код перед каждым тестом.</li>\n        <li><strong>@AfterEach</strong>: Выполняет код после каждого теста.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации в Spring Framework — это мощный инструмент, который значительно упрощает разработку приложений. Они позволяют минимизировать конфигурацию в XML-файлах и делают код более читаемым и поддерживаемым. В этом руководстве мы рассмотрели основные аннотации Spring, их назначение и примеры использования.\n    </p>',3),(90,'Основы Spring Framework','<ul>\n        <li><strong>Что такое Spring Framework?</strong></li>\n        <li><strong>Основные модули Spring:</strong> Core, Context, Beans, AOP, Data Access, Web, MVC, Security.</li>\n        <li><strong>IoC (Inversion of Control) и DI (Dependency Injection):</strong> Что это такое и как они работают в Spring.</li>\n        <li><strong>ApplicationContext и BeanFactory:</strong> Различия и использование.</li>\n        <li><strong>Жизненный цикл бина:</strong> Инициализация, использование, уничтожение.</li>\n        <li><strong>Аннотации Spring:</strong> @Component, @Service, @Repository, @Controller, @Autowired, @Qualifier, @Value, @Configuration, @Bean и другие.</li>\n    </ul>\n\n    <h2>2. Spring Boot</h2>\n    <ul>\n        <li><strong>Что такое Spring Boot?</strong></li>\n        <li><strong>Преимущества Spring Boot:</strong> Автоконфигурация, встроенные серверы, упрощение разработки.</li>\n        <li><strong>Основные аннотации:</strong> @SpringBootApplication, @EnableAutoConfiguration, @ComponentScan.</li>\n        <li><strong>Конфигурация приложения:</strong> application.properties и application.yml.</li>\n        <li><strong>Профили Spring Boot:</strong> Разделение конфигурации для разных сред (dev, prod, test).</li>\n        <li><strong>Встроенные серверы:</strong> Tomcat, Jetty.</li>\n        <li><strong>Spring Boot Actuator:</strong> Мониторинг и управление приложением.</li>\n    </ul>\n\n    <h2>3. Spring MVC</h2>\n    <ul>\n        <li><strong>Что такое Spring MVC?</strong></li>\n        <li><strong>Основные компоненты:</strong> DispatcherServlet, Controller, Model, View.</li>\n        <li><strong>Аннотации для контроллеров:</strong> @Controller, @RestController, @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping.</li>\n        <li><strong>Обработка запросов:</strong> @PathVariable, @RequestParam, @RequestBody, @ResponseBody.</li>\n        <li><strong>Обработка исключений:</strong> @ExceptionHandler, @ControllerAdvice.</li>\n        <li><strong>Валидация данных:</strong> @Valid, BindingResult.</li>\n        <li><strong>Межсайтовые запросы (CORS):</strong> @CrossOrigin.</li>\n    </ul>\n\n    <h2>4. Spring Data и работа с базами данных</h2>\n    <ul>\n        <li><strong>Spring Data JPA:</strong> Основные концепции и использование.</li>\n        <li><strong>Аннотации JPA:</strong> @Entity, @Table, @Id, @GeneratedValue, @Column, @OneToMany, @ManyToOne, @JoinColumn.</li>\n        <li><strong>Репозитории:</strong> CrudRepository, JpaRepository, PagingAndSortingRepository.</li>\n        <li><strong>Методы запросов:</strong> Наследование от репозиториев, @Query, @Modifying.</li>\n        <li><strong>Транзакции:</strong> @Transactional, propagation, isolation, rollbackFor.</li>\n        <li><strong>Spring JDBC:</strong> JdbcTemplate, NamedParameterJdbcTemplate.</li>\n    </ul>\n\n    <h2>5. Spring Security</h2>\n    <ul>\n        <li><strong>Что такое Spring Security?</strong></li>\n        <li><strong>Основные концепции:</strong> Аутентификация, авторизация, роли, права доступа.</li>\n        <li><strong>Конфигурация безопасности:</strong> WebSecurityConfigurerAdapter, @EnableWebSecurity.</li>\n        <li><strong>Аутентификация:</strong> In-memory, JDBC, LDAP, OAuth2, JWT.</li>\n        <li><strong>Авторизация:</strong> @PreAuthorize, @PostAuthorize, @Secured, @RolesAllowed.</li>\n        <li><strong>CSRF защита:</strong> Как она работает и как ее отключить.</li>\n        <li><strong>Spring Security и REST API:</strong> Базовая аутентификация, JWT, OAuth2.</li>\n    </ul>\n\n    <h2>6. Spring AOP (Аспектно-ориентированное программирование)</h2>\n    <ul>\n        <li><strong>Что такое AOP?</strong></li>\n        <li><strong>Основные концепции:</strong> Аспект, совет, точка среза, соединение.</li>\n        <li><strong>Аннотации AOP:</strong> @Aspect, @Before, @After, @Around, @AfterReturning, @AfterThrowing, @Pointcut.</li>\n        <li><strong>Использование AOP в Spring:</strong> Логирование, транзакции, безопасность.</li>\n    </ul>\n\n    <h2>7. Тестирование в Spring</h2>\n    <ul>\n        <li><strong>Spring TestContext Framework:</strong> @ContextConfiguration, @SpringBootTest.</li>\n        <li><strong>Тестирование контроллеров:</strong> @WebMvcTest, MockMvc.</li>\n        <li><strong>Тестирование репозиториев:</strong> @DataJpaTest.</li>\n        <li><strong>Моки и стабы:</strong> @MockBean, @SpyBean.</li>\n        <li><strong>Интеграционные тесты:</strong> @SpringBootTest, TestRestTemplate.</li>\n    </ul>\n\n    <h2>8. Spring Cloud и микросервисы</h2>\n    <ul>\n        <li><strong>Основные компоненты Spring Cloud:</strong> Eureka, Ribbon, Feign, Hystrix, Zuul, Config Server.</li>\n        <li><strong>Обнаружение сервисов:</strong> Eureka.</li>\n        <li><strong>Балансировка нагрузки:</strong> Ribbon.</li>\n        <li><strong>REST клиенты:</strong> Feign.</li>\n        <li><strong>Circuit Breaker:</strong> Hystrix.</li>\n        <li><strong>API Gateway:</strong> Zuul.</li>\n        <li><strong>Централизованная конфигурация:</strong> Config Server.</li>\n    </ul>\n\n    <h2>9. Работа с сообщениями и событиями</h2>\n    <ul>\n        <li><strong>Spring Events:</strong> Создание и обработка событий.</li>\n        <li><strong>Spring Integration:</strong> Интеграция с внешними системами.</li>\n        <li><strong>Spring AMQP:</strong> Работа с RabbitMQ.</li>\n        <li><strong>Spring Kafka:</strong> Работа с Apache Kafka.</li>\n    </ul>\n\n    <h2>10. Производительность и оптимизация</h2>\n    <ul>\n        <li><strong>Кэширование:</strong> @Cacheable, @CacheEvict, @CachePut.</li>\n        <li><strong>Профилирование:</strong> Использование Spring Boot Actuator для мониторинга производительности.</li>\n        <li><strong>Оптимизация запросов к базе данных:</strong> Использование индексов, ленивая загрузка, пакетная обработка.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Spring Framework — это мощный и гибкий инструмент для разработки Java-приложений.\n    </p>',3),(91,'Команды git',' <title>Популярные команды Git</title>\n    <style>\n        body {\n            font-family: \'Roboto\', sans-serif; /* Используем шрифт Roboto */\n            line-height: 1.6;\n            margin: 20px;\n        }\n        h1 {\n            color: #333;\n            font-weight: 700; /* Полужирный текст для заголовка */\n        }\n        h2 {\n            color: #555;\n            font-weight: 700; /* Полужирный текст для подзаголовка */\n        }\n        pre {\n            background-color: #f4f4f4;\n            padding: 10px;\n            border-left: 3px solid #ccc;\n            font-family: \'Courier New\', monospace; /* Шрифт для кода */\n        }\n    </style>\n<body>\n\n    <h1>Популярные команды Git</h1>\n\n    <h2>Основные команды Git</h2>\n    <ol>\n        <li>\n            <strong>git init</strong>\n            <p>Инициализирует новый репозиторий Git. Создает скрытую папку <code>.git</code>, где будут храниться все метаданные репозитория.</p>\n        </li>\n        <li>\n            <strong>git clone &lt;url&gt;</strong>\n            <p>Клонирует репозиторий из указанного URL в новую папку на вашем компьютере. Например: <code>git clone https://github.com/user/repo.git</code>.</p>\n        </li>\n        <li>\n            <strong>git add &lt;file&gt;</strong>\n            <p>Добавляет указанный файл (или файлы) в индекс (staging area), подготавливая их для коммита. Можно использовать <code>git add .</code> для добавления всех измененных файлов.</p>\n        </li>\n        <li>\n            <strong>git commit -m \"message\"</strong>\n            <p>Фиксирует изменения в репозитории с заданным сообщением.</p>\n        </li>\n        <li>\n            <strong>git status</strong>\n            <p>Показывает текущее состояние рабочего каталога и индекс.</p>\n        </li>\n        <li>\n            <strong>git log</strong>\n            <p>Выводит историю коммитов в текущем репозитории, включая идентификатор коммита, автора, дату и сообщение.</p>\n        </li>\n        <li>\n            <strong>git diff</strong>\n            <p>Показывает различия между изменениями в рабочем каталоге и индексом, а также между коммитами.</p>\n        </li>\n        <li>\n            <strong>git branch</strong>\n            <p>Показывает список всех локальных веток.</p>\n        </li>\n        <li>\n            <strong>git checkout &lt;branch&gt;</strong>\n            <p>Переключает на указанную ветку.</p>\n        </li>\n        <li>\n            <strong>git merge &lt;branch&gt;</strong>\n            <p>Сливает указанную ветку с текущей веткой.</p>\n        </li>\n        <li>\n            <strong>git pull</strong>\n            <p>Загружает изменения из удаленного репозитория и сливает их с текущей веткой.</p>\n        </li>\n        <li>\n            <strong>git push</strong>\n            <p>Загружает ваши коммиты в удаленный репозиторий.</p>\n        </li>\n        <li>\n            <strong>git remote -v</strong>\n            <p>Показывает список удаленных репозиториев и их URL.</p>\n        </li>\n        <li>\n            <strong>git fetch</strong>\n            <p>Загружает изменения из удаленного репозитория, но не сливает их с текущей веткой.</p>\n        </li>\n        <li>\n           <strong>git stash</strong>\n                       <p>Сохраняет текущие изменения и очищает рабочий каталог.</p>\n                   </li>\n                   <li>\n                       <strong>git revert &lt;commit&gt;</strong>\n                       <p>Создает новый коммит, который отменяет изменения, внесенные в указанный коммит.</p>\n                   </li>\n                   <li>\n                       <strong>git reset &lt;commit&gt;</strong>\n                       <p>Сбрасывает текущую ветку к указанному коммиту.</p>\n                   </li>\n                   <li>\n                       <strong>git config</strong>\n                       <p>Настраивает параметры Git, такие как имя пользователя и адрес электронной почты.</p>\n                   </li>\n               </ol>\n           \n               <h2>Примеры использования</h2>\n               <pre><code>Создание нового репозитория:\n           git init my_project\n           cd my_project\n               </code></pre>\n               <pre><code>Клонирование репозитория:\n           git clone https://github.com/user/repo.git\n               </code></pre>',2),(92,'Java Server Pages','<h2>Общее описание</h2>\n    <p>Java Server Pages (JSP) — это технология, позволяющая разработчикам создавать динамические веб-страницы, использующие язык программирования Java. JSP позволяет включать Java-код в HTML-код, что делает разработку более интуитивной.</p>\n\n    <h2>Основные характеристики</h2>\n    <ul>\n        <li><strong>Простота использования:</strong> JSP позволяет разработчикам комбинировать HTML и Java, что облегчает создание динамического контента.</li>\n        <li><strong>Автоматическая компиляция:</strong> JSP-файлы автоматически компилируются в сервлеты, что упрощает процесс развертывания веб-приложений.</li>\n        <li><strong>Разделение логики и представления:</strong> JSP поддерживает использование JavaBeans и других Java-компонентов для управления бизнес-логикой, что способствует организации кода.</li>\n        <li><strong>Интеграция с Java EE:</strong> JSP хорошо интегрируется с другими компонентами Java EE, такими как сервлеты, EJB и JDBC.</li>\n    </ul>\n\n    <h2>Пример простого JSP</h2>\n    <pre><code>\n&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Пример JSP&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Добро пожаловать на страницу JSP&lt;/h1&gt;\n    &lt;% \n        String greeting = \"Привет, мир!\";\n        out.println(greeting);\n    %&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n    </code></pre>\n\n    <h2>Заключение</h2>\n    <p>Java Server Pages (JSP) — мощный инструмент для разработки динамических веб-приложений на языке Java. Используя JSP, разработчики могут легко создавать интерактивные веб-страницы, сочетая преимущества Java и HTML.</p>',6),(93,'Интерфейс Runnable','<p>\n        Интерфейс <code>Runnable</code> в Java является одним из ключевых элементов для работы с многопоточностью. Он используется для создания задач, которые могут выполняться в отдельном потоке. Этот интерфейс является частью пакета <code>java.lang</code> и имеет всего один метод — <code>run()</code>.\n    </p>\n\n    <h2>Описание интерфейса</h2>\n    <p>\n        Интерфейс <code>Runnable</code> выглядит следующим образом:\n    </p>\n    <pre><code>\n@FunctionalInterface\npublic interface Runnable {\n    void run();\n}\n    </code></pre>\n    <p>\n        Как видно, интерфейс содержит только один метод <code>run()</code>, который не принимает аргументов и не возвращает значений. Этот метод определяет код, который будет выполняться в потоке.\n    </p>\n\n    <h2>Зачем нужен <code>Runnable</code>?</h2>\n    <p>\n        Интерфейс <code>Runnable</code> используется для создания задач, которые могут быть переданы в поток (<code>Thread</code>) для выполнения. Это позволяет разделить логику задачи от механизма запуска потока, что делает код более гибким и удобным для повторного использования.\n    </p>\n\n    <h2>Пример использования</h2>\n    <p>\n        Рассмотрим пример создания и запуска задачи с использованием <code>Runnable</code>:\n    </p>\n    <pre><code>\npublic class Main {\n    public static void main(String[] args) {\n        // Создаем задачу\n        Runnable task = () -> {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(\"Поток: \" + Thread.currentThread().getName() + \", счетчик: \" + i);\n            }\n        };\n\n        // Создаем поток и передаем ему задачу\n        Thread thread = new Thread(task);\n        thread.start(); // Запускаем поток\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Создается задача <code>task</code>, которая выводит в консоль значения счетчика.</li>\n        <li>Задача передается в объект <code>Thread</code>.</li>\n        <li>Поток запускается с помощью метода <code>start()</code>.</li>\n    </ul>\n\n    <h2>Преимущества использования <code>Runnable</code></h2>\n    <ul>\n        <li><strong>Разделение логики:</strong> Код задачи отделен от механизма запуска потока.</li>\n        <li><strong>Гибкость:</strong> Задачи, реализующие <code>Runnable</code>, могут быть переданы в различные механизмы выполнения, такие как <code>ExecutorService</code>.</li>\n        <li><strong>Совместимость с лямбда-выражениями:</strong> Начиная с Java 8, <code>Runnable</code> является функциональным интерфейсом, что позволяет использовать лямбда-выражения для его реализации.</li>\n    </ul>\n\n    <h2>Использование с <code>ExecutorService</code></h2>\n    <p>\n        <code>Runnable</code> часто используется вместе с <code>ExecutorService</code>, который предоставляет более удобный способ управления потоками. Пример:\n    </p>\n    <pre><code>\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Создаем пул потоков\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        // Создаем задачу\n        Runnable task = () -> {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(\"Поток: \" + Thread.currentThread().getName() + \", счетчик: \" + i);\n            }\n        };\n\n        // Передаем задачу в пул потоков\n        executor.submit(task);\n        executor.submit(task);\n\n        // Завершаем работу пула\n        executor.shutdown();\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере задачи выполняются в пуле потоков, что позволяет эффективно управлять ресурсами.\n    </p>\n\n    <h2>Отличие от <code>Thread</code></h2>\n    <p>\n        Интерфейс <code>Runnable</code> предпочтительнее, чем прямое наследование от класса <code>Thread</code>, по следующим причинам:\n    </p>\n    <ul>\n        <li><strong>Отделение задачи от потока:</strong> <code>Runnable</code> позволяет отделить логику задачи от механизма выполнения.</li>\n        <li><strong>Многократное использование:</strong> Задачи, реализующие <code>Runnable</code>, могут быть переданы в разные потоки или пулы потоков.</li>\n        <li><strong>Отсутствие ограничений наследования:</strong> В Java нет множественного наследования, поэтому использование <code>Runnable</code> позволяет классу наследовать другие классы.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Интерфейс <code>Runnable</code> является важным инструментом для работы с многопоточностью в Java. Он позволяет создавать задачи, которые могут выполняться в отдельных потоках, и обеспечивает гибкость и удобство в управлении многопоточными приложениями. Использование <code>Runnable</code> вместе с <code>ExecutorService</code> делает код более эффективным и легко поддерживаемым.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> Начиная с Java 8, <code>Runnable</code> является функциональным интерфейсом, что позволяет использовать его с лямбда-выражениями для более компактного и читаемого кода.\n    </div>',5),(94,'Что такое контекст переключения? Как он влияет на производительность?',' <p>\n        Контекст переключения (англ. <strong>Context Switching</strong>) — это процесс сохранения и восстановления состояния потока (или процесса) операционной системой, чтобы поток мог быть приостановлен и позже возобновлен с того же места. Это важный механизм многозадачных операционных систем, который позволяет эффективно распределять ресурсы процессора между множеством задач.\n    </p>\n\n    <h2>Что такое контекст переключения?</h2>\n    <p>\n        Контекст переключения происходит, когда операционная система переключает выполнение с одного потока (или процесса) на другой. Для этого система должна:\n    </p>\n    <ul>\n        <li><strong>Сохранить состояние текущего потока:</strong> Это включает регистры процессора, указатель на текущую инструкцию, состояние стека и другие данные, необходимые для возобновления работы потока.</li>\n        <li><strong>Загрузить состояние следующего потока:</strong> Операционная система загружает сохраненное состояние другого потока, чтобы он мог продолжить выполнение.</li>\n    </ul>\n    <p>\n        Этот процесс требует времени и ресурсов процессора, что может повлиять на общую производительность системы.\n    </p>\n\n    <h2>Типы контекста переключения</h2>\n    <p>\n        Контекст переключения может происходить на двух уровнях:\n    </p>\n    <ul>\n        <li><strong>Переключение между процессами:</strong> Когда операционная система переключается между разными процессами. Это требует больше ресурсов, так как процессы изолированы друг от друга и имеют собственные адресные пространства.</li>\n        <li><strong>Переключение между потоками:</strong> Когда операционная система переключается между потоками в рамках одного процесса. Это менее затратно, так как потоки разделяют общее адресное пространство.</li>\n    </ul>\n\n    <h2>Как контекст переключения влияет на производительность?</h2>\n    <p>\n        Контекст переключения может негативно влиять на производительность системы по следующим причинам:\n    </p>\n    <ul>\n        <li><strong>Затраты времени:</strong> Каждое переключение требует времени на сохранение и восстановление состояния. Если переключения происходят слишком часто, это может привести к значительным накладным расходам.</li>\n        <li><strong>Потеря кэша процессора:</strong> При переключении контекста данные, которые были в кэше процессора, могут стать неактуальными. Это приводит к промахам кэша (cache misses), что замедляет выполнение задач.</li>\n        <li><strong>Увеличение нагрузки на систему:</strong> Частые переключения контекста могут увеличить нагрузку на операционную систему и процессор, что снижает общую производительность.</li>\n    </ul>\n\n    <h2>Пример влияния на производительность</h2>\n    <p>\n        Предположим, у нас есть система с большим количеством потоков, выполняющих короткие задачи. Если переключение контекста происходит слишком часто, большая часть времени процессора будет тратиться на сохранение и восстановление состояний, а не на выполнение полезной работы. Это может привести к снижению производительности и увеличению времени выполнения задач.\n    </p>\n\n    <h2>Как минимизировать влияние контекста переключения?</h2>\n    <p>\n        Для уменьшения негативного влияния контекста переключения можно использовать следующие подходы:\n    </p>\n    <ul>\n        <li><strong>Оптимизация количества потоков:</strong> Создавайте только необходимое количество потоков. Избыточное количество потоков увеличивает частоту переключений контекста.</li>\n        <li><strong>Использование пулов потоков:</strong> Пул потоков (например, <code>ExecutorService</code> в Java) позволяет эффективно управлять потоками и минимизировать переключения.</li>\n        <li><strong>Увеличение кванта времени:</strong> Увеличение времени, выделяемого каждому потоку перед переключением, может снизить частоту переключений.</li>\n        <li><strong>Использование асинхронного программирования:</strong> Асинхронные модели (например, <code>async/await</code> в C# или JavaScript) позволяют избежать блокировок и уменьшить необходимость в переключениях контекста.</li>\n    </ul>\n\n    <h2>Пример на Java</h2>\n    <p>\n        Рассмотрим пример, где частое переключение контекста может негативно сказаться на производительности:\n    </p>\n    <pre><code>\npublic class ContextSwitchExample {\n    public static void main(String[] args) {\n        Runnable task = () -> {\n            for (int i = 0; i < 1000; i++) {\n                System.out.println(Thread.currentThread().getName() + \": \" + i);\n            }\n        };\n\n        // Создаем большое количество потоков\n        for (int i = 0; i < 1000; i++) {\n            new Thread(task).start();\n        }\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере создается 1000 потоков, каждый из которых выполняет короткую задачу. Это приводит к частым переключениям контекста, что может значительно снизить производительность.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Контекст переключения — это важный механизм многозадачных операционных систем, но его частое использование может негативно сказаться на производительности. Для минимизации влияния контекста переключения важно оптимизировать количество потоков, использовать пулы потоков и асинхронные модели программирования. Понимание этого механизма помогает создавать более эффективные и производительные приложения.\n    </p>\n\n    <div class=\"important\">\n        <strong>Важно:</strong> Частые переключения контекста могут стать узким местом в высоконагруженных системах. Поэтому важно проектировать приложения с учетом минимизации переключений.\n    </div>',5),(95,'Объясните разные состояния потока в Java.',' <p>\n        В Java поток (thread) может находиться в одном из нескольких состояний, которые определяют его текущую активность и доступность для выполнения. Эти состояния важны для понимания работы многопоточных приложений и управления потоками. Состояния потока в Java описываются перечислением <code>Thread.State</code>.\n    </p>\n\n    <h2>Основные состояния потока</h2>\n    <p>\n        В Java поток может находиться в одном из следующих состояний:\n    </p>\n    <ul>\n        <li><strong>NEW</strong></li>\n        <li><strong>RUNNABLE</strong></li>\n        <li><strong>BLOCKED</strong></li>\n        <li><strong>WAITING</strong></li>\n        <li><strong>TIMED_WAITING</strong></li>\n        <li><strong>TERMINATED</strong></li>\n    </ul>\n\n    <h3>1. NEW (Новый)</h3>\n    <p>\n        Поток находится в состоянии <code>NEW</code>, когда он создан, но еще не запущен. В этом состоянии поток существует как объект, но еще не начал выполнение.\n    </p>\n    <pre><code>\nThread thread = new Thread(() -> {\n    // Код потока\n});\nSystem.out.println(thread.getState()); // NEW\n    </code></pre>\n\n    <h3>2. RUNNABLE (Готов к выполнению)</h3>\n    <p>\n        Поток переходит в состояние <code>RUNNABLE</code>, когда вызывается метод <code>start()</code>. В этом состоянии поток готов к выполнению, но может ожидать выделения процессорного времени. Поток может находиться в состоянии <code>RUNNABLE</code>, даже если он фактически не выполняется в данный момент (например, из-за планировщика потоков).\n    </p>\n    <pre><code>\nthread.start();\nSystem.out.println(thread.getState()); // RUNNABLE\n    </code></pre>\n\n    <h3>3. BLOCKED (Заблокирован)</h3>\n    <p>\n        Поток переходит в состояние <code>BLOCKED</code>, когда он пытается получить доступ к заблокированному ресурсу, например, при попытке захватить монитор объекта, который уже захвачен другим потоком. В этом состоянии поток ожидает освобождения ресурса.\n    </p>\n    <pre><code>\nsynchronized (lock) {\n    // Поток заблокирован, если другой поток уже владеет lock\n}\n    </code></pre>\n\n    <h3>4. WAITING (Ожидание)</h3>\n    <p>\n        Поток переходит в состояние <code>WAITING</code>, когда он ожидает уведомления от другого потока. Это происходит при вызове методов <code>wait()</code>, <code>join()</code> (без таймаута) или <code>LockSupport.park()</code>. Поток остается в этом состоянии, пока другой поток не вызовет <code>notify()</code>, <code>notifyAll()</code> или <code>LockSupport.unpark()</code>.\n    </p>\n    <pre><code>\nsynchronized (lock) {\n    lock.wait(); // Поток переходит в состояние WAITING\n}\n    </code></pre>\n\n    <h3>5. TIMED_WAITING (Ожидание с таймаутом)</h3>\n    <p>\n        Поток находится в состоянии <code>TIMED_WAITING</code>, когда он ожидает уведомления или истечения определенного времени. Это происходит при вызове методов <code>sleep()</code>, <code>wait(timeout)</code>, <code>join(timeout)</code> или <code>LockSupport.parkNanos()</code>.\n    </p>\n    <pre><code>\nThread.sleep(1000); // Поток переходит в состояние TIMED_WAITING\n    </code></pre>\n\n    <h3>6. TERMINATED (Завершен)</h3>\n    <p>\n        Поток переходит в состояние <code>TERMINATED</code>, когда он завершил выполнение своего кода. После этого поток больше не может быть запущен.\n    </p>\n    <pre><code>\nthread.join();\nSystem.out.println(thread.getState()); // TERMINATED\n    </code></pre>\n\n    <h2>Диаграмма состояний потока</h2>\n    <div class=\"state-diagram\">\n        <img src=\"https://www.baeldung.com/wp-content/uploads/2018/02/Life_cycle_of_a_Thread_in_Java.jpg\" alt=\"Диаграмма состояний потока в Java\">\n        <p><em>Диаграмма состояний потока в Java</em></p>\n    </div>\n\n    <h2>Как проверить состояние потока?</h2>\n    <p>\n        Состояние потока можно проверить с помощью метода <code>getState()</code>, который возвращает значение перечисления <code>Thread.State</code>.\n    </p>\n    <pre><code>\nThread thread = new Thread(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n});\nSystem.out.println(thread.getState()); // NEW\nthread.start();\nSystem.out.println(thread.getState()); // RUNNABLE\nThread.sleep(500);\nSystem.out.println(thread.getState()); // TIMED_WAITING\nthread.join();\nSystem.out.println(thread.getState()); // TERMINATED\n    </code></pre>\n\n    <h2>Заключение</h2>\n    <p>\n        Понимание состояний потока в Java важно для разработки многопоточных приложений. Каждое состояние отражает текущую активность потока и помогает диагностировать проблемы, такие как deadlock или избыточное потребление ресурсов. Используя методы управления потоками и мониторинга их состояний, можно создавать эффективные и стабильные приложения.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> Состояния потока в Java являются частью модели многопоточности и определяются JVM. Они помогают разработчикам управлять потоками и анализировать их поведение.\n    </div>',5),(96,' Каковы преимущества и недостатки использования synchronized в Java?',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\">\n\n    <h1>Преимущества и недостатки использования <code>synchronized</code> в Java</h1>\n\n    <p>\n        Ключевое слово <code>synchronized</code> в Java используется для управления доступом к общим ресурсам в многопоточных приложениях. Оно обеспечивает синхронизацию потоков, предотвращая состояние гонки (race condition) и обеспечивая потокобезопасность. Однако у <code>synchronized</code> есть как преимущества, так и недостатки, которые важно учитывать при разработке.\n    </p>\n\n    <h2>Преимущества использования <code>synchronized</code></h2>\n    <div class=\"advantages\">\n        <ul>\n            <li><strong>Простота использования:</strong> <code>synchronized</code> легко применять. Достаточно добавить ключевое слово к методу или блоку кода, чтобы обеспечить синхронизацию.</li>\n            <li><strong>Потокобезопасность:</strong> <code>synchronized</code> гарантирует, что только один поток может выполнять синхронизированный код в любой момент времени, что предотвращает состояние гонки.</li>\n            <li><strong>Встроенная поддержка в Java:</strong> <code>synchronized</code> является частью языка Java, поэтому не требует дополнительных библиотек или зависимостей.</li>\n            <li><strong>Автоматическое управление блокировками:</strong> Java автоматически управляет блокировками и их освобождением, что снижает вероятность ошибок, таких как deadlock (хотя deadlock всё ещё возможен при неправильном использовании).</li>\n            <li><strong>Поддержка мониторов:</strong> <code>synchronized</code> использует мониторы объектов, что позволяет синхронизировать доступ к конкретным объектам, а не ко всему коду.</li>\n        </ul>\n    </div>\n\n    <h2>Недостатки использования <code>synchronized</code></h2>\n    <div class=\"disadvantages\">\n        <ul>\n            <li><strong>Снижение производительности:</strong> Использование <code>synchronized</code> может привести к снижению производительности, так как только один поток может выполнять синхронизированный код в любой момент времени. Это может вызвать блокировки и задержки.</li>\n            <li><strong>Риск deadlock:</strong> Неправильное использование <code>synchronized</code> может привести к deadlock, когда два или более потоков блокируют друг друга, ожидая освобождения ресурсов.</li>\n            <li><strong>Отсутствие гибкости:</strong> <code>synchronized</code> не предоставляет таких возможностей, как таймауты или попытки захвата блокировки без ожидания, что может быть полезно в сложных сценариях.</li>\n            <li><strong>Проблемы с масштабируемостью:</strong> В высоконагруженных системах <code>synchronized</code> может стать узким местом, так как все потоки вынуждены ждать доступа к синхронизированному ресурсу.</li>\n            <li><strong>Неявное управление блокировками:</strong> Поскольку блокировки управляются автоматически, разработчику сложнее контролировать их поведение, что может привести к неочевидным ошибкам.</li>\n        </ul>\n    </div>\n\n    <h2>Пример использования <code>synchronized</code></h2>\n    <p>\n        Рассмотрим пример синхронизированного метода:\n    </p>\n    <pre><code>\npublic class Counter {\n    private int count = 0;\n\n    // Синхронизированный метод\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>increment()</code> синхронизирован, что гарантирует, что только один поток может увеличивать значение <code>count</code> в любой момент времени.\n    </p>\n\n    <h2>Альтернативы <code>synchronized</code></h2>\n    <p>\n        В некоторых случаях вместо <code>synchronized</code> можно использовать более гибкие механизмы синхронизации, такие как:\n    </p>\n    <ul>\n        <li><strong>ReentrantLock:</strong> Позволяет более гибко управлять блокировками, включая таймауты и попытки захвата блокировки без ожидания.</li>\n        <li><strong>Atomic-классы:</strong> Например, <code>AtomicInteger</code>, которые обеспечивают атомарные операции без необходимости явной синхронизации.</li>\n        <li><strong>ReadWriteLock:</strong> Позволяет разделять блокировки для чтения и записи, что может повысить производительность в системах с частыми операциями чтения.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Ключевое слово <code>synchronized</code> в Java является простым и эффективным способом обеспечения потокобезопасности. Однако оно имеет свои ограничения, такие как снижение производительности и риск deadlock. В сложных или высоконагруженных системах стоит рассмотреть альтернативные механизмы синхронизации, которые предоставляют больше гибкости и контроля.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> Использование <code>synchronized</code> оправдано в простых сценариях, но для сложных многопоточных приложений рекомендуется изучить более продвинутые механизмы синхронизации.\n    </div>\n\n       </div>\n                </div>\n            </div>',5),(97,'Что такое блокировки (Locks) в Java и как они отличаются от synchronized?','<p>\n        В Java для управления доступом к общим ресурсам в многопоточных приложениях используются два основных механизма: ключевое слово <code>synchronized</code> и интерфейс <code>Lock</code>. Оба подхода обеспечивают синхронизацию потоков, но имеют свои особенности, преимущества и недостатки.\n    </p>\n\n    <h2>Что такое блокировки (Locks)?</h2>\n    <p>\n        Блокировки (Locks) — это механизм синхронизации, представленный в Java в пакете <code>java.util.concurrent.locks</code>. Интерфейс <code>Lock</code> предоставляет более гибкий и мощный способ управления доступом к общим ресурсам по сравнению с <code>synchronized</code>.\n    </p>\n    <p>\n        Основные реализации интерфейса <code>Lock</code>:\n    </p>\n    <ul>\n        <li><strong>ReentrantLock:</strong> Позволяет повторно захватывать блокировку тем же потоком.</li>\n        <li><strong>ReadWriteLock:</strong> Разделяет блокировки для чтения и записи, что повышает производительность в системах с частыми операциями чтения.</li>\n    </ul>\n\n    <h2>Основные методы интерфейса <code>Lock</code></h2>\n    <ul>\n        <li><code>lock()</code>: Захватывает блокировку. Если блокировка недоступна, поток блокируется до тех пор, пока блокировка не будет получена.</li>\n        <li><code>unlock()</code>: Освобождает блокировку.</li>\n        <li><code>tryLock()</code>: Пытается захватить блокировку без блокировки потока. Возвращает <code>true</code>, если блокировка успешно захвачена.</li>\n        <li><code>tryLock(long time, TimeUnit unit)</code>: Пытается захватить блокировку в течение указанного времени.</li>\n        <li><code>lockInterruptibly()</code>: Захватывает блокировку, но позволяет прервать поток, если он заблокирован.</li>\n    </ul>\n\n    <h2>Пример использования <code>ReentrantLock</code></h2>\n    <pre><code>\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Counter {\n    private int count = 0;\n    private Lock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock(); // Захватываем блокировку\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Освобождаем блокировку\n        }\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере используется <code>ReentrantLock</code> для синхронизации доступа к переменной <code>count</code>.\n    </p>\n\n    <h2>Отличие блокировок от <code>synchronized</code></h2>\n    <p>\n        Основные различия между блокировками и <code>synchronized</code>:\n    </p>\n    <table class=\"comparison-table\">\n        <thead>\n            <tr>\n                <th>Характеристика</th>\n                <th><code>synchronized</code></th>\n                <th>Блокировки (Locks)</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>Гибкость</td>\n                <td>Ограниченная. Блокировка автоматически управляется JVM.</td>\n                <td>Высокая. Позволяет явно управлять блокировками, включая таймауты и попытки захвата без ожидания.</td>\n            </tr>\n            <tr>\n                <td>Простота использования</td>\n                <td>Простота. Достаточно добавить ключевое слово.</td>\n                <td>Требует явного захвата и освобождения блокировки.</td>\n            </tr>\n            <tr>\n                <td>Производительность</td>\n                <td>Может быть менее эффективным в высоконагруженных системах.</td>\n                <td>Более эффективен в сложных сценариях благодаря гибкости.</td>\n            </tr>\n            <tr>\n                <td>Поддержка прерываний</td>\n                <td>Не поддерживает прерывание блокировки.</td>\n                <td>Поддерживает прерывание блокировки с помощью <code>lockInterruptibly()</code>.</td>\n            </tr>\n            <tr>\n                <td>Таймауты</td>\n                <td>Не поддерживает таймауты.</td>\n                <td>Поддерживает таймауты с помощью <code>tryLock(timeout)</code>.</td>\n            </tr>\n            <tr>\n                <td>Чтение/Запись</td>\n                <td>Нет разделения на чтение и запись.</td>\n                <td>Поддерживает разделение на чтение и запись с помощью <code>ReadWriteLock</code>.</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <h2>Преимущества блокировок</h2>\n    <ul>\n        <li><strong>Гибкость:</strong> Блокировки предоставляют больше контроля над синхронизацией, включая таймауты и попытки захвата блокировки без ожидания.</li>\n        <li><strong>Поддержка прерываний:</strong> Поток может быть прерван во время ожидания блокировки.</li>\n        <li><strong>Разделение на чтение и запись:</strong> <code>ReadWriteLock</code> позволяет повысить производительность в системах с частыми операциями чтения.</li>\n    </ul>\n\n    <h2>Недостатки блокировок</h2>\n    <ul>\n        <li><strong>Сложность:</strong> Требует явного захвата и освобождения блокировки, что увеличивает вероятность ошибок, таких как забытый <code>unlock()</code>.</li>\n        <li><strong>Риск deadlock:</strong> Неправильное использование блокировок может привести к deadlock.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Блокировки (Locks) в Java предоставляют более гибкий и мощный способ управления синхронизацией по сравнению с <code>synchronized</code>. Они особенно полезны в сложных и высоконагруженных системах, где требуется точный контроль над блокировками. Однако их использование требует большего внимания и аккуратности, чтобы избежать ошибок, таких как забытый <code>unlock()</code> или deadlock.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> Выбор между <code>synchronized</code> и блокировками зависит от конкретных требований приложения. Для простых сценариев <code>synchronized</code> может быть достаточно, а для сложных — блокировки предоставляют больше возможностей.\n    </div>',5),(98,'Что такое ReadWriteLock',' <h1>ReadWriteLock в Java и его применение</h1>\n\n    <p>\n        <code>ReadWriteLock</code> — это интерфейс в Java, который предоставляет механизм для разделения блокировок на чтение и запись. Это позволяет повысить производительность в системах, где операции чтения происходят значительно чаще, чем операции записи. Основная реализация этого интерфейса — <code>ReentrantReadWriteLock</code>.\n    </p>\n\n    <h2>Что такое ReadWriteLock?</h2>\n    <p>\n        <code>ReadWriteLock</code> разделяет блокировки на две:\n    </p>\n    <ul>\n        <li><strong>Блокировка чтения (Read Lock):</strong> Может быть захвачена несколькими потоками одновременно, если нет блокировки записи. Это позволяет нескольким потокам читать данные одновременно.</li>\n        <li><strong>Блокировка записи (Write Lock):</strong> Может быть захвачена только одним потоком. При этом блокировка чтения также недоступна для других потоков. Это гарантирует, что только один поток может изменять данные.</li>\n    </ul>\n    <p>\n        Таким образом, <code>ReadWriteLock</code> позволяет повысить производительность в системах с частыми операциями чтения, так как несколько потоков могут читать данные одновременно, не блокируя друг друга.\n    </p>\n\n    <h2>Основные методы ReadWriteLock</h2>\n    <p>\n        Интерфейс <code>ReadWriteLock</code> предоставляет два метода:\n    </p>\n    <ul>\n        <li><code>readLock()</code>: Возвращает блокировку чтения.</li>\n        <li><code>writeLock()</code>: Возвращает блокировку записи.</li>\n    </ul>\n    <p>\n        Эти блокировки реализуют интерфейс <code>Lock</code>, поэтому поддерживают методы <code>lock()</code>, <code>unlock()</code>, <code>tryLock()</code> и другие.\n    </p>\n\n    <h2>Пример использования ReadWriteLock</h2>\n    <p>\n        Рассмотрим пример использования <code>ReentrantReadWriteLock</code> для управления доступом к общему ресурсу:\n    </p>\n    <pre><code>\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class SharedResource {\n    private int data = 0;\n    private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public void readData() {\n        lock.readLock().lock(); // Захватываем блокировку чтения\n        try {\n            System.out.println(\"Чтение данных: \" + data);\n        } finally {\n            lock.readLock().unlock(); // Освобождаем блокировку чтения\n        }\n    }\n\n    public void writeData(int newData) {\n        lock.writeLock().lock(); // Захватываем блокировку записи\n        try {\n            data = newData;\n            System.out.println(\"Запись данных: \" + data);\n        } finally {\n            lock.writeLock().unlock(); // Освобождаем блокировку записи\n        }\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Метод <code>readData()</code> использует блокировку чтения, чтобы несколько потоков могли одновременно читать данные.</li>\n        <li>Метод <code>writeData()</code> использует блокировку записи, чтобы только один поток мог изменять данные.</li>\n    </ul>\n\n    <h2>Где эффективно использовать ReadWriteLock?</h2>\n    <div class=\"use-cases\">\n        <p>\n            <code>ReadWriteLock</code> эффективно использовать в следующих сценариях:\n        </p>\n        <ul>\n            <li><strong>Кэширование данных:</strong> В системах, где данные часто читаются, но редко изменяются (например, кэши), <code>ReadWriteLock</code> позволяет повысить производительность за счет одновременного чтения.</li>\n            <li><strong>Реестры и конфигурации:</strong> В приложениях, где конфигурационные данные или реестры часто читаются, но редко обновляются.</li>\n            <li><strong>Базы данных в памяти:</strong> В системах, где данные хранятся в памяти и часто запрашиваются, но редко изменяются.</li>\n            <li><strong>Многопоточные коллекции:</strong> В коллекциях, где операции чтения преобладают над операциями записи.</li>\n        </ul>\n    </div>\n\n    <h2>Преимущества ReadWriteLock</h2>\n    <ul>\n        <li><strong>Повышение производительности:</strong> Позволяет нескольким потокам одновременно читать данные, что увеличивает пропускную способность.</li>\n        <li><strong>Гибкость:</strong> Разделение блокировок на чтение и запись позволяет более точно управлять доступом к ресурсам.</li>\n        <li><strong>Масштабируемость:</strong> Эффективно работает в системах с большим количеством операций чтения.</li>\n    </ul>\n\n    <h2>Недостатки ReadWriteLock</h2>\n    <ul>\n        <li><strong>Сложность:</strong> Требует аккуратного управления блокировками, чтобы избежать deadlock или starvation (голодания потоков).</li>\n        <li><strong>Низкая эффективность при частых операциях записи:</strong> Если операции записи происходят часто, преимущества <code>ReadWriteLock</code> могут быть сведены к минимуму.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        <code>ReadWriteLock</code> — это мощный инструмент для повышения производительности в многопоточных приложениях, где операции чтения преобладают над операциями записи. Он позволяет нескольким потокам одновременно читать данные, что делает его идеальным для использования в кэшах, реестрах и других системах с частыми операциями чтения. Однако его использование требует аккуратности, чтобы избежать проблем, таких как deadlock или starvation.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> <code>ReadWriteLock</code> особенно полезен в системах с высокой конкуренцией за чтение данных. Однако в системах с частыми операциями записи его преимущества могут быть менее заметны.\n    </div>',5),(99,'Что такое атомарные операции','<p>\n        Атомарные операции — это операции, которые выполняются как единое целое, без возможности прерывания другими потоками. В многопоточных приложениях атомарные операции используются для обеспечения потокобезопасности без необходимости использования блокировок, таких как <code>synchronized</code>.\n    </p>\n\n    <h2>Что такое атомарные операции?</h2>\n    <p>\n        Атомарная операция гарантирует, что никакой другой поток не сможет увидеть промежуточное состояние операции. Это означает, что операция либо полностью выполнится, либо не выполнится вовсе. Атомарные операции часто используются для работы с общими ресурсами в многопоточных приложениях.\n    </p>\n    <p>\n        Примеры атомарных операций:\n    </p>\n    <ul>\n        <li>Инкремент и декремент переменной.</li>\n        <li>Сравнение и замена значения (Compare-and-Swap, CAS).</li>\n        <li>Чтение и запись значений в переменные.</li>\n    </ul>\n\n    <h2>Атомарные типы в Java</h2>\n    <p>\n        В Java атомарные операции реализованы с помощью классов из пакета <code>java.util.concurrent.atomic</code>. Эти классы предоставляют атомарные методы для работы с переменными. Основные атомарные типы:\n    </p>\n    <div class=\"atomic-types\">\n        <ul>\n            <li><strong>AtomicInteger:</strong> Атомарная целочисленная переменная.</li>\n            <li><strong>AtomicLong:</strong> Атомарная переменная типа <code>long</code>.</li>\n            <li><strong>AtomicBoolean:</strong> Атомарная переменная типа <code>boolean</code>.</li>\n            <li><strong>AtomicReference:</strong> Атомарная ссылка на объект.</li>\n            <li><strong>AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray:</strong> Атомарные массивы.</li>\n        </ul>\n    </div>\n\n    <h2>Пример использования AtomicInteger</h2>\n    <p>\n        Рассмотрим пример использования <code>AtomicInteger</code> для атомарного инкремента:\n    </p>\n    <pre><code>\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet(); // Атомарный инкремент\n    }\n\n    public int getCount() {\n        return count.get(); // Атомарное чтение\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Метод <code>increment()</code> использует <code>incrementAndGet()</code> для атомарного увеличения значения переменной <code>count</code>.</li>\n        <li>Метод <code>getCount()</code> использует <code>get()</code> для атомарного чтения значения переменной.</li>\n    </ul>\n\n    <h2>Как реализованы атомарные операции в Java?</h2>\n    <p>\n        Атомарные операции в Java реализованы с использованием аппаратных инструкций процессора, таких как <strong>Compare-and-Swap (CAS)</strong>. CAS — это атомарная инструкция, которая сравнивает значение в памяти с ожидаемым значением и, если они совпадают, заменяет его на новое значение. Если значение в памяти изменилось, операция CAS завершается неудачно.\n    </p>\n    <p>\n        Пример работы CAS:\n    </p>\n    <pre><code>\nboolean compareAndSwap(int expectedValue, int newValue) {\n    if (currentValue == expectedValue) {\n        currentValue = newValue;\n        return true;\n    }\n    return false;\n}\n    </code></pre>\n    <p>\n        В Java CAS реализован с помощью методов, таких как <code>compareAndSet()</code>, которые доступны в атомарных классах.\n    </p>\n\n    <h2>Преимущества атомарных операций</h2>\n    <ul>\n        <li><strong>Потокобезопасность:</strong> Атомарные операции обеспечивают потокобезопасность без использования блокировок.</li>\n        <li><strong>Производительность:</strong> Атомарные операции обычно быстрее, чем блокировки, так как они используют аппаратные инструкции процессора.</li>\n        <li><strong>Отсутствие deadlock:</strong> Поскольку атомарные операции не используют блокировки, они исключают возможность deadlock.</li>\n    </ul>\n\n    <h2>Недостатки атомарных операций</h2>\n    <ul>\n        <li><strong>Ограниченность:</strong> Атомарные операции подходят только для простых операций, таких как инкремент или замена значения. Для сложных операций могут потребоваться блокировки.</li>\n        <li><strong>Проблема ABA:</strong> В некоторых случаях CAS может не заметить, что значение изменилось и вернулось к исходному (проблема ABA).</li>\n    </ul>\n\n    <h2>Пример использования AtomicReference</h2>\n    <p>\n        Рассмотрим пример использования <code>AtomicReference</code> для атомарного обновления объекта:\n    </p>\n    <pre><code>\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceExample {\n    private AtomicReference&lt;String&gt; message = new AtomicReference&lt;&gt;(\"Hello\");\n\n    public void updateMessage(String newMessage) {\n        message.updateAndGet(oldMessage -> oldMessage + \" \" + newMessage);\n    }\n\n    public String getMessage() {\n        return message.get();\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>updateMessage()</code> атомарно обновляет значение переменной <code>message</code>.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Атомарные операции в Java — это мощный инструмент для обеспечения потокобезопасности без использования блокировок. Они реализованы с использованием аппаратных инструкций процессора, таких как CAS, и предоставляют высокую производительность в многопоточных приложениях. Однако их использование ограничено простыми операциями, и для сложных сценариев могут потребоваться другие механизмы синхронизации.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> Атомарные операции особенно полезны в системах с высокой конкуренцией за доступ к общим ресурсам, где производительность критически важна.\n    </div>',5),(100,'Thread-safe','<p>\n        Потокобезопасность (Thread-safe) — это свойство программы или класса, которое гарантирует корректную работу в многопоточной среде. Если программа или класс являются потокобезопасными, это означает, что они могут использоваться несколькими потоками одновременно без риска возникновения состояний гонки (race conditions), повреждения данных или других ошибок, связанных с многопоточностью.\n    </p>\n\n    <h2>Что такое потокобезопасность?</h2>\n    <p>\n        Программа или класс считаются потокобезопасными, если они корректно работают в условиях, когда несколько потоков одновременно обращаются к общим ресурсам (например, переменным, объектам, файлам). Потокобезопасность достигается за счет синхронизации доступа к общим ресурсам, чтобы избежать конфликтов между потоками.\n    </p>\n\n    <h2>Проблемы при отсутствии потокобезопасности</h2>\n    <p>\n        Если программа не является потокобезопасной, это может привести к следующим проблемам:\n    </p>\n    <ul>\n        <li><strong>Состояние гонки (Race Condition):</strong> Когда несколько потоков одновременно изменяют общий ресурс, результат может зависеть от порядка выполнения операций, что приводит к непредсказуемым ошибкам.</li>\n        <li><strong>Повреждение данных:</strong> Если несколько потоков одновременно изменяют данные, они могут быть повреждены или находиться в несогласованном состоянии.</li>\n        <li><strong>Deadlock:</strong> Взаимная блокировка потоков, когда каждый поток ожидает освобождения ресурса, захваченного другим потоком.</li>\n    </ul>\n\n    <h2>Как реализовать потокобезопасность?</h2>\n    <p>\n        Для реализации потокобезопасности в Java можно использовать следующие подходы:\n    </p>\n    <div class=\"methods\">\n        <ul>\n            <li><strong>Использование синхронизированных методов и блоков:</strong> Ключевое слово <code>synchronized</code> позволяет синхронизировать доступ к методам или блокам кода, чтобы только один поток мог выполнять их в любой момент времени.</li>\n            <li><strong>Использование атомарных классов:</strong> Классы из пакета <code>java.util.concurrent.atomic</code> (например, <code>AtomicInteger</code>) обеспечивают атомарные операции, которые выполняются как единое целое.</li>\n            <li><strong>Использование потокобезопасных коллекций:</strong> Коллекции из пакета <code>java.util.concurrent</code> (например, <code>ConcurrentHashMap</code>) разработаны для работы в многопоточной среде.</li>\n            <li><strong>Использование блокировок (Locks):</strong> Интерфейс <code>Lock</code> и его реализации (например, <code>ReentrantLock</code>) предоставляют более гибкий способ управления синхронизацией.</li>\n            <li><strong>Использование неизменяемых объектов:</strong> Неизменяемые объекты (immutable objects) по своей природе потокобезопасны, так как их состояние не может быть изменено после создания.</li>\n        </ul>\n    </div>\n\n    <h2>Пример реализации потокобезопасности</h2>\n    <p>\n        Рассмотрим пример потокобезопасного класса с использованием синхронизированного метода:\n    </p>\n    <pre><code>\npublic class Counter {\n    private int count = 0;\n\n    // Синхронизированный метод\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>increment()</code> синхронизирован, что гарантирует, что только один поток может выполнять его в любой момент времени.\n    </p>\n\n    <h2>Пример использования атомарных классов</h2>\n    <p>\n        Рассмотрим пример потокобезопасного класса с использованием <code>AtomicInteger</code>:\n    </p>\n    <pre><code>\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet(); // Атомарный инкремент\n    }\n\n    public int getCount() {\n        return count.get(); // Атомарное чтение\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере используется <code>AtomicInteger</code>, который обеспечивает атомарные операции без необходимости явной синхронизации.\n    </p>\n\n    <h2>Пример использования потокобезопасных коллекций</h2>\n    <p>\n        Рассмотрим пример использования <code>ConcurrentHashMap</code>:\n    </p>\n    <pre><code>\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Cache {\n    private ConcurrentHashMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();\n\n    public void add(String key, String value) {\n        map.put(key, value);\n    }\n\n    public String get(String key) {\n        return map.get(key);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере <code>ConcurrentHashMap</code> обеспечивает потокобезопасность при работе с данными.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Потокобезопасность — это важное свойство многопоточных приложений, которое гарантирует корректную работу при одновременном доступе нескольких потоков к общим ресурсам. В Java потокобезопасность может быть достигнута с использованием синхронизированных методов, атомарных классов, потокобезопасных коллекций и других механизмов. Выбор подхода зависит от конкретных требований приложения и желаемого уровня производительности.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> При разработке многопоточных приложений важно тщательно тестировать код на предмет потокобезопасности, чтобы избежать ошибок, таких как состояние гонки или deadlock.\n    </div>',5),(101,'Что такое starvation и как его избежать?','<p>\n        <strong>Starvation</strong> (голодание) — это ситуация в многопоточных приложениях, когда один или несколько потоков не могут получить доступ к общим ресурсам или выполнить свою работу из-за того, что другие потоки постоянно монополизируют эти ресурсы. В результате \"голодающие\" потоки могут находиться в состоянии ожидания неопределенно долгое время.\n    </p>\n\n    <h2>Причины возникновения Starvation</h2>\n    <p>\n        Starvation может возникать по следующим причинам:\n    </p>\n    <ul>\n        <li><strong>Несправедливое распределение ресурсов:</strong> Если планировщик потоков или механизмы синхронизации отдают предпочтение определенным потокам, другие потоки могут \"голодать\".</li>\n        <li><strong>Высокий приоритет некоторых потоков:</strong> Потоки с высоким приоритетом могут постоянно получать доступ к ресурсам, оставляя потоки с низким приоритетом без возможности выполнения.</li>\n        <li><strong>Неправильное использование блокировок:</strong> Если потоки захватывают блокировки на длительное время, другие потоки могут не получить доступ к ресурсам.</li>\n        <li><strong>Активное ожидание:</strong> Потоки, которые активно ожидают ресурсов (например, в цикле <code>while</code>), могут мешать другим потокам получить доступ к этим ресурсам.</li>\n    </ul>\n\n    <h2>Пример Starvation</h2>\n    <p>\n        Рассмотрим пример, где поток с низким приоритетом \"голодает\" из-за потоков с высоким приоритетом:\n    </p>\n    <pre><code>\npublic class StarvationExample {\n    public static void main(String[] args) {\n        Thread highPriorityThread = new Thread(() -> {\n            while (true) {\n                synchronized (StarvationExample.class) {\n                    System.out.println(\"High priority thread is running\");\n                }\n            }\n        });\n\n        Thread lowPriorityThread = new Thread(() -> {\n            while (true) {\n                synchronized (StarvationExample.class) {\n                    System.out.println(\"Low priority thread is running\");\n                }\n            }\n        });\n\n        highPriorityThread.setPriority(Thread.MAX_PRIORITY);\n        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);\n\n        highPriorityThread.start();\n        lowPriorityThread.start();\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере поток с высоким приоритетом (<code>highPriorityThread</code>) постоянно захватывает блокировку, оставляя поток с низким приоритетом (<code>lowPriorityThread</code>) без возможности выполнения.\n    </p>\n\n    <h2>Как избежать Starvation?</h2>\n    <div class=\"prevention\">\n        <p>\n            Чтобы избежать Starvation, можно использовать следующие подходы:\n        </p>\n        <ul>\n            <li><strong>Справедливое распределение ресурсов:</strong> Используйте механизмы, которые обеспечивают справедливое распределение ресурсов между потоками. Например, в Java можно использовать <code>ReentrantLock</code> с режимом справедливости (<code>fair mode</code>).</li>\n            <li><strong>Управление приоритетами:</strong> Избегайте чрезмерного использования высоких приоритетов для потоков. Устанавливайте приоритеты только в случае крайней необходимости.</li>\n            <li><strong>Ограничение времени захвата блокировок:</strong> Старайтесь минимизировать время, в течение которого поток удерживает блокировку. Это позволяет другим потокам быстрее получить доступ к ресурсам.</li>\n            <li><strong>Использование пулов потоков:</strong> Пул потоков (<code>ExecutorService</code>) помогает управлять количеством активных потоков и распределять задачи более равномерно.</li>\n            <li><strong>Использование неблокирующих алгоритмов:</strong> Вместо блокировок можно использовать неблокирующие структуры данных, такие как атомарные классы (<code>AtomicInteger</code>, <code>AtomicReference</code>).</li>\n        </ul>\n    </div>\n\n    <h2>Пример использования справедливой блокировки</h2>\n    <p>\n        Рассмотрим пример использования <code>ReentrantLock</code> с режимом справедливости:\n    </p>\n    <pre><code>\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class FairLockExample {\n    private static Lock lock = new ReentrantLock(true); // Справедливая блокировка\n\n    public static void main(String[] args) {\n        Runnable task = () -> {\n            for (int i = 0; i < 5; i++) {\n                lock.lock();\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" is running\");\n                } finally {\n                    lock.unlock();\n                }\n            }\n        };\n\n        Thread thread1 = new Thread(task, \"Thread-1\");\n        Thread thread2 = new Thread(task, \"Thread-2\");\n        Thread thread3 = new Thread(task, \"Thread-3\");\n\n        thread1.start();\n        thread2.start();\n        thread3.start();\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере используется <code>ReentrantLock</code> с режимом справедливости, что позволяет потокам получать доступ к ресурсу в порядке очереди.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Starvation — это серьезная проблема в многопоточных приложениях, которая может привести к тому, что некоторые потоки не смогут выполнить свою работу. Чтобы избежать Starvation, важно использовать справедливые механизмы распределения ресурсов, управлять приоритетами потоков и минимизировать время захвата блокировок. Использование пулов потоков и неблокирующих алгоритмов также помогает снизить риск возникновения Starvation.\n    </p>\n\n    <div class=\"note\">\n        <strong>Примечание:</strong> При разработке многопоточных приложений важно тестировать код на предмет Starvation, чтобы убедиться, что все потоки получают возможность выполнить свою работу.\n    </div>',5),(102,'Бинарное и красно-чёрное дерево','<p>Бинарное дерево и красно-чёрное дерево являются структурами данных, но они имеют существенные различия:</p><ul> <li> <strong>Бинарное дерево:</strong> <ul> <li>Это дерево, где каждый узел имеет не более двух дочерних элементов (левый и правый).</li> <li>Не имеет строгих правил балансировки, поэтому может быть несбалансированным, что ухудшает производительность операций (например, поиска).</li> <li>Простота реализации, но в худшем случае время выполнения операций может быть O(n).</li> </ul> </li> <li> <strong>Красно-чёрное дерево:</strong> <ul> <li>Это сбалансированное бинарное дерево поиска, которое поддерживает балансировку с помощью дополнительных свойств:</li> <ul> <li>Каждый узел имеет цвет (красный или чёрный).</li> <li>Корень и листья (NIL-узлы) всегда чёрные.</li> <li>Если узел красный, то его дочерние элементы чёрные.</li> <li>Все пути от узла до листьев содержат одинаковое количество чёрных узлов.</li> </ul> <li>Гарантирует время выполнения операций (вставка, удаление, поиск) за O(log n).</li> <li>Более сложная реализация из-за необходимости поддерживать балансировку.</li> </ul> </li> </ul><p>Таким образом, основное отличие заключается в том, что красно-чёрное дерево является сбалансированным и обеспечивает более предсказуемую производительность, тогда как бинарное дерево может быть несбалансированным.</p>\n',7),(103,'Что такое Future',' <p>\n        В Java <strong>Future</strong> — это интерфейс, который представляет результат асинхронной операции. Он позволяет выполнять задачи в отдельном потоке и получать результат их выполнения в будущем, когда они будут завершены. Это особенно полезно для выполнения длительных операций, которые не должны блокировать основной поток выполнения программы.\n    </p>\n\n    <h2>Основные методы интерфейса <code>Future</code>:</h2>\n    <ul>\n        <li>\n            <strong><code>get()</code></strong> — возвращает результат выполнения задачи. Если задача ещё не завершена, метод блокирует текущий поток до тех пор, пока результат не будет доступен.\n            <ul>\n                <li>Может выбрасывать исключения <code>InterruptedException</code> и <code>ExecutionException</code>.</li>\n            </ul>\n        </li>\n        <li>\n            <strong><code>get(long timeout, TimeUnit unit)</code></strong> — аналогичен <code>get()</code>, но позволяет задать максимальное время ожидания результата. Если результат не будет получен за указанное время, выбрасывается исключение <code>TimeoutException</code>.\n        </li>\n        <li>\n            <strong><code>isDone()</code></strong> — возвращает <code>true</code>, если задача завершена (успешно, с ошибкой или отменой).\n        </li>\n        <li>\n            <strong><code>cancel(boolean mayInterruptIfRunning)</code></strong> — пытается отменить выполнение задачи. Если задача уже завершена, возвращает <code>false</code>.\n            <ul>\n                <li>Параметр <code>mayInterruptIfRunning</code> указывает, можно ли прерывать поток, выполняющий задачу.</li>\n            </ul>\n        </li>\n        <li>\n            <strong><code>isCancelled()</code></strong> — возвращает <code>true</code>, если задача была отменена до её завершения.\n        </li>\n    </ul>\n\n    <h2>Пример использования <code>Future</code>:</h2>\n    <pre>\n        <code>\nimport java.util.concurrent.*;\n\npublic class FutureExample {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n\n        // Задача, которая возвращает результат\n        Callable&lt;String&gt; task = () -> {\n            Thread.sleep(2000); // Имитация длительной операции\n            return \"Результат выполнения задачи\";\n        };\n\n        // Отправляем задачу на выполнение\n        Future&lt;String&gt; future = executor.submit(task);\n\n        System.out.println(\"Задача отправлена на выполнение...\");\n\n        // Получаем результат (блокирующий вызов)\n        String result = future.get();\n        System.out.println(\"Результат: \" + result);\n\n        executor.shutdown();\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Где используется <code>Future</code>?</h2>\n    <ul>\n        <li>Для выполнения длительных операций в фоновом режиме.</li>\n        <li>Для параллельного выполнения нескольких задач.</li>\n        <li>В сочетании с <code>ExecutorService</code> для управления потоками.</li>\n    </ul>\n\n    <h2>Ограничения <code>Future</code>:</h2>\n    <ul>\n        <li>Не поддерживает цепочки асинхронных задач (например, выполнение одной задачи после завершения другой).</li>\n        <li>Не предоставляет механизма для обработки ошибок в асинхронном режиме.</li>\n    </ul>\n\n    <p>\n        Для более гибкого управления асинхронными операциями в Java 8 был введён <code>CompletableFuture</code>, который расширяет возможности <code>Future</code> и поддерживает цепочки задач, обработку исключений и комбинирование результатов.\n    </p>',5),(104,'Что такое JDBC?','<p>\n        <strong>JDBC</strong> (Java Database Connectivity) — это стандартный Java API (интерфейс программирования приложений), который позволяет приложениям на Java взаимодействовать с реляционными базами данных. JDBC предоставляет набор классов и интерфейсов для выполнения SQL-запросов, обработки результатов и управления соединениями с базой данных.\n    </p>\n\n    <h2>Основные компоненты JDBC:</h2>\n    <ul>\n        <li>\n            <strong>JDBC API</strong> — набор интерфейсов и классов, которые позволяют выполнять SQL-запросы и обрабатывать результаты.\n            <ul>\n                <li><code>java.sql</code> и <code>javax.sql</code> — основные пакеты, содержащие классы и интерфейсы JDBC.</li>\n            </ul>\n        </li>\n        <li>\n            <strong>JDBC Driver</strong> — драйвер, который реализует интерфейсы JDBC для конкретной СУБД (например, MySQL, PostgreSQL, Oracle). Драйвер обеспечивает связь между Java-приложением и базой данных.\n        </li>\n        <li>\n            <strong>Connection</strong> — объект, представляющий соединение с базой данных.\n        </li>\n        <li>\n            <strong>Statement</strong> — объект для выполнения SQL-запросов.\n        </li>\n        <li>\n            <strong>ResultSet</strong> — объект, который содержит результаты выполнения SQL-запроса (например, данные из таблицы).\n        </li>\n    </ul>\n\n    <h2>Основные шаги для работы с JDBC:</h2>\n    <ol>\n        <li>\n            <strong>Загрузка драйвера базы данных</strong> — регистрация JDBC-драйвера в приложении.\n            <pre>\n                <code>\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Установление соединения с базой данных</strong> — создание объекта <code>Connection</code>.\n            <pre>\n                <code>\nString url = \"jdbc:mysql://localhost:3306/mydatabase\";\nString user = \"root\";\nString password = \"password\";\nConnection connection = DriverManager.getConnection(url, user, password);\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Создание и выполнение SQL-запроса</strong> — использование объекта <code>Statement</code> или <code>PreparedStatement</code>.\n            <pre>\n                <code>\nStatement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Обработка результатов</strong> — работа с объектом <code>ResultSet</code>.\n            <pre>\n                <code>\nwhile (resultSet.next()) {\n    String name = resultSet.getString(\"name\");\n    int age = resultSet.getInt(\"age\");\n    System.out.println(\"Name: \" + name + \", Age: \" + age);\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Закрытие соединения</strong> — освобождение ресурсов.\n            <pre>\n                <code>\nresultSet.close();\nstatement.close();\nconnection.close();\n                </code>\n            </pre>\n        </li>\n    </ol>\n\n    <h2>Преимущества JDBC:</h2>\n    <ul>\n        <li>Универсальность — работает с любой реляционной базой данных, для которой существует JDBC-драйвер.</li>\n        <li>Простота использования — предоставляет понятный API для работы с базами данных.</li>\n        <li>Поддержка транзакций — позволяет управлять транзакциями (например, commit и rollback).</li>\n    </ul>\n\n    <h2>Недостатки JDBC:</h2>\n    <ul>\n        <li>Необходимость написания большого количества boilerplate-кода (например, закрытие ресурсов вручную).</li>\n        <li>Отсутствие ORM (Object-Relational Mapping) — требуется вручную преобразовывать данные из <code>ResultSet</code> в объекты.</li>\n    </ul>\n\n    <h2>Пример использования JDBC:</h2>\n    <pre>\n        <code>\nimport java.sql.*;\n\npublic class JdbcExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\")) {\n\n            while (resultSet.next()) {\n                String name = resultSet.getString(\"name\");\n                int age = resultSet.getInt(\"age\");\n                System.out.println(\"Name: \" + name + \", Age: \" + age);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Альтернативы JDBC:</h2>\n    <ul>\n        <li><strong>ORM-фреймворки</strong> — например, Hibernate, JPA (Java Persistence API), которые упрощают работу с базой данных, автоматизируя преобразование объектов в таблицы и обратно.</li>\n        <li><strong>Библиотеки для работы с базами данных</strong> — например, MyBatis, jOOQ.</li>\n    </ul>\n\n    <p>\n        JDBC остаётся важным инструментом для работы с базами данных в Java, особенно в случаях, когда требуется низкоуровневый контроль над SQL-запросами и транзакциями.\n    </p>',4),(105,'Что такое junit','<p>\n        <strong>JUnit</strong> — это популярный фреймворк для модульного тестирования (unit testing) в Java. Он позволяет разработчикам писать и запускать повторяемые тесты для проверки корректности работы отдельных частей кода (например, методов или классов). JUnit является частью экосистемы тестирования в Java и широко используется в разработке программного обеспечения.\n    </p>\n\n    <h2>Основные возможности JUnit:</h2>\n    <ul>\n        <li>Создание тестовых методов с использованием аннотаций.</li>\n        <li>Проверка ожидаемых результатов с помощью утверждений (assertions).</li>\n        <li>Поддержка параметризованных тестов.</li>\n        <li>Группировка тестов в тестовые наборы (test suites).</li>\n        <li>Интеграция с инструментами сборки (например, Maven, Gradle) и CI/CD (например, Jenkins).</li>\n    </ul>\n\n    <h2>Основные аннотации JUnit:</h2>\n    <ul>\n        <li>\n            <strong><code>@Test</code></strong> — указывает, что метод является тестовым.\n            <pre>\n                <code>\n@Test\npublic void testMethod() {\n    // Тестовый код\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@Before</code></strong> — метод, помеченный этой аннотацией, выполняется перед каждым тестом. Используется для настройки тестового окружения.\n            <pre>\n                <code>\n@Before\npublic void setUp() {\n    // Инициализация ресурсов\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@After</code></strong> — метод, помеченный этой аннотацией, выполняется после каждого теста. Используется для освобождения ресурсов.\n            <pre>\n                <code>\n@After\npublic void tearDown() {\n    // Очистка ресурсов\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@BeforeClass</code></strong> — метод, помеченный этой аннотацией, выполняется один раз перед всеми тестами в классе.\n            <pre>\n                <code>\n@BeforeClass\npublic static void setUpClass() {\n    // Инициализация, выполняемая один раз\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@AfterClass</code></strong> — метод, помеченный этой аннотацией, выполняется один раз после всех тестов в классе.\n            <pre>\n                <code>\n@AfterClass\npublic static void tearDownClass() {\n    // Очистка, выполняемая один раз\n}\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@Ignore</code></strong> — игнорирует выполнение тестового метода или класса.\n            <pre>\n                <code>\n@Ignore(\"Тест временно отключён\")\n@Test\npublic void ignoredTest() {\n    // Этот тест не будет выполнен\n}\n                </code>\n            </pre>\n        </li>\n    </ul>\n\n    <h2>Пример использования JUnit:</h2>\n    <pre>\n        <code>\nimport org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class CalculatorTest {\n\n    @Before\n    public void setUp() {\n        // Инициализация перед каждым тестом\n    }\n\n    @Test\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result); // Проверка ожидаемого результата\n    }\n\n    @Test\n    public void testSubtraction() {\n        Calculator calculator = new Calculator();\n        int result = calculator.subtract(5, 3);\n        assertEquals(2, result); // Проверка ожидаемого результата\n    }\n\n    @After\n    public void tearDown() {\n        // Очистка после каждого теста\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Преимущества JUnit:</h2>\n    <ul>\n        <li>Простота использования — минимальные требования для написания тестов.</li>\n        <li>Интеграция с IDE (например, IntelliJ IDEA, Eclipse) и инструментами сборки.</li>\n        <li>Поддержка автоматизации тестирования.</li>\n        <li>Большое сообщество и множество ресурсов для обучения.</li>\n    </ul>\n\n    <h2>Недостатки JUnit:</h2>\n    <ul>\n        <li>Ограниченная поддержка тестирования сложных сценариев (например, интеграционных тестов).</li>\n        <li>Требует написания дополнительного кода для тестов.</li>\n    </ul>\n\n    <h2>Альтернативы JUnit:</h2>\n    <ul>\n        <li><strong>TestNG</strong> — более мощный фреймворк для тестирования с поддержкой параметризованных тестов, групп тестов и зависимостей.</li>\n        <li><strong>Spock</strong> — фреймворк для тестирования на Groovy, который предоставляет более выразительный синтаксис.</li>\n    </ul>\n\n    <p>\n        JUnit остаётся стандартом для модульного тестирования в Java и активно используется разработчиками для обеспечения качества кода.\n    </p>',8),(106,'Что такое mockito','<p>\n        <strong>Mockito</strong> — это популярный фреймворк для создания mock-объектов (заглушек) в Java. Он используется в unit-тестировании для изоляции тестируемого кода от зависимостей, таких как базы данных, сетевые запросы или сложные объекты. Mockito позволяет создавать mock-объекты, настраивать их поведение и проверять взаимодействие с ними.\n    </p>\n\n    <h2>Основные возможности Mockito:</h2>\n    <ul>\n        <li>Создание mock-объектов.</li>\n        <li>Настройка поведения mock-объектов (например, возвращаемые значения или выбрасываемые исключения).</li>\n        <li>Проверка взаимодействия с mock-объектами (например, сколько раз был вызван метод).</li>\n        <li>Поддержка аннотаций для упрощения создания и внедрения mock-объектов.</li>\n    </ul>\n\n    <h2>Основные методы Mockito:</h2>\n    <ul>\n        <li>\n            <strong><code>mock()</code></strong> — создаёт mock-объект для указанного класса или интерфейса.\n            <pre>\n                <code>\nList&lt;String&gt; mockedList = mock(List.class);\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>when()</code></strong> — настраивает поведение mock-объекта.\n            <pre>\n                <code>\nwhen(mockedList.get(0)).thenReturn(\"first\");\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>verify()</code></strong> — проверяет, был ли вызван метод mock-объекта с определёнными параметрами.\n            <pre>\n                <code>\nverify(mockedList).get(0);\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>any()</code></strong> — используется для указания, что метод может быть вызван с любым аргументом.\n            <pre>\n                <code>\nwhen(mockedList.get(anyInt())).thenReturn(\"element\");\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>doThrow()</code></strong> — настраивает mock-объект на выбрасывание исключения.\n            <pre>\n                <code>\ndoThrow(new RuntimeException()).when(mockedList).clear();\n                </code>\n            </pre>\n        </li>\n    </ul>\n\n    <h2>Пример использования Mockito:</h2>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MockitoExampleTest {\n\n    @Test\n    public void testMockito() {\n        // Создаём mock-объект\n        List&lt;String&gt; mockedList = mock(List.class);\n\n        // Настраиваем поведение\n        when(mockedList.get(0)).thenReturn(\"first\");\n\n        // Проверяем поведение\n        assertEquals(\"first\", mockedList.get(0));\n\n        // Проверяем, что метод был вызван\n        verify(mockedList).get(0);\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Аннотации Mockito:</h2>\n    <ul>\n        <li>\n            <strong><code>@Mock</code></strong> — создаёт mock-объект.\n            <pre>\n                <code>\n@Mock\nList&lt;String&gt; mockedList;\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@InjectMocks</code></strong> — внедряет mock-объекты в тестируемый объект.\n            <pre>\n                <code>\n@InjectMocks\nMyService myService;\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong><code>@Spy</code></strong> — создаёт spy-объект, который является частичным mock-объектом (реальные методы вызываются, если не настроено иное поведение).\n            <pre>\n                <code>\n@Spy\nList&lt;String&gt; spiedList = new ArrayList<>();\n                </code>\n            </pre>\n        </li>\n    </ul>\n\n    <h2>Преимущества Mockito:</h2>\n    <ul>\n        <li>Простота использования — интуитивно понятный API.</li>\n        <li>Гибкость — возможность настраивать поведение mock-объектов для различных сценариев.</li>\n        <li>Интеграция с JUnit и другими фреймворками для тестирования.</li>\n        <li>Поддержка аннотаций для упрощения кода.</li>\n    </ul>\n\n    <h2>Недостатки Mockito:</h2>\n    <ul>\n        <li>Не подходит для интеграционного тестирования — только для unit-тестов.</li>\n        <li>Требует осторожности при использовании, чтобы не переусложнить тесты.</li>\n    </ul>\n\n    <h2>Альтернативы Mockito:</h2>\n    <ul>\n        <li><strong>EasyMock</strong> — ещё один фреймворк для создания mock-объектов.</li>\n        <li><strong>PowerMock</strong> — расширение Mockito, которое позволяет mock-ировать статические методы и конструкторы.</li>\n    </ul>\n\n    <p>\n        Mockito является мощным инструментом для unit-тестирования в Java, который помогает изолировать тестируемый код и делает тесты более надёжными и поддерживаемыми.\n    </p>',8),(107,'Что такое Postman','<p>\n        <strong>Postman</strong> — это популярный инструмент для разработки, тестирования и документирования API (Application Programming Interface). Он предоставляет удобный графический интерфейс для отправки HTTP-запросов, анализа ответов и автоматизации тестирования API. Postman широко используется разработчиками, тестировщиками и инженерами по обеспечению качества.\n    </p>\n\n    <h2>Основные возможности Postman:</h2>\n    <ul>\n        <li>Отправка HTTP-запросов (GET, POST, PUT, DELETE и другие).</li>\n        <li>Создание и управление коллекциями запросов.</li>\n        <li>Автоматизация тестирования API с помощью скриптов.</li>\n        <li>Генерация документации API.</li>\n        <li>Поддержка переменных и окружений для гибкой настройки запросов.</li>\n        <li>Интеграция с CI/CD (Continuous Integration/Continuous Deployment).</li>\n        <li>Совместная работа через Postman Workspaces.</li>\n    </ul>\n\n    <h2>Основные компоненты Postman:</h2>\n    <ul>\n        <li>\n            <strong>Коллекции (Collections)</strong> — группы запросов, которые можно организовать для удобства работы с API.\n        </li>\n        <li>\n            <strong>Окружения (Environments)</strong> — наборы переменных, которые можно использовать в запросах для разных сред (например, разработка, тестирование, production).\n        </li>\n        <li>\n            <strong>Тесты (Tests)</strong> — скрипты на JavaScript, которые позволяют автоматизировать проверку ответов API.\n        </li>\n        <li>\n            <strong>Мониторинг (Monitors)</strong> — возможность запускать коллекции запросов по расписанию для мониторинга работоспособности API.\n        </li>\n        <li>\n            <strong>Документация (Documentation)</strong> — автоматическая генерация документации API на основе коллекций.\n        </li>\n    </ul>\n\n    <h2>Пример использования Postman:</h2>\n    <ol>\n        <li>\n            <strong>Создание запроса:</strong>\n            <ul>\n                <li>Выберите метод HTTP-запроса (например, GET, POST).</li>\n                <li>Укажите URL API.</li>\n                <li>Добавьте параметры, заголовки или тело запроса (если необходимо).</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Отправка запроса:</strong>\n            <ul>\n                <li>Нажмите кнопку \"Send\".</li>\n                <li>Проанализируйте ответ (статус код, тело ответа, заголовки).</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Создание тестов:</strong>\n            <ul>\n                <li>В разделе \"Tests\" напишите скрипт для проверки ответа.</li>\n                <pre>\n                    <code>\npm.test(\"Status code is 200\", function () {\n    pm.response.to.have.status(200);\n});\n\npm.test(\"Response contains expected data\", function () {\n    pm.expect(pm.response.text()).to.include(\"expected_data\");\n});\n                    </code>\n                </pre>\n            </ul>\n        </li>\n        <li>\n            <strong>Сохранение запроса в коллекцию:</strong>\n            <ul>\n                <li>Добавьте запрос в коллекцию для повторного использования.</li>\n            </ul>\n        </li>\n    </ol>\n\n    <h2>Преимущества Postman:</h2>\n    <ul>\n        <li>Удобный интерфейс для работы с API.</li>\n        <li>Поддержка множества функций для тестирования и автоматизации.</li>\n        <li>Кроссплатформенность (доступен для Windows, macOS, Linux).</li>\n        <li>Бесплатная версия с широкими возможностями.</li>\n        <li>Поддержка командной работы.</li>\n    </ul>\n\n    <h2>Недостатки Postman:</h2>\n    <ul>\n        <li>Ограниченные возможности в бесплатной версии (например, количество запросов в мониторинге).</li>\n        <li>Требует установки на локальную машину (в отличие от некоторых облачных альтернатив).</li>\n    </ul>\n\n    <h2>Альтернативы Postman:</h2>\n    <ul>\n        <li><strong>Insomnia</strong> — инструмент для работы с API с открытым исходным кодом.</li>\n        <li><strong>Swagger</strong> — фреймворк для проектирования, документирования и тестирования API.</li>\n        <li><strong>cURL</strong> — командная утилита для отправки HTTP-запросов.</li>\n    </ul>\n\n    <p>\n        Postman является мощным и удобным инструментом для работы с API, который помогает ускорить процесс разработки, тестирования и документирования.\n    </p>',6),(108,'Что такое HQL?','<p>\n        <strong>HQL</strong> (Hibernate Query Language) — это объектно-ориентированный язык запросов, используемый в Hibernate для работы с базами данных. HQL позволяет писать запросы на основе сущностей (entity) и их свойств, а не на основе таблиц и столбцов, как в SQL. Это делает HQL более удобным для работы с объектно-ориентированными моделями данных.\n    </p>\n\n    <h2>Основные особенности HQL:</h2>\n    <ul>\n        <li>Работа с объектами, а не с таблицами.</li>\n        <li>Поддержка полиморфных запросов (запросы могут возвращать объекты разных классов, связанных наследованием).</li>\n        <li>Использование имен сущностей и их свойств вместо имен таблиц и столбцов.</li>\n        <li>Поддержка JOIN, GROUP BY, HAVING и других операций, аналогичных SQL.</li>\n        <li>Интеграция с Hibernate для автоматического преобразования запросов в SQL.</li>\n    </ul>\n\n    <h2>Примеры HQL-запросов:</h2>\n    <ul>\n        <li>\n            <strong>Простой запрос:</strong>\n            <pre>\n                <code>\nString hql = \"FROM Employee\";\nQuery query = session.createQuery(hql);\nList&lt;Employee&gt; employees = query.list();\n                </code>\n            </pre>\n            <p>Этот запрос возвращает все объекты сущности <code>Employee</code>.</p>\n        </li>\n        <li>\n            <strong>Запрос с условием:</strong>\n            <pre>\n                <code>\nString hql = \"FROM Employee WHERE department = :dept\";\nQuery query = session.createQuery(hql);\nquery.setParameter(\"dept\", \"IT\");\nList&lt;Employee&gt; employees = query.list();\n                </code>\n            </pre>\n            <p>Этот запрос возвращает всех сотрудников из отдела IT.</p>\n        </li>\n        <li>\n            <strong>Запрос с агрегацией:</strong>\n            <pre>\n                <code>\nString hql = \"SELECT COUNT(e) FROM Employee e\";\nQuery query = session.createQuery(hql);\nLong count = (Long) query.uniqueResult();\n                </code>\n            </pre>\n            <p>Этот запрос возвращает количество сотрудников.</p>\n        </li>\n        <li>\n            <strong>Запрос с JOIN:</strong>\n            <pre>\n                <code>\nString hql = \"SELECT e.name, d.name FROM Employee e JOIN e.department d\";\nQuery query = session.createQuery(hql);\nList&lt;Object[]&gt; results = query.list();\n                </code>\n            </pre>\n            <p>Этот запрос возвращает имена сотрудников и их отделов.</p>\n        </li>\n    </ul>\n\n    <h2>Преимущества HQL:</h2>\n    <ul>\n        <li>Объектно-ориентированный подход — запросы пишутся на основе сущностей, что упрощает работу с объектами.</li>\n        <li>Независимость от базы данных — HQL преобразуется в SQL, специфичный для используемой СУБД.</li>\n        <li>Поддержка сложных запросов — HQL позволяет выполнять JOIN, подзапросы, агрегации и другие операции.</li>\n        <li>Интеграция с Hibernate — HQL тесно интегрирован с Hibernate, что упрощает работу с ORM.</li>\n    </ul>\n\n    <h2>Недостатки HQL:</h2>\n    <ul>\n        <li>Ограниченная поддержка специфических функций СУБД — HQL не всегда поддерживает все функции конкретной базы данных.</li>\n        <li>Необходимость знания HQL — разработчикам нужно изучить синтаксис HQL, чтобы эффективно его использовать.</li>\n    </ul>\n\n    <h2>Сравнение HQL и SQL:</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Критерий</th>\n            <th>HQL</th>\n            <th>SQL</th>\n        </tr>\n        <tr>\n            <td>Объектно-ориентированный</td>\n            <td>Да</td>\n            <td>Нет</td>\n        </tr>\n        <tr>\n            <td>Работа с сущностями</td>\n            <td>Да</td>\n            <td>Нет</td>\n        </tr>\n        <tr>\n            <td>Зависимость от СУБД</td>\n            <td>Нет</td>\n            <td>Да</td>\n        </tr>\n        <tr>\n            <td>Поддержка сложных запросов</td>\n            <td>Да</td>\n            <td>Да</td>\n        </tr>\n    </table>\n\n    <h2>Альтернативы HQL:</h2>\n    <ul>\n        <li><strong>Criteria API</strong> — типобезопасный способ создания запросов в Hibernate.</li>\n        <li><strong>Native SQL</strong> — использование SQL-запросов напрямую в Hibernate.</li>\n        <li><strong>JPQL</strong> (Java Persistence Query Language) — язык запросов, используемый в JPA, очень похожий на HQL.</li>\n    </ul>\n\n    <p>\n        HQL является мощным инструментом для работы с базами данных в Hibernate, который позволяет разработчикам писать объектно-ориентированные запросы и упрощает работу с ORM.\n    </p>',4),(109,'что такое JMM','<p>\n        <strong>Java Memory Model (JMM)</strong> — это набор правил и соглашений, которые определяют, как потоки в Java взаимодействуют с памятью. JMM описывает, как изменения, сделанные одним потоком в памяти, становятся видимыми для других потоков, и как обеспечивается корректная работа многопоточных программ. JMM играет ключевую роль в обеспечении потокобезопасности и предсказуемости поведения многопоточных приложений.\n    </p>\n\n    <h2>Основные задачи JMM:</h2>\n    <ul>\n        <li>Определение видимости изменений памяти между потоками.</li>\n        <li>Обеспечение порядка выполнения операций в многопоточной среде.</li>\n        <li>Управление взаимодействием потоков через общие переменные.</li>\n    </ul>\n\n    <h2>Основные концепции JMM:</h2>\n    <ul>\n        <li>\n            <strong>Видимость (Visibility)</strong> — гарантирует, что изменения, сделанные одним потоком в общих переменных, будут видны другим потокам.\n            <ul>\n                <li>Используются ключевые слова <code>volatile</code>, <code>synchronized</code> и другие механизмы синхронизации.</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Атомарность (Atomicity)</strong> — гарантирует, что операции над переменными будут выполняться как единое целое, без вмешательства других потоков.\n            <ul>\n                <li>Пример: операции с переменными, помеченными как <code>volatile</code>, или использование классов из пакета <code>java.util.concurrent.atomic</code>.</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Упорядочивание (Ordering)</strong> — определяет порядок выполнения операций в многопоточной среде.\n            <ul>\n                <li>JMM использует механизмы, такие как <code>happens-before</code>, для обеспечения предсказуемого порядка операций.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Принцип happens-before:</h2>\n    <p>\n        <strong>Happens-before</strong> — это отношение между операциями, которое гарантирует, что одна операция будет видна другой. Если операция A happens-before операция B, то результат операции A будет виден для операции B.\n    </p>\n    <ul>\n        <li>Примеры отношений happens-before:\n            <ul>\n                <li>Запись в <code>volatile</code> переменную happens-before чтение из неё.</li>\n                <li>Захват монитора (<code>synchronized</code>) happens-before освобождение монитора.</li>\n                <li>Запуск потока (<code>Thread.start()</code>) happens-before выполнение кода в этом потоке.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Пример проблем без JMM:</h2>\n    <pre>\n        <code>\npublic class VisibilityProblem {\n    private static boolean flag = false;\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (!flag) {} // Бесконечный цикл, если флаг не виден\n            System.out.println(\"Флаг изменён!\");\n        }).start();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        flag = true; // Изменение флага\n    }\n}\n        </code>\n    </pre>\n    <p>\n        В этом примере изменение флага в основном потоке может быть не видно в другом потоке из-за отсутствия синхронизации. Это приводит к бесконечному циклу.\n    </p>\n\n    <h2>Решение с использованием JMM:</h2>\n    <pre>\n        <code>\npublic class VisibilitySolution {\n    private static volatile boolean flag = false; // Используем volatile\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (!flag) {} // Цикл завершится, когда флаг станет true\n            System.out.println(\"Флаг изменён!\");\n        }).start();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        flag = true; // Изменение флага\n    }\n}\n        </code>\n    </pre>\n    <p>\n        Использование <code>volatile</code> гарантирует видимость изменения флага для всех потоков.\n    </p>\n\n    <h2>Преимущества JMM:</h2>\n    <ul>\n        <li>Обеспечивает предсказуемость поведения многопоточных программ.</li>\n        <li>Предоставляет механизмы для управления видимостью и порядком операций.</li>\n        <li>Позволяет избежать таких проблем, как гонки данных (race conditions) и невидимость изменений.</li>\n    </ul>\n\n    <h2>Недостатки JMM:</h2>\n    <ul>\n        <li>Сложность понимания и правильного использования.</li>\n        <li>Требует внимательного подхода к синхронизации и управлению памятью.</li>\n    </ul>\n\n    <h2>Альтернативы и дополнения:</h2>\n    <ul>\n        <li><strong>java.util.concurrent</strong> — пакет, предоставляющий высокоуровневые инструменты для многопоточности (например, <code>AtomicInteger</code>, <code>ReentrantLock</code>).</li>\n        <li><strong>ThreadLocal</strong> — механизм для хранения данных, специфичных для каждого потока.</li>\n    </ul>\n\n    <p>\n        Java Memory Model (JMM) является важной частью многопоточного программирования в Java, обеспечивая корректное взаимодействие потоков и управление памятью.\n    </p>',5),(110,'что такое JMS',' <p>\n        <strong>Java Message Service (JMS)</strong> — это API (интерфейс программирования приложений) для работы с системами обмена сообщениями в Java. JMS позволяет приложениям создавать, отправлять, получать и читать сообщения асинхронно, что делает его полезным для построения распределённых и слабосвязанных систем.\n    </p>\n\n    <h2>Основные концепции JMS:</h2>\n    <ul>\n        <li>\n            <strong>Сообщение (Message)</strong> — единица данных, передаваемая между приложениями. Сообщение может содержать текст, объекты, байты и другие данные.\n        </li>\n        <li>\n            <strong>Очередь (Queue)</strong> — точка назначения для сообщений в модели \"точка-точка\" (Point-to-Point). Сообщения в очереди обрабатываются одним получателем.\n        </li>\n        <li>\n            <strong>Топик (Topic)</strong> — точка назначения для сообщений в модели \"издатель-подписчик\" (Publish/Subscribe). Сообщения в топике доставляются всем подписчикам.\n        </li>\n        <li>\n            <strong>Поставщик (Provider)</strong> — реализация JMS, которая управляет очередями и топиками (например, Apache ActiveMQ, IBM MQ).\n        </li>\n        <li>\n            <strong>Клиент (Client)</strong> — приложение, которое отправляет или получает сообщения.\n        </li>\n        <li>\n            <strong>Отправитель (Producer)</strong> — клиент, который создаёт и отправляет сообщения.\n        </li>\n        <li>\n            <strong>Получатель (Consumer)</strong> — клиент, который получает и обрабатывает сообщения.\n        </li>\n    </ul>\n\n    <h2>Модели обмена сообщениями в JMS:</h2>\n    <ul>\n        <li>\n            <strong>Точка-точка (Point-to-Point)</strong>:\n            <ul>\n                <li>Сообщения отправляются в очередь и обрабатываются одним получателем.</li>\n                <li>Пример использования: задачи, которые должны быть выполнены только один раз.</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Издатель-подписчик (Publish/Subscribe)</strong>:\n            <ul>\n                <li>Сообщения отправляются в топик и доставляются всем подписчикам.</li>\n                <li>Пример использования: уведомления или события, которые должны быть обработаны несколькими системами.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Пример использования JMS:</h2>\n    <pre>\n        <code>\nimport javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JMSExample {\n    public static void main(String[] args) throws JMSException {\n        // Создаём фабрику соединений\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n\n        // Создаём соединение\n        Connection connection = connectionFactory.createConnection();\n        connection.start();\n\n        // Создаём сессию\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        // Создаём очередь\n        Queue queue = session.createQueue(\"exampleQueue\");\n\n        // Создаём отправителя\n        MessageProducer producer = session.createProducer(queue);\n\n        // Создаём текстовое сообщение\n        TextMessage message = session.createTextMessage(\"Привет, JMS!\");\n\n        // Отправляем сообщение\n        producer.send(message);\n        System.out.println(\"Сообщение отправлено: \" + message.getText());\n\n        // Создаём получателя\n        MessageConsumer consumer = session.createConsumer(queue);\n\n        // Получаем сообщение\n        Message receivedMessage = consumer.receive();\n        if (receivedMessage instanceof TextMessage) {\n            TextMessage textMessage = (TextMessage) receivedMessage;\n            System.out.println(\"Сообщение получено: \" + textMessage.getText());\n        }\n\n        // Закрываем соединение\n        session.close();\n        connection.close();\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Преимущества JMS:</h2>\n    <ul>\n        <li>Асинхронность — отправка и получение сообщений происходит независимо.</li>\n        <li>Надёжность — сообщения могут быть сохранены и доставлены даже в случае сбоев.</li>\n        <li>Гибкость — поддержка моделей \"точка-точка\" и \"издатель-подписчик\".</li>\n        <li>Интеграция — JMS легко интегрируется с другими Java-приложениями.</li>\n    </ul>\n\n    <h2>Недостатки JMS:</h2>\n    <ul>\n        <li>Сложность настройки и управления.</li>\n        <li>Зависимость от реализации поставщика (например, Apache ActiveMQ, IBM MQ).</li>\n        <li>Ограниченная поддержка в облачных средах (в современных системах часто используются альтернативы, такие как Kafka или RabbitMQ).</li>\n    </ul>\n\n    <h2>Альтернативы JMS:</h2>\n    <ul>\n        <li><strong>Apache Kafka</strong> — распределённая система обмена сообщениями, ориентированная на высокую производительность и масштабируемость.</li>\n        <li><strong>RabbitMQ</strong> — брокер сообщений, поддерживающий различные протоколы (AMQP, MQTT).</li>\n        <li><strong>Amazon SQS</strong> — облачная очередь сообщений от Amazon Web Services.</li>\n    </ul>\n\n    <p>\n        JMS является мощным инструментом для построения асинхронных и распределённых систем в Java, обеспечивая надёжность и гибкость в обмене сообщениями.\n    </p>',12),(111,'Что такое RabbitMq',' <p>\n        <strong>RabbitMQ</strong> — это брокер сообщений с открытым исходным кодом, который реализует протокол AMQP (Advanced Message Queuing Protocol). Он используется для организации асинхронного обмена сообщениями между приложениями, системами или компонентами. RabbitMQ обеспечивает надёжную доставку сообщений, балансировку нагрузки и масштабируемость, что делает его популярным инструментом для построения распределённых систем.\n    </p>\n\n    <h2>Основные концепции RabbitMQ:</h2>\n    <ul>\n        <li>\n            <strong>Сообщение (Message)</strong> — данные, которые передаются между приложениями. Сообщение может содержать текст, JSON, XML или другие форматы.\n        </li>\n        <li>\n            <strong>Очередь (Queue)</strong> — структура, в которой хранятся сообщения до их обработки получателем.\n        </li>\n        <li>\n            <strong>Обменник (Exchange)</strong> — компонент, который получает сообщения от отправителей и направляет их в очереди на основе определённых правил (routing keys).\n        </li>\n        <li>\n            <strong>Связка (Binding)</strong> — правило, которое связывает обменник с очередью и определяет, как сообщения будут направляться.\n        </li>\n        <li>\n            <strong>Производитель (Producer)</strong> — приложение или компонент, который отправляет сообщения в RabbitMQ.\n        </li>\n        <li>\n            <strong>Потребитель (Consumer)</strong> — приложение или компонент, который получает и обрабатывает сообщения из очереди.\n        </li>\n    </ul>\n\n    <h2>Типы обменников (Exchanges) в RabbitMQ:</h2>\n    <ul>\n        <li>\n            <strong>Direct</strong> — сообщения направляются в очередь, если routing key сообщения совпадает с routing key очереди.\n        </li>\n        <li>\n            <strong>Fanout</strong> — сообщения направляются во все связанные очереди, игнорируя routing key.\n        </li>\n        <li>\n            <strong>Topic</strong> — сообщения направляются в очереди на основе совпадения routing key с шаблоном (pattern).\n        </li>\n        <li>\n            <strong>Headers</strong> — сообщения направляются в очереди на основе заголовков, а не routing key.\n        </li>\n    </ul>\n\n    <h2>Пример работы RabbitMQ:</h2>\n    <ol>\n        <li>\n            <strong>Производитель отправляет сообщение в обменник.</strong>\n            <pre>\n                <code>\nchannel.basicPublish(exchangeName, routingKey, null, message.getBytes());\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Обменник направляет сообщение в очередь на основе routing key.</strong>\n        </li>\n        <li>\n            <strong>Потребитель получает сообщение из очереди.</strong>\n            <pre>\n                <code>\nchannel.basicConsume(queueName, true, (consumerTag, delivery) -> {\n    String message = new String(delivery.getBody(), \"UTF-8\");\n    System.out.println(\"Получено сообщение: \" + message);\n}, consumerTag -> {});\n                </code>\n            </pre>\n        </li>\n    </ol>\n\n    <h2>Преимущества RabbitMQ:</h2>\n    <ul>\n        <li>Надёжность — поддержка подтверждений доставки и сохранение сообщений на диск.</li>\n        <li>Гибкость — поддержка различных моделей обмена сообщениями (Direct, Fanout, Topic, Headers).</li>\n        <li>Масштабируемость — возможность кластеризации и балансировки нагрузки.</li>\n        <li>Кроссплатформенность — поддержка множества языков программирования (Java, Python, .NET и др.).</li>\n        <li>Открытый исходный код — RabbitMQ бесплатен и активно развивается сообществом.</li>\n    </ul>\n\n    <h2>Недостатки RabbitMQ:</h2>\n    <ul>\n        <li>Сложность настройки и управления для больших и сложных систем.</li>\n        <li>Ограниченная производительность по сравнению с некоторыми современными брокерами (например, Apache Kafka).</li>\n        <li>Требует дополнительных усилий для обеспечения высокой доступности и отказоустойчивости.</li>\n    </ul>\n\n    <h2>Сравнение RabbitMQ и Apache Kafka:</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Критерий</th>\n            <th>RabbitMQ</th>\n            <th>Apache Kafka</th>\n        </tr>\n        <tr>\n            <td>Основное назначение</td>\n            <td>Обмен сообщениями</td>\n            <td>Обработка потоков данных</td>\n        </tr>\n        <tr>\n            <td>Протокол</td>\n            <td>AMQP, MQTT, STOMP</td>\n            <td>Собственный протокол</td>\n        </tr>\n        <tr>\n            <td>Производительность</td>\n            <td>Средняя</td>\n            <td>Высокая</td>\n        </tr>\n        <tr>\n            <td>Масштабируемость</td>\n            <td>Хорошая</td>\n            <td>Отличная</td>\n        </tr>\n    </table>\n\n    <h2>Альтернативы RabbitMQ:</h2>\n    <ul>\n        <li><strong>Apache Kafka</strong> — распределённая система для обработки потоков данных.</li>\n        <li><strong>Amazon SQS</strong> — облачная очередь сообщений от Amazon Web Services.</li>\n        <li><strong>ActiveMQ</strong> — брокер сообщений с поддержкой JMS.</li>\n    </ul>\n\n    <p>\n        RabbitMQ является мощным инструментом для организации асинхронного обмена сообщениями, который подходит для широкого спектра задач, от простых очередей до сложных распределённых систем.\n    </p>',12),(112,'Что такое Kafka','<p>\n        <strong>Apache Kafka</strong> — это распределённая потоковая платформа с открытым исходным кодом, разработанная для обработки потоков данных в реальном времени. Kafka позволяет собирать, хранить и обрабатывать большие объёмы данных с высокой пропускной способностью и низкой задержкой. Она широко используется для построения масштабируемых и отказоустойчивых систем, таких как системы обработки событий, логов, метрик и потоковых данных.\n    </p>\n\n    <h2>Основные концепции Kafka:</h2>\n    <ul>\n        <li>\n            <strong>Топик (Topic)</strong> — категория или имя потока данных, в который записываются сообщения. Топики разделяются на разделы (partitions) для масштабируемости.\n        </li>\n        <li>\n            <strong>Раздел (Partition)</strong> — часть топика, которая хранится на одном или нескольких серверах (брокерах). Каждый раздел упорядочен и неизменяем.\n        </li>\n        <li>\n            <strong>Сообщение (Message)</strong> — единица данных, которая состоит из ключа, значения и метаданных (например, временной метки).\n        </li>\n        <li>\n            <strong>Производитель (Producer)</strong> — приложение или компонент, который отправляет сообщения в топик.\n        </li>\n        <li>\n            <strong>Потребитель (Consumer)</strong> — приложение или компонент, которое читает сообщения из топика.\n        </li>\n        <li>\n            <strong>Брокер (Broker)</strong> — сервер, который хранит данные и управляет топиками и разделами.\n        </li>\n        <li>\n            <strong>Кластер (Cluster)</strong> — группа брокеров, работающих вместе для обеспечения отказоустойчивости и масштабируемости.\n        </li>\n        <li>\n            <strong>Zookeeper</strong> — служба, которая управляет метаданными кластера Kafka (в новых версиях Kafka постепенно уходит от зависимости от Zookeeper).\n        </li>\n    </ul>\n\n    <h2>Архитектура Kafka:</h2>\n    <ul>\n        <li>\n            <strong>Производители</strong> отправляют сообщения в топики.\n        </li>\n        <li>\n            <strong>Топики</strong> разделяются на разделы для распределения нагрузки.\n        </li>\n        <li>\n            <strong>Потребители</strong> читают сообщения из топиков, объединяясь в группы (consumer groups) для параллельной обработки.\n        </li>\n        <li>\n            <strong>Брокеры</strong> хранят данные и обеспечивают их доступность.\n        </li>\n    </ul>\n\n    <h2>Пример работы Kafka:</h2>\n    <ol>\n        <li>\n            <strong>Производитель отправляет сообщение в топик.</strong>\n            <pre>\n                <code>\nProducerRecord&lt;String, String&gt; record = new ProducerRecord<>(\"my-topic\", \"key\", \"value\");\nproducer.send(record);\n                </code>\n            </pre>\n        </li>\n        <li>\n            <strong>Сообщение записывается в раздел топика.</strong>\n        </li>\n        <li>\n            <strong>Потребитель читает сообщение из топика.</strong>\n            <pre>\n                <code>\nConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));\nfor (ConsumerRecord&lt;String, String&gt; record : records) {\n    System.out.println(\"Получено сообщение: \" + record.value());\n}\n                </code>\n            </pre>\n        </li>\n    </ol>\n\n    <h2>Преимущества Kafka:</h2>\n    <ul>\n        <li>Высокая производительность — Kafka способна обрабатывать миллионы сообщений в секунду.</li>\n        <li>Масштабируемость — легко масштабируется за счёт разделов и кластеров.</li>\n        <li>Отказоустойчивость — данные реплицируются между брокерами, что обеспечивает высокую доступность.</li>\n        <li>Хранение данных — Kafka хранит сообщения в течение определённого времени, что позволяет повторно обрабатывать данные.</li>\n        <li>Интеграция — Kafka поддерживает множество языков программирования и интеграцию с другими системами (например, Hadoop, Spark).</li>\n    </ul>\n\n    <h2>Недостатки Kafka:</h2>\n    <ul>\n        <li>Сложность настройки и управления — требует глубокого понимания архитектуры и конфигурации.</li>\n        <li>Высокие требования к ресурсам — Kafka требует значительных вычислительных ресурсов и дискового пространства.</li>\n        <li>Ограниченная поддержка транзакций — Kafka не предназначена для сложных транзакционных сценариев.</li>\n    </ul>\n\n    <h2>Сравнение Kafka и RabbitMQ:</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Критерий</th>\n            <th>Kafka</th>\n            <th>RabbitMQ</th>\n        </tr>\n        <tr>\n            <td>Основное назначение</td>\n            <td>Обработка потоков данных</td>\n            <td>Обмен сообщениями</td>\n        </tr>\n        <tr>\n            <td>Производительность</td>\n            <td>Очень высокая</td>\n            <td>Средняя</td>\n        </tr>\n        <tr>\n            <td>Масштабируемость</td>\n            <td>Отличная</td>\n            <td>Хорошая</td>\n        </tr>\n        <tr>\n            <td>Хранение данных</td>\n            <td>Да (временное)</td>\n            <td>Нет</td>\n        </tr>\n    </table>\n\n    <h2>Альтернативы Kafka:</h2>\n    <ul>\n        <li><strong>RabbitMQ</strong> — брокер сообщений, ориентированный на обмен сообщениями.</li>\n        <li><strong>Amazon Kinesis</strong> — облачная платформа для обработки потоков данных от AWS.</li>\n        <li><strong>Apache Pulsar</strong> — распределённая потоковая платформа с поддержкой множества функций.</li>\n    </ul>\n\n    <p>\n        Apache Kafka является мощным инструментом для обработки потоков данных в реальном времени, который подходит для построения высоконагруженных и масштабируемых систем.\n    </p>',12),(113,'Что такое ActiveMQ',' <p>\n        <strong>ActiveMQ</strong> — это брокер сообщений с открытым исходным кодом, который реализует стандарт JMS (Java Message Service) и поддерживает множество протоколов, таких как AMQP, MQTT, STOMP и другие. ActiveMQ используется для организации асинхронного обмена сообщениями между приложениями и системами, обеспечивая надёжность, масштабируемость и гибкость.\n    </p>\n\n    <h2>Основные концепции ActiveMQ:</h2>\n    <ul>\n        <li>\n            <strong>Сообщение (Message)</strong> — единица данных, передаваемая между приложениями. Сообщение может содержать текст, объекты, байты и другие данные.\n        </li>\n        <li>\n            <strong>Очередь (Queue)</strong> — точка назначения для сообщений в модели \"точка-точка\" (Point-to-Point). Сообщения в очереди обрабатываются одним получателем.\n        </li>\n        <li>\n            <strong>Топик (Topic)</strong> — точка назначения для сообщений в модели \"издатель-подписчик\" (Publish/Subscribe). Сообщения в топике доставляются всем подписчикам.\n        </li>\n        <li>\n            <strong>Брокер (Broker)</strong> — сервер, который управляет очередями, топиками и маршрутизацией сообщений.\n        </li>\n        <li>\n            <strong>Производитель (Producer)</strong> — приложение или компонент, который отправляет сообщения в ActiveMQ.\n        </li>\n        <li>\n            <strong>Потребитель (Consumer)</strong> — приложение или компонент, который получает и обрабатывает сообщения из очереди или топика.\n        </li>\n    </ul>\n\n    <h2>Модели обмена сообщениями в ActiveMQ:</h2>\n    <ul>\n        <li>\n            <strong>Точка-точка (Point-to-Point)</strong>:\n            <ul>\n                <li>Сообщения отправляются в очередь и обрабатываются одним получателем.</li>\n                <li>Пример использования: задачи, которые должны быть выполнены только один раз.</li>\n            </ul>\n        </li>\n        <li>\n            <strong>Издатель-подписчик (Publish/Subscribe)</strong>:\n            <ul>\n                <li>Сообщения отправляются в топик и доставляются всем подписчикам.</li>\n                <li>Пример использования: уведомления или события, которые должны быть обработаны несколькими системами.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Пример использования ActiveMQ:</h2>\n    <pre>\n        <code>\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class ActiveMQExample {\n    public static void main(String[] args) throws JMSException {\n        // Создаём фабрику соединений\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n\n        // Создаём соединение\n        Connection connection = connectionFactory.createConnection();\n        connection.start();\n\n        // Создаём сессию\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        // Создаём очередь\n        Queue queue = session.createQueue(\"exampleQueue\");\n\n        // Создаём отправителя\n        MessageProducer producer = session.createProducer(queue);\n\n        // Создаём текстовое сообщение\n        TextMessage message = session.createTextMessage(\"Привет, ActiveMQ!\");\n\n        // Отправляем сообщение\n        producer.send(message);\n        System.out.println(\"Сообщение отправлено: \" + message.getText());\n\n        // Создаём получателя\n        MessageConsumer consumer = session.createConsumer(queue);\n\n        // Получаем сообщение\n        Message receivedMessage = consumer.receive();\n        if (receivedMessage instanceof TextMessage) {\n            TextMessage textMessage = (TextMessage) receivedMessage;\n            System.out.println(\"Сообщение получено: \" + textMessage.getText());\n        }\n\n        // Закрываем соединение\n        session.close();\n        connection.close();\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Преимущества ActiveMQ:</h2>\n    <ul>\n        <li>Поддержка JMS — ActiveMQ полностью совместим с Java Message Service.</li>\n        <li>Многопротокольность — поддерживает AMQP, MQTT, STOMP и другие протоколы.</li>\n        <li>Надёжность — сообщения могут быть сохранены на диск для обеспечения отказоустойчивости.</li>\n        <li>Масштабируемость — возможность кластеризации для повышения производительности и доступности.</li>\n        <li>Открытый исходный код — ActiveMQ бесплатен и активно развивается сообществом.</li>\n    </ul>\n\n    <h2>Недостатки ActiveMQ:</h2>\n    <ul>\n        <li>Сложность настройки и управления для больших и сложных систем.</li>\n        <li>Ограниченная производительность по сравнению с некоторыми современными брокерами (например, Apache Kafka).</li>\n        <li>Требует дополнительных усилий для обеспечения высокой доступности и отказоустойчивости.</li>\n    </ul>\n\n    <h2>Сравнение ActiveMQ и RabbitMQ:</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Критерий</th>\n            <th>ActiveMQ</th>\n            <th>RabbitMQ</th>\n        </tr>\n        <tr>\n            <td>Основное назначение</td>\n            <td>Обмен сообщениями (JMS)</td>\n            <td>Обмен сообщениями (AMQP)</td>\n        </tr>\n        <tr>\n            <td>Протоколы</td>\n            <td>JMS, AMQP, MQTT, STOMP</td>\n            <td>AMQP, MQTT, STOMP</td>\n        </tr>\n        <tr>\n            <td>Производительность</td>\n            <td>Средняя</td>\n            <td>Средняя</td>\n        </tr>\n        <tr>\n            <td>Масштабируемость</td>\n            <td>Хорошая</td>\n            <td>Хорошая</td>\n        </tr>\n    </table>\n\n    <h2>Альтернативы ActiveMQ:</h2>\n    <ul>\n        <li><strong>RabbitMQ</strong> — брокер сообщений, ориентированный на AMQP.</li>\n        <li><strong>Apache Kafka</strong> — распределённая потоковая платформа для обработки потоков данных.</li>\n        <li><strong>Amazon SQS</strong> — облачная очередь сообщений от Amazon Web Services.</li>\n    </ul>\n\n    <p>\n        ActiveMQ является мощным инструментом для организации асинхронного обмена сообщениями, который подходит для широкого спектра задач, от простых очередей до сложных распределённых систем.\n    </p>',12),(114,'Как начать тестирование с JUnit?','<p>\n        <strong>JUnit</strong> — это популярный фреймворк для модульного тестирования (unit testing) в Java. Он позволяет разработчикам писать и запускать тесты для проверки корректности работы отдельных частей кода. В этом руководстве вы узнаете, как начать тестирование с использованием JUnit.\n    </p>\n\n    <h2>Шаг 1: Установка JUnit</h2>\n    <p>\n        Для начала работы с JUnit необходимо добавить зависимость в ваш проект. Если вы используете Maven или Gradle, добавьте следующие зависимости:\n    </p>\n\n    <h3>Для Maven:</h3>\n    <pre>\n        <code>\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n    &lt;version&gt;5.10.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;\n    &lt;version&gt;5.10.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n        </code>\n    </pre>\n\n    <h3>Для Gradle:</h3>\n    <pre>\n        <code>\ntestImplementation \'org.junit.jupiter:junit-jupiter-api:5.10.0\'\ntestRuntimeOnly \'org.junit.jupiter:junit-jupiter-engine:5.10.0\'\n        </code>\n    </pre>\n\n    <h2>Шаг 2: Создание тестового класса</h2>\n    <p>\n        Создайте класс, который будет содержать тесты. Обычно тестовые классы имеют суффикс <code>Test</code> и находятся в директории <code>src/test/java</code>.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testSubtraction() {\n        Calculator calculator = new Calculator();\n        int result = calculator.subtract(5, 3);\n        assertEquals(2, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Шаг 3: Написание тестов</h2>\n    <p>\n        Тестовые методы помечаются аннотацией <code>@Test</code>. Внутри тестового метода используются утверждения (assertions) для проверки ожидаемых результатов.\n    </p>\n    <ul>\n        <li>\n            <strong><code>assertEquals(expected, actual)</code></strong> — проверяет, что ожидаемое значение равно фактическому.\n        </li>\n        <li>\n            <strong><code>assertTrue(condition)</code></strong> — проверяет, что условие истинно.\n        </li>\n        <li>\n            <strong><code>assertFalse(condition)</code></strong> — проверяет, что условие ложно.\n        </li>\n        <li>\n            <strong><code>assertNull(object)</code></strong> — проверяет, что объект равен <code>null</code>.\n        </li>\n        <li>\n            <strong><code>assertNotNull(object)</code></strong> — проверяет, что объект не равен <code>null</code>.\n        </li>\n    </ul>\n\n    <h2>Шаг 4: Запуск тестов</h2>\n    <p>\n        Тесты можно запустить из командной строки или из вашей IDE (например, IntelliJ IDEA, Eclipse).\n    </p>\n\n    <h3>Запуск из командной строки:</h3>\n    <pre>\n        <code>\nmvn test\n        </code>\n    </pre>\n    <p>или</p>\n    <pre>\n        <code>\ngradle test\n        </code>\n    </pre>\n\n    <h3>Запуск из IDE:</h3>\n    <p>\n        В IDE, такой как IntelliJ IDEA, вы можете щёлкнуть правой кнопкой мыши на тестовом классе или методе и выбрать \"Run\".\n    </p>\n\n    <h2>Шаг 5: Использование аннотаций для настройки тестов</h2>\n    <p>\n        JUnit предоставляет несколько аннотаций для настройки тестов:\n    </p>\n    <ul>\n        <li>\n            <strong><code>@BeforeEach</code></strong> — метод, помеченный этой аннотацией, выполняется перед каждым тестом.\n        </li>\n        <li>\n            <strong><code>@AfterEach</code></strong> — метод, помеченный этой аннотацией, выполняется после каждого теста.\n        </li>\n        <li>\n            <strong><code>@BeforeAll</code></strong> — метод, помеченный этой аннотацией, выполняется один раз перед всеми тестами в классе.\n        </li>\n        <li>\n            <strong><code>@AfterAll</code></strong> — метод, помеченный этой аннотацией, выполняется один раз после всех тестов в классе.\n        </li>\n        <li>\n            <strong><code>@Disabled</code></strong> — игнорирует выполнение тестового метода или класса.\n        </li>\n    </ul>\n\n    <h2>Пример использования аннотаций:</h2>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.*;\n\npublic class CalculatorTest {\n\n    private Calculator calculator;\n\n    @BeforeEach\n    public void setUp() {\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testAddition() {\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n\n    @Test\n    @Disabled(\"Тест временно отключён\")\n    public void testSubtraction() {\n        int result = calculator.subtract(5, 3);\n        assertEquals(2, result);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        calculator = null;\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Шаг 6: Параметризованные тесты</h2>\n    <p>\n        JUnit поддерживает параметризованные тесты, которые позволяют запускать один тест с разными наборами данных.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ParameterizedTestExample {\n\n    @ParameterizedTest\n    @ValueSource(ints = {1, 2, 3})\n    public void testIsPositive(int number) {\n        assertTrue(number > 0);\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Заключение</h2>\n    <p>\n        JUnit — это мощный инструмент для модульного тестирования в Java, который помогает разработчикам писать надёжные и поддерживаемые тесты. Следуя этому руководству, вы сможете начать писать и запускать тесты с использованием JUnit.\n    </p>',8),(115,'Аннотации в JUnit',' <p>\n        В JUnit аннотации используются для настройки и управления тестами. Они позволяют определить, как и когда должны выполняться тестовые методы, а также как должны настраиваться и очищаться ресурсы. В этом руководстве подробно рассмотрены основные аннотации JUnit и их использование.\n    </p>\n\n    <h2>Основные аннотации JUnit</h2>\n    <p>\n        JUnit предоставляет множество аннотаций для управления жизненным циклом тестов и их поведением. Ниже приведены основные аннотации:\n    </p>\n\n    <h3>1. <code>@Test</code></h3>\n    <p>\n        Аннотация <code>@Test</code> указывает, что метод является тестовым. Методы, помеченные этой аннотацией, будут выполняться как тесты.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ExampleTest {\n\n    @Test\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>2. <code>@BeforeEach</code></h3>\n    <p>\n        Метод, помеченный аннотацией <code>@BeforeEach</code>, выполняется перед каждым тестовым методом. Это полезно для настройки тестового окружения.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTest {\n\n    private Calculator calculator;\n\n    @BeforeEach\n    public void setUp() {\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testAddition() {\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>3. <code>@AfterEach</code></h3>\n    <p>\n        Метод, помеченный аннотацией <code>@AfterEach</code>, выполняется после каждого тестового метода. Это полезно для очистки ресурсов.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTest {\n\n    private Calculator calculator;\n\n    @AfterEach\n    public void tearDown() {\n        calculator = null;\n    }\n\n    @Test\n    public void testAddition() {\n        calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>4. <code>@BeforeAll</code></h3>\n    <p>\n        Метод, помеченный аннотацией <code>@BeforeAll</code>, выполняется один раз перед всеми тестами в классе. Этот метод должен быть статическим.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTest {\n\n    private static Calculator calculator;\n\n    @BeforeAll\n    public static void setUpClass() {\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testAddition() {\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>5. <code>@AfterAll</code></h3>\n    <p>\n        Метод, помеченный аннотацией <code>@AfterAll</code>, выполняется один раз после всех тестов в классе. Этот метод должен быть статическим.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTest {\n\n    private static Calculator calculator;\n\n    @AfterAll\n    public static void tearDownClass() {\n        calculator = null;\n    }\n\n    @Test\n    public void testAddition() {\n        calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>6. <code>@Disabled</code></h3>\n    <p>\n        Аннотация <code>@Disabled</code> используется для временного отключения тестового метода или класса. Отключённые тесты не будут выполняться.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTest {\n\n    @Test\n    @Disabled(\"Тест временно отключён\")\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>7. <code>@DisplayName</code></h3>\n    <p>\n        Аннотация <code>@DisplayName</code> позволяет задать читаемое имя для тестового метода или класса, которое будет отображаться в отчётах.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\n@DisplayName(\"Тесты для калькулятора\")\npublic class ExampleTest {\n\n    @Test\n    @DisplayName(\"Проверка сложения\")\n    public void testAddition() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>8. <code>@ParameterizedTest</code></h3>\n    <p>\n        Аннотация <code>@ParameterizedTest</code> используется для создания параметризованных тестов, которые могут выполняться с разными наборами данных.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ParameterizedTestExample {\n\n    @ParameterizedTest\n    @ValueSource(ints = {1, 2, 3})\n    public void testIsPositive(int number) {\n        assertTrue(number > 0);\n    }\n}\n        </code>\n    </pre>\n\n    <h3>9. <code>@RepeatedTest</code></h3>\n    <p>\n        Аннотация <code>@RepeatedTest</code> позволяет повторять выполнение теста указанное количество раз.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.RepeatedTest;\n\npublic class RepeatedTestExample {\n\n    @RepeatedTest(5)\n    public void testRepeated() {\n        System.out.println(\"Тест выполнен\");\n    }\n}\n        </code>\n    </pre>\n\n    <h3>10. <code>@Timeout</code></h3>\n    <p>\n        Аннотация <code>@Timeout</code> позволяет задать максимальное время выполнения теста. Если тест выполняется дольше указанного времени, он будет прерван.\n    </p>\n    <pre>\n        <code>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport java.util.concurrent.TimeUnit;\n\npublic class TimeoutTestExample {\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testTimeout() throws InterruptedException {\n        Thread.sleep(400); // Тест пройдёт успешно\n    }\n}\n        </code>\n    </pre>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации в JUnit предоставляют мощные инструменты для управления тестами, их настройки и выполнения. Используя эти аннотации, вы можете создавать гибкие и поддерживаемые тесты, которые помогут вам обеспечить качество вашего кода.\n    </p>',8),(116,'Что такое набор тестов (Test Suite)?','<p>\n        <strong>Набор тестов (Test Suite)</strong> — это коллекция тестовых случаев (test cases), которые объединены для проверки функциональности, производительности или других аспектов программного обеспечения. Набор тестов позволяет организовать и выполнять тесты систематически, что упрощает процесс тестирования и повышает его эффективность.\n    </p>\n\n    <h2>Как создается набор тестов?</h2>\n    <p>\n        Создание набора тестов включает несколько этапов:\n    </p>\n    <ol>\n        <li><strong>Определение целей тестирования:</strong> Необходимо понять, какие аспекты программного обеспечения нужно проверить (функциональность, производительность, безопасность и т.д.).</li>\n        <li><strong>Создание тестовых случаев:</strong> Разработка отдельных тестов, которые проверяют конкретные функции или сценарии использования.</li>\n        <li><strong>Организация тестов:</strong> Тестовые случаи группируются в наборы в зависимости от их назначения (например, модульные тесты, интеграционные тесты, регрессионные тесты).</li>\n        <li><strong>Автоматизация (опционально):</strong> Набор тестов может быть автоматизирован с использованием инструментов тестирования, таких как Selenium, JUnit, TestNG и других.</li>\n        <li><strong>Документация:</strong> Каждый тестовый случай и набор тестов должны быть задокументированы для удобства использования и поддержки.</li>\n    </ol>\n\n    <h2>Как используется набор тестов?</h2>\n    <p>\n        Набор тестов используется для:\n    </p>\n    <ul>\n        <li><strong>Проверки корректности работы:</strong> Тесты выполняются для проверки, что программное обеспечение работает в соответствии с требованиями.</li>\n        <li><strong>Регрессионного тестирования:</strong> После внесения изменений в код набор тестов помогает убедиться, что существующие функции не сломались.</li>\n        <li><strong>Интеграционного тестирования:</strong> Проверка взаимодействия между различными модулями или компонентами системы.</li>\n        <li><strong>Автоматизации процессов:</strong> Набор тестов может быть интегрирован в CI/CD (Continuous Integration/Continuous Deployment) для автоматического запуска тестов при каждом изменении кода.</li>\n    </ul>\n\n    <h2>Пример использования набора тестов</h2>\n    <p>\n        Предположим, у вас есть веб-приложение, и вы хотите проверить его функциональность. Вы можете создать набор тестов, который включает:\n    </p>\n    <ul>\n        <li>Тесты для проверки авторизации пользователя.</li>\n        <li>Тесты для проверки работы форм.</li>\n        <li>Тесты для проверки корректности отображения данных.</li>\n    </ul>\n    <p>\n        Эти тесты могут быть запущены автоматически при каждом обновлении кода, чтобы убедиться, что новые изменения не нарушили существующую функциональность.\n    </p>\n',8),(117,'Виды тестирования',' <p>\n        Тестирование программного обеспечения — это процесс проверки соответствия программы заданным требованиям и ожиданиям. Существует множество видов тестирования, каждый из которых направлен на решение конкретных задач. Ниже представлены основные виды тестирования.\n    </p>\n\n    <h2>1. Функциональное тестирование</h2>\n    <p>\n        Проверяет, соответствует ли программное обеспечение заявленным функциональным требованиям. Основные типы:\n    </p>\n    <ul>\n        <li><strong>Модульное тестирование (Unit Testing):</strong> Проверка отдельных компонентов или модулей программы.</li>\n        <li><strong>Интеграционное тестирование (Integration Testing):</strong> Проверка взаимодействия между различными модулями или компонентами системы.</li>\n        <li><strong>Системное тестирование (System Testing):</strong> Проверка работы системы в целом.</li>\n        <li><strong>Приемочное тестирование (Acceptance Testing):</strong> Проверка, удовлетворяет ли система требованиям заказчика.</li>\n    </ul>\n\n    <h2>2. Нефункциональное тестирование</h2>\n    <p>\n        Проверяет аспекты, не связанные с функциональностью, такие как производительность, безопасность и удобство использования. Основные типы:\n    </p>\n    <ul>\n        <li><strong>Тестирование производительности (Performance Testing):</strong> Проверка скорости, отзывчивости и стабильности системы под нагрузкой.</li>\n        <li><strong>Нагрузочное тестирование (Load Testing):</strong> Проверка поведения системы при высокой нагрузке.</li>\n        <li><strong>Стрессовое тестирование (Stress Testing):</strong> Проверка системы в условиях, превышающих пределы нормальной работы.</li>\n        <li><strong>Тестирование безопасности (Security Testing):</strong> Проверка уязвимостей и защищенности системы.</li>\n        <li><strong>Тестирование удобства использования (Usability Testing):</strong> Проверка того, насколько система удобна для пользователя.</li>\n    </ul>\n\n    <h2>3. Регрессионное тестирование</h2>\n    <p>\n        Проверка того, что новые изменения в коде не повлияли на уже существующую функциональность. Это важно для поддержания стабильности системы.\n    </p>\n\n    <h2>4. Тестирование пользовательского интерфейса (UI Testing)</h2>\n    <p>\n        Проверка корректности отображения и взаимодействия элементов интерфейса с пользователем.\n    </p>\n\n    <h2>5. Тестирование API</h2>\n    <p>\n        Проверка работы интерфейсов программирования приложений (API), которые обеспечивают взаимодействие между различными компонентами системы.\n    </p>\n\n    <h2>6. Тестирование совместимости</h2>\n    <p>\n        Проверка работы системы на различных устройствах, операционных системах, браузерах и в разных условиях.\n    </p>\n\n    <h2>7. Дымовое тестирование (Smoke Testing)</h2>\n    <p>\n        Быстрая проверка основных функций системы для убеждения в том, что она готова к более глубокому тестированию.\n    </p>\n\n    <h2>8. Санитарное тестирование (Sanity Testing)</h2>\n    <p>\n        Узконаправленная проверка после внесения изменений в код, чтобы убедиться, что исправления работают корректно.\n    </p>\n\n    <h2>9. Тестирование установки (Installation Testing)</h2>\n    <p>\n        Проверка процесса установки, настройки и удаления программного обеспечения.\n    </p>\n\n    <h2>10. Исследовательское тестирование (Exploratory Testing)</h2>\n    <p>\n        Тестирование без заранее подготовленных тестовых случаев, основанное на интуиции и опыте тестировщика.\n    </p>\n\n    <h2>11. Тестирование локализации (Localization Testing)</h2>\n    <p>\n        Проверка адаптации программного обеспечения для использования в различных регионах и языковых средах.\n    </p>\n\n    <h2>12. Тестирование доступности (Accessibility Testing)</h2>\n    <p>\n        Проверка того, насколько система доступна для людей с ограниченными возможностями.\n    </p>',8),(118,'Ожидаемые исключения в JUnit','<p>\n        В JUnit есть несколько способов проверки ожидаемых исключений. Два наиболее распространенных метода — это использование аннотации <code>@Test(expected = Exception.class)</code> и блока <code>try-catch</code>. Рассмотрим оба подхода.\n    </p>\n\n    <h2>1. Использование аннотации @Test(expected = Exception.class)</h2>\n    <p>\n        Аннотация <code>@Test(expected = Exception.class)</code> позволяет указать, что тест должен выбросить определенное исключение. Если исключение выбрасывается, тест считается успешным. Если исключение не выбрасывается, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testExpectedException() {\n        // Метод, который должен выбросить IllegalArgumentException\n        throw new IllegalArgumentException(\"Пример исключения\");\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testExpectedException</code> ожидает, что будет выброшено исключение <code>IllegalArgumentException</code>. Если исключение выбрасывается, тест проходит успешно.\n    </p>\n\n    <h2>2. Использование блока try-catch</h2>\n    <p>\n        Блок <code>try-catch</code> позволяет более гибко проверять исключения, включая проверку сообщения исключения или других его свойств.\n    </p>\n    <pre><code>\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n\n    @Test\n    public void testExpectedExceptionWithTryCatch() {\n        try {\n            // Метод, который должен выбросить IllegalArgumentException\n            throw new IllegalArgumentException(\"Пример исключения\");\n            // Если исключение не выбрасывается, тест завершается с ошибкой\n            fail(\"Ожидалось исключение IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // Проверка сообщения исключения\n            assertEquals(\"Пример исключения\", e.getMessage());\n        }\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Если исключение <code>IllegalArgumentException</code> не выбрасывается, вызывается метод <code>fail</code>, который завершает тест с ошибкой.</li>\n        <li>Если исключение выбрасывается, проверяется его сообщение с помощью <code>assertEquals</code>.</li>\n    </ul>\n\n    <h2>3. Использование JUnit 5 и assertThrows</h2>\n    <p>\n        В JUnit 5 появился более удобный способ проверки исключений с помощью метода <code>assertThrows</code>.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ExampleTest {\n\n    @Test\n    public void testExpectedExceptionWithAssertThrows() {\n        // Проверка, что исключение выбрасывается\n        IllegalArgumentException exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                // Метод, который должен выбросить IllegalArgumentException\n                throw new IllegalArgumentException(\"Пример исключения\");\n            }\n        );\n\n        // Проверка сообщения исключения\n        assertEquals(\"Пример исключения\", exception.getMessage());\n    }\n}\n    </code></pre>\n    <p>\n        Этот метод более лаконичен и позволяет сразу проверить как факт возникновения исключения, так и его свойства.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Выбор метода проверки исключений зависит от ваших требований:\n    </p>\n    <ul>\n        <li>Используйте <code>@Test(expected = Exception.class)</code>, если нужно просто проверить факт возникновения исключения.</li>\n        <li>Используйте блок <code>try-catch</code>, если требуется более гибкая проверка.</li>\n        <li>Используйте <code>assertThrows</code> в JUnit 5 для более удобного и читаемого кода.</li>\n    </ul>',8),(119,'Что такое ассерты (asserts)','<p>\n        <strong>Ассерты (asserts)</strong> — это методы, используемые в тестировании для проверки условий, которые должны быть выполнены в ходе выполнения теста. Если условие не выполняется, тест завершается с ошибкой, указывая на проблему в коде. Ассерты являются основным инструментом для проверки корректности работы программного обеспечения.\n    </p>\n\n    <h2>Методы класса Assert</h2>\n    <p>\n        В JUnit класс <code>Assert</code> предоставляет множество методов для проверки различных условий. Рассмотрим наиболее популярные из них.\n    </p>\n\n    <h3>1. assertEquals</h3>\n    <p>\n        Проверяет, что два значения равны. Если значения не совпадают, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testEquals() {\n        int expected = 5;\n        int actual = 5;\n        assertEquals(expected, actual);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что <code>expected</code> и <code>actual</code> равны.\n    </p>\n\n    <h3>2. assertNotNull</h3>\n    <p>\n        Проверяет, что объект не является <code>null</code>. Если объект <code>null</code>, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertNotNull;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testNotNull() {\n        Object obj = new Object();\n        assertNotNull(obj);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что объект <code>obj</code> не равен <code>null</code>.\n    </p>\n\n    <h3>3. assertTrue</h3>\n    <p>\n        Проверяет, что условие истинно. Если условие ложно, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testTrue() {\n        boolean condition = true;\n        assertTrue(condition);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что переменная <code>condition</code> равна <code>true</code>.\n    </p>\n\n    <h3>4. assertFalse</h3>\n    <p>\n        Проверяет, что условие ложно. Если условие истинно, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertFalse;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testFalse() {\n        boolean condition = false;\n        assertFalse(condition);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что переменная <code>condition</code> равна <code>false</code>.\n    </p>\n\n    <h3>5. assertNull</h3>\n    <p>\n        Проверяет, что объект равен <code>null</code>. Если объект не <code>null</code>, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertNull;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testNull() {\n        Object obj = null;\n        assertNull(obj);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что объект <code>obj</code> равен <code>null</code>.\n    </p>\n\n    <h3>6. assertSame</h3>\n    <p>\n        Проверяет, что две ссылки указывают на один и тот же объект. Если ссылки разные, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertSame;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testSame() {\n        Object obj1 = new Object();\n        Object obj2 = obj1;\n        assertSame(obj1, obj2);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что <code>obj1</code> и <code>obj2</code> ссылаются на один и тот же объект.\n    </p>\n\n    <h3>7. assertNotSame</h3>\n    <p>\n        Проверяет, что две ссылки указывают на разные объекты. Если ссылки одинаковые, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertNotSame;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testNotSame() {\n        Object obj1 = new Object();\n        Object obj2 = new Object();\n        assertNotSame(obj1, obj2);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что <code>obj1</code> и <code>obj2</code> ссылаются на разные объекты.\n    </p>\n\n    <h3>8. assertArrayEquals</h3>\n    <p>\n        Проверяет, что два массива равны. Если массивы отличаются, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class ExampleTest {\n\n    @Test\n    public void testArrayEquals() {\n        int[] expected = {1, 2, 3};\n        int[] actual = {1, 2, 3};\n        assertArrayEquals(expected, actual);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что массивы <code>expected</code> и <code>actual</code> равны.\n    </p>\n\n<h3>9. Метод assertAll</h2>\n    <p>\n        Метод <code>assertAll</code> позволяет группировать несколько проверок (assertions) в одном тесте. Если одна из проверок завершится с ошибкой, остальные проверки все равно будут выполнены, и все ошибки будут отображены.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AssertAllTest {\n\n    @Test\n    public void testMultipleAssertions() {\n        String firstName = \"John\";\n        String lastName = \"Doe\";\n\n        assertAll(\"Проверка имени и фамилии\",\n            () -> assertEquals(\"John\", firstName),\n            () -> assertEquals(\"Doe\", lastName),\n            () -> assertTrue(firstName.length() > 0),\n            () -> assertTrue(lastName.length() > 0)\n        );\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере все проверки внутри <code>assertAll</code> будут выполнены, даже если одна из них завершится с ошибкой.\n    </p>\n\n    <h3>10. Метод assertTimeout</h2>\n    <p>\n        Метод <code>assertTimeout</code> позволяет проверить, что выполнение кода завершается за указанное время. Если код выполняется дольше, тест завершается с ошибкой.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport java.time.Duration;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AssertTimeoutTest {\n\n    @Test\n    public void testTimeout() {\n        assertTimeout(Duration.ofMillis(100), () -> {\n            // Имитация долгого выполнения\n            Thread.sleep(50); // Тест пройдет\n            // Thread.sleep(150); // Тест завершится с ошибкой\n        });\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что выполнение кода завершается за 100 миллисекунд.\n    </p>\n\n    <h3>11. Метод assertThrows</h2>\n    <p>\n        Метод <code>assertThrows</code> позволяет проверить, что определенный блок кода выбрасывает ожидаемое исключение. Это полезно для тестирования обработки ошибок.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AssertThrowsTest {\n\n    @Test\n    public void testException() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            throw new IllegalArgumentException(\"Пример исключения\");\n        });\n\n        assertEquals(\"Пример исключения\", exception.getMessage());\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест проверяет, что блок кода выбрасывает исключение <code>IllegalArgumentException</code>, и проверяет его сообщение.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Ассерты — это мощный инструмент для проверки корректности работы программного обеспечения. Класс <code>Assert</code> в JUnit предоставляет множество методов для различных проверок, таких как сравнение значений, проверка на <code>null</code>, проверка условий и многое другое. Использование ассертов помогает сделать тесты более надежными и читаемыми.\n    </p>',8),(120,'Аннотации @BeforeEach, @AfterEach','<p>\n        В JUnit 5 аннотации <code>@BeforeEach</code> и <code>@AfterEach</code> используются для выполнения кода до и после каждого теста соответственно. Эти аннотации помогают настроить начальное состояние тестового окружения и очистить ресурсы после завершения теста.\n    </p>\n\n    <h2>Аннотация @BeforeEach</h2>\n    <p>\n        Метод, помеченный аннотацией <code>@BeforeEach</code>, выполняется перед каждым тестом. Это полезно для инициализации объектов, настройки данных или подготовки окружения, которые необходимы для выполнения тестов.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ExampleTest {\n\n    private int value;\n\n    @BeforeEach\n    public void setUp() {\n        // Инициализация переменной перед каждым тестом\n        value = 10;\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(10, value);\n    }\n\n    @Test\n    public void testValueIncremented() {\n        value += 5;\n        assertEquals(15, value);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>setUp()</code>, помеченный аннотацией <code>@BeforeEach</code>, инициализирует переменную <code>value</code> перед каждым тестом. Это гарантирует, что каждый тест начинается с одного и того же начального состояния.\n    </p>\n\n    <h2>Аннотация @AfterEach</h2>\n    <p>\n        Метод, помеченный аннотацией <code>@AfterEach</code>, выполняется после каждого теста. Это полезно для освобождения ресурсов, сброса состояния или выполнения других действий по очистке.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ExampleTest {\n\n    private int value;\n\n    @BeforeEach\n    public void setUp() {\n        // Инициализация переменной перед каждым тестом\n        value = 10;\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Очистка после каждого теста\n        value = 0;\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(10, value);\n    }\n\n    @Test\n    public void testValueIncremented() {\n        value += 5;\n        assertEquals(15, value);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>tearDown()</code>, помеченный аннотацией <code>@AfterEach</code>, сбрасывает значение переменной <code>value</code> после каждого теста. Это гарантирует, что состояние не переносится между тестами.\n    </p>\n\n    <h2>Пример использования @BeforeEach и @AfterEach</h2>\n    <p>\n        Рассмотрим пример, где аннотации <code>@BeforeEach</code> и <code>@AfterEach</code> используются для работы с базой данных.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DatabaseTest {\n\n    private DatabaseConnection connection;\n\n    @BeforeEach\n    public void setUp() {\n        // Установка соединения с базой данных перед каждым тестом\n        connection = new DatabaseConnection();\n        connection.connect();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Закрытие соединения с базой данных после каждого теста\n        connection.disconnect();\n    }\n\n    @Test\n    public void testDatabaseQuery() {\n        String result = connection.query(\"SELECT * FROM users\");\n        assertNotNull(result);\n    }\n\n    @Test\n    public void testDatabaseUpdate() {\n        boolean success = connection.update(\"UPDATE users SET name = \'John\' WHERE id = 1\");\n        assertTrue(success);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Метод <code>setUp()</code> устанавливает соединение с базой данных перед каждым тестом.</li>\n        <li>Метод <code>tearDown()</code> закрывает соединение с базой данных после каждого теста.</li>\n        <li>Тесты <code>testDatabaseQuery</code> и <code>testDatabaseUpdate</code> используют это соединение для выполнения запросов.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации <code>@BeforeEach</code> и <code>@AfterEach</code> в JUnit 5 позволяют настроить начальное состояние и выполнить очистку после каждого теста. Это делает тесты более изолированными и независимыми, что повышает их надежность и читаемость.\n    </p>\n',8),(121,'Параметризованные тесты в JUnit','<p>\n        Параметризованные тесты позволяют запускать один и тот же тест с разными наборами входных данных. Это особенно полезно, когда нужно проверить множество сценариев с различными параметрами. В JUnit 4 для создания параметризованных тестов используется класс <code>Parameterized</code>.\n    </p>\n\n    <h2>Реализация параметризованных тестов с использованием класса Parameterized</h2>\n    <p>\n        Для создания параметризованного теста в JUnit 4 необходимо выполнить следующие шаги:\n    </p>\n    <ol>\n        <li>Добавить аннотацию <code>@RunWith(Parameterized.class)</code> к классу теста.</li>\n        <li>Создать метод, помеченный аннотацией <code>@Parameters</code>, который возвращает коллекцию данных для теста.</li>\n        <li>Создать конструктор, который принимает параметры теста.</li>\n        <li>Написать тестовый метод, использующий параметры.</li>\n    </ol>\n\n    <h3>Пример параметризованного теста</h3>\n    <p>\n        Рассмотрим пример параметризованного теста для проверки функции сложения двух чисел.\n    </p>\n    <pre><code>\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\n\n@RunWith(Parameterized.class)\npublic class AdditionTest {\n\n    private int a;\n    private int b;\n    private int expectedSum;\n\n    // Конструктор, принимающий параметры теста\n    public AdditionTest(int a, int b, int expectedSum) {\n        this.a = a;\n        this.b = b;\n        this.expectedSum = expectedSum;\n    }\n\n    // Метод, возвращающий набор данных для теста\n    @Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][]{\n            {1, 2, 3},\n            {5, 5, 10},\n            {10, -5, 5},\n            {0, 0, 0}\n        });\n    }\n\n    // Тестовый метод\n    @Test\n    public void testAddition() {\n        assertEquals(expectedSum, a + b);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Класс теста помечен аннотацией <code>@RunWith(Parameterized.class)</code>, чтобы указать, что это параметризованный тест.</li>\n        <li>Метод <code>data()</code>, помеченный аннотацией <code>@Parameters</code>, возвращает набор данных в виде коллекции массивов объектов. Каждый массив содержит входные параметры для одного теста.</li>\n        <li>Конструктор класса принимает параметры и инициализирует поля <code>a</code>, <code>b</code> и <code>expectedSum</code>.</li>\n        <li>Тестовый метод <code>testAddition()</code> проверяет, что сумма <code>a</code> и <code>b</code> равна <code>expectedSum</code>.</li>\n    </ul>\n\n    <h3>Результат выполнения</h3>\n    <p>\n        При запуске этого теста JUnit выполнит метод <code>testAddition()</code> для каждого набора данных, переданного в метод <code>data()</code>. В данном случае тест будет выполнен 4 раза с разными значениями:\n    </p>\n    <ul>\n        <li>1 + 2 = 3</li>\n        <li>5 + 5 = 10</li>\n        <li>10 + (-5) = 5</li>\n        <li>0 + 0 = 0</li>\n    </ul>\n\n    <h2>Параметризованные тесты в JUnit 5</h2>\n    <p>\n        В JUnit 5 параметризованные тесты реализуются с использованием аннотации <code>@ParameterizedTest</code> и различных источников данных, таких как <code>@ValueSource</code>, <code>@CsvSource</code>, <code>@MethodSource</code> и других.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AdditionTestJUnit5 {\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 2, 3\",\n        \"5, 5, 10\",\n        \"10, -5, 5\",\n        \"0, 0, 0\"\n    })\n    public void testAddition(int a, int b, int expectedSum) {\n        assertEquals(expectedSum, a + b);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Аннотация <code>@ParameterizedTest</code> указывает, что это параметризованный тест.</li>\n        <li>Аннотация <code>@CsvSource</code> предоставляет данные в формате CSV.</li>\n        <li>Тестовый метод <code>testAddition()</code> принимает параметры и проверяет результат.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Параметризованные тесты в JUnit позволяют легко тестировать код с различными наборами входных данных. В JUnit 4 для этого используется класс <code>Parameterized</code>, а в JUnit 5 — аннотация <code>@ParameterizedTest</code> с различными источниками данных. Это делает тесты более гибкими и удобными для проверки множества сценариев.\n    </p>',8),(122,'Как организовать тесты в проекте?','<p>\n        Правильная организация тестового кода в проекте помогает поддерживать порядок, упрощает навигацию и делает тесты более читаемыми и поддерживаемыми. В этом документе рассмотрим лучшие практики и структуру директорий для организации тестов.\n    </p>\n\n    <h2>Структура директорий для тестов</h2>\n    <p>\n        Один из самых распространенных подходов — это зеркальная структура директорий для тестового кода. Это означает, что тестовые классы располагаются в директориях, которые повторяют структуру основного кода.\n    </p>\n\n    <h3>Пример структуры проекта</h3>\n    <pre>\nsrc/\n├── main/\n│   ├── java/\n│   │   ├── com/\n│   │   │   └── example/\n│   │   │       ├── service/\n│   │   │       │   └── UserService.java\n│   │   │       └── controller/\n│   │   │           └── UserController.java\n│   └── resources/\n│       └── application.properties\n└── test/\n    ├── java/\n    │   ├── com/\n    │   │   └── example/\n    │   │       ├── service/\n    │   │       │   └── UserServiceTest.java\n    │   │       └── controller/\n    │   │           └── UserControllerTest.java\n    └── resources/\n        └── test-application.properties\n    </pre>\n    <p>\n        В этом примере:\n    </p>\n    <ul>\n        <li>Основной код находится в директории <code>src/main/java</code>.</li>\n        <li>Тестовый код находится в директории <code>src/test/java</code>.</li>\n        <li>Структура пакетов в тестовой директории повторяет структуру пакетов основного кода.</li>\n        <li>Ресурсы для тестов (например, конфигурационные файлы) располагаются в <code>src/test/resources</code>.</li>\n    </ul>\n\n    <h2>Лучшие практики по организации тестового кода</h2>\n    <p>\n        Вот несколько рекомендаций, которые помогут организовать тестовый код эффективно:\n    </p>\n\n    <h3>1. Используйте понятные имена для тестовых классов и методов</h3>\n    <p>\n        Имена тестовых классов и методов должны быть описательными и отражать, что именно они тестируют. Например:\n    </p>\n    <ul>\n        <li>Тестовый класс: <code>UserServiceTest</code>.</li>\n        <li>Тестовый метод: <code>testCreateUserWithValidData()</code>.</li>\n    </ul>\n\n    <h3>2. Разделяйте тесты на категории</h3>\n    <p>\n        Тесты можно разделить на категории, такие как:\n    </p>\n    <ul>\n        <li><strong>Модульные тесты (Unit Tests):</strong> Тестируют отдельные классы или методы.</li>\n        <li><strong>Интеграционные тесты (Integration Tests):</strong> Тестируют взаимодействие между несколькими компонентами.</li>\n        <li><strong>Функциональные тесты (Functional Tests):</strong> Тестируют функциональность системы в целом.</li>\n    </ul>\n    <p>\n        Для разделения можно использовать разные директории или пакеты, например:\n    </p>\n    <pre>\nsrc/test/java/\n├── com/\n│   └── example/\n│       ├── unit/\n│       │   └── UserServiceTest.java\n│       ├── integration/\n│       │   └── UserControllerIntegrationTest.java\n│       └── functional/\n│           └── UserFunctionalTest.java\n    </pre>\n\n    <h3>3. Используйте аннотации для настройки и очистки</h3>\n    <p>\n        Используйте аннотации <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@BeforeAll</code> и <code>@AfterAll</code> для настройки и очистки тестового окружения.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class UserServiceTest {\n\n    private UserService userService;\n\n    @BeforeEach\n    public void setUp() {\n        userService = new UserService();\n    }\n\n    @Test\n    public void testCreateUser() {\n        // Тестирование создания пользователя\n    }\n}\n    </code></pre>\n\n    <h3>4. Используйте параметризованные тесты</h3>\n    <p>\n        Для тестирования с разными наборами данных используйте параметризованные тесты. Это уменьшает дублирование кода и делает тесты более гибкими.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class UserServiceTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"user1\", \"user2\", \"user3\"})\n    public void testUsernameValidation(String username) {\n        assertTrue(UserService.isValidUsername(username));\n    }\n}\n    </code></pre>\n\n    <h3>5. Используйте отдельные ресурсы для тестов</h3>\n    <p>\n        Если тестам требуются конфигурационные файлы или другие ресурсы, размещайте их в <code>src/test/resources</code>. Это позволяет изолировать тестовые данные от основного кода.\n    </p>\n\n    <h3>6. Документируйте тесты</h3>\n    <p>\n        Добавляйте комментарии к тестам, чтобы объяснить, что именно они проверяют. Это особенно полезно для сложных тестов или интеграционных тестов.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Организация тестового кода — это важный аспект разработки программного обеспечения. Следуя лучшим практикам, таким как зеркальная структура директорий, использование понятных имен, разделение тестов на категории и использование аннотаций, вы сможете сделать тесты более читаемыми, поддерживаемыми и эффективными.\n    </p>\n',8),(123,'Анотации @Disabled,@Nested,@ExtendWith,@Timeout','<p>\n        JUnit 5 предоставляет множество аннотаций, которые упрощают написание и организацию тестов. В этом документе рассмотрим аннотации <code>@Disabled</code>, <code>@Nested</code>, <code>@ExtendWith</code> и <code>@Timeout</code>, их назначение и примеры использования.\n    </p>\n\n    <h2>1. Аннотация @Disabled</h2>\n    <p>\n        Аннотация <code>@Disabled</code> используется для отключения тестов или тестовых классов. Это полезно, если тест временно не должен выполняться (например, из-за незавершенной функциональности или известной ошибки).\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class DisabledTest {\n\n    @Disabled(\"Этот тест отключен до исправления бага #123\")\n    @Test\n    public void testDisabled() {\n        assertEquals(2, 1 + 1);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testDisabled</code> не будет выполнен, так как он помечен аннотацией <code>@Disabled</code>.\n    </p>\n\n    <h2>2. Аннотация @Nested</h2>\n    <p>\n        Аннотация <code>@Nested</code> позволяет создавать вложенные тестовые классы. Это полезно для группировки тестов, которые проверяют связанную функциональность.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NestedTest {\n\n    @Nested\n    class UserTests {\n        @Test\n        public void testCreateUser() {\n            assertTrue(true);\n        }\n\n        @Test\n        public void testDeleteUser() {\n            assertFalse(false);\n        }\n    }\n\n    @Nested\n    class ProductTests {\n        @Test\n        public void testCreateProduct() {\n            assertEquals(1, 1);\n        }\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тесты сгруппированы по функциональности: <code>UserTests</code> и <code>ProductTests</code>. Это улучшает читаемость и организацию тестов.\n    </p>\n\n    <h2>3. Аннотация @ExtendWith</h2>\n    <p>\n        Аннотация <code>@ExtendWith</code> используется для подключения расширений (extensions) в JUnit 5. Расширения позволяют добавлять дополнительную функциональность, такую как управление жизненным циклом тестов, обработка исключений или интеграция с другими библиотеками.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n// Пример пользовательского расширения\nclass CustomExtension implements org.junit.jupiter.api.extension.Extension {\n    // Логика расширения\n}\n\n@ExtendWith(CustomExtension.class)\npublic class ExtendWithTest {\n\n    @Test\n    public void testWithCustomExtension() {\n        assertEquals(2, 1 + 1);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере к тестовому классу подключено пользовательское расширение <code>CustomExtension</code>.\n    </p>\n\n    <h2>4. Аннотация @Timeout</h2>\n    <p>\n        Аннотация <code>@Timeout</code> позволяет установить максимальное время выполнения теста. Если тест выполняется дольше указанного времени, он завершается с ошибкой.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport java.util.concurrent.TimeUnit;\n\npublic class TimeoutTest {\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testTimeout() throws InterruptedException {\n        // Имитация долгого выполнения\n        Thread.sleep(400); // Тест пройдет\n        // Thread.sleep(600); // Тест завершится с ошибкой\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testTimeout</code> должен завершиться за 500 миллисекунд. Если выполнение занимает больше времени, тест завершится с ошибкой.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации <code>@Disabled</code>, <code>@Nested</code>, <code>@ExtendWith</code> и <code>@Timeout</code> предоставляют мощные инструменты для управления тестами в JUnit 5. Они помогают отключать тесты, группировать их, добавлять дополнительную функциональность и контролировать время выполнения. Использование этих аннотаций делает тесты более гибкими и удобными для поддержки.\n    </p>',8),(124,'Тестирование асинхронного кода','<p>\n        Тестирование асинхронного кода требует особого подхода, так как результаты операций могут быть доступны не сразу, а через некоторое время. В этом документе рассмотрим основные подходы и инструменты для тестирования асинхронного поведения.\n    </p>\n\n    <h2>1. Использование CompletableFuture и Future</h2>\n    <p>\n        Если асинхронный код возвращает <code>CompletableFuture</code> или <code>Future</code>, можно использовать методы <code>get()</code> или <code>join()</code> для получения результата. Однако это может привести к блокировке потока, поэтому важно учитывать время ожидания.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CompletableFutureTest {\n\n    @Test\n    public void testCompletableFuture() throws ExecutionException, InterruptedException {\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \"Hello, World!\");\n        String result = future.get(); // Блокирующий вызов\n        assertEquals(\"Hello, World!\", result);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>get()</code> блокирует выполнение до завершения <code>CompletableFuture</code>.\n    </p>\n\n    <h2>2. Использование CountDownLatch</h2>\n    <p>\n        <code>CountDownLatch</code> позволяет дождаться завершения асинхронной операции. Это полезно, если асинхронный код не возвращает <code>Future</code>.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class CountDownLatchTest {\n\n    @Test\n    public void testAsyncOperation() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(1);\n        boolean[] result = {false};\n\n        new Thread(() -> {\n            // Имитация асинхронной операции\n            try {\n                Thread.sleep(500);\n                result[0] = true;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                latch.countDown();\n            }\n        }).start();\n\n        latch.await(1, TimeUnit.SECONDS); // Ожидание завершения\n        assertTrue(result[0]);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере <code>CountDownLatch</code> используется для ожидания завершения асинхронной операции.\n    </p>\n\n    <h2>3. Использование библиотеки Awaitility</h2>\n    <p>\n        <a href=\"https://github.com/awaitility/awaitility\">Awaitility</a> — это библиотека, которая упрощает тестирование асинхронного кода, позволяя дождаться выполнения условий.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport static org.awaitility.Awaitility.await;\nimport static org.awaitility.Durations.ONE_SECOND;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class AwaitilityTest {\n\n    @Test\n    public void testAsyncOperation() {\n        boolean[] result = {false};\n\n        new Thread(() -> {\n            // Имитация асинхронной операции\n            try {\n                Thread.sleep(500);\n                result[0] = true;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        await().atMost(ONE_SECOND).until(() -> result[0]);\n        assertTrue(result[0]);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере Awaitility используется для ожидания изменения значения <code>result[0]</code>.\n    </p>\n\n    <h2>4. Использование реактивных библиотек (Reactive Streams)</h2>\n    <p>\n        Если асинхронный код использует реактивные библиотеки, такие как <code>Reactor</code> или <code>RxJava</code>, можно использовать их встроенные инструменты для тестирования.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport reactor.core.publisher.Mono;\nimport reactor.test.StepVerifier;\n\npublic class ReactorTest {\n\n    @Test\n    public void testMono() {\n        Mono<String> mono = Mono.just(\"Hello, World!\");\n\n        StepVerifier.create(mono)\n            .expectNext(\"Hello, World!\")\n            .verifyComplete();\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере <code>StepVerifier</code> используется для проверки реактивного потока.\n    </p>\n\n    <h2>5. Использование аннотации @Timeout в JUnit 5</h2>\n    <p>\n        В JUnit 5 можно использовать аннотацию <code>@Timeout</code> для ограничения времени выполнения теста. Это полезно для асинхронных тестов, которые могут зависнуть.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport java.util.concurrent.TimeUnit;\n\npublic class TimeoutTest {\n\n    @Test\n    @Timeout(value = 1, unit = TimeUnit.SECONDS)\n    public void testAsyncOperation() throws InterruptedException {\n        Thread.sleep(500); // Тест пройдет\n        // Thread.sleep(2000); // Тест завершится с ошибкой\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест должен завершиться за 1 секунду.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Тестирование асинхронного кода требует использования специальных подходов и инструментов. В зависимости от ситуации можно использовать <code>CompletableFuture</code>, <code>CountDownLatch</code>, библиотеку Awaitility, реактивные библиотеки или аннотацию <code>@Timeout</code>. Эти методы помогают эффективно тестировать асинхронное поведение и избегать блокировок или зависаний.\n    </p>',8),(125,'Test-Driven Development','<p>\n        <strong>TDD (Test-Driven Development)</strong> — это методология разработки программного обеспечения, при которой тесты пишутся до реализации кода. Основная идея TDD заключается в том, что разработчик сначала пишет тест для новой функциональности, а затем реализует код, который делает этот тест успешным. Этот процесс повторяется для каждой новой функции или улучшения.\n    </p>\n\n    <h2>Основные этапы TDD</h2>\n    <p>\n        TDD состоит из трех основных этапов, которые часто называют \"красный-зеленый-рефакторинг\":\n    </p>\n    <ol>\n        <li><strong>Красный:</strong> Написание теста, который проверяет новую функциональность. На этом этапе тест должен завершиться с ошибкой, так как код еще не реализован.</li>\n        <li><strong>Зеленый:</strong> Реализация кода, который делает тест успешным. На этом этапе важно написать минимально необходимый код для прохождения теста.</li>\n        <li><strong>Рефакторинг:</strong> Улучшение кода без изменения его функциональности. Это включает удаление дублирования, улучшение читаемости и оптимизацию.</li>\n    </ol>\n\n    <h2>Пример использования TDD</h2>\n    <p>\n        Рассмотрим пример разработки простого калькулятора с использованием TDD.\n    </p>\n\n    <h3>1. Красный: Написание теста</h3>\n    <p>\n        Начнем с написания теста для функции сложения двух чисел.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculatorTest {\n\n    @Test\n    public void testAdd() {\n        Calculator calculator = new Calculator();\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n}\n    </code></pre>\n    <p>\n        На этом этапе тест завершится с ошибкой, так как класс <code>Calculator</code> и метод <code>add</code> еще не реализованы.\n    </p>\n\n    <h3>2. Зеленый: Реализация кода</h3>\n    <p>\n        Теперь реализуем минимальный код, чтобы тест прошел.\n    </p>\n    <pre><code>\npublic class Calculator {\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n    </code></pre>\n    <p>\n        После реализации кода тест должен завершиться успешно.\n    </p>\n\n    <h3>3. Рефакторинг: Улучшение кода</h3>\n    <p>\n        На этом этапе можно улучшить код, например, добавить проверку на переполнение или улучшить читаемость. В данном случае код уже достаточно прост, поэтому рефакторинг не требуется.\n    </p>\n\n    <h2>Преимущества TDD</h2>\n    <p>\n        Использование TDD имеет несколько преимуществ:\n    </p>\n    <ul>\n        <li><strong>Качество кода:</strong> TDD помогает выявить ошибки на ранних этапах разработки.</li>\n        <li><strong>Документация:</strong> Тесты служат живой документацией, которая показывает, как должен работать код.</li>\n        <li><strong>Уверенность в изменениях:</strong> Наличие тестов позволяет вносить изменения в код, не боясь сломать существующую функциональность.</li>\n        <li><strong>Проектирование:</strong> TDD заставляет разработчика думать о дизайне кода до его реализации.</li>\n    </ul>\n\n    <h2>Недостатки TDD</h2>\n    <p>\n        Несмотря на преимущества, TDD имеет и некоторые недостатки:\n    </p>\n    <ul>\n        <li><strong>Время:</strong> Написание тестов до реализации кода может замедлить процесс разработки.</li>\n        <li><strong>Кривая обучения:</strong> TDD требует определенного опыта и дисциплины.</li>\n        <li><strong>Сложность для некоторых задач:</strong> Не все задачи легко тестировать с помощью TDD, особенно если они связаны с пользовательским интерфейсом или сторонними API.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        TDD — это мощная методология, которая помогает создавать качественный и поддерживаемый код. Она требует дисциплины и практики, но при правильном использовании может значительно улучшить процесс разработки. Начните с небольших проектов, чтобы освоить TDD, и постепенно применяйте его в более сложных задачах.\n    </p>',8),(126,'Анотации @ValueSource,@EnumSource,@MethodSource,@NullSource,@CSVSource',' <p>\n        JUnit 5 предоставляет множество аннотаций для работы с параметризованными тестами. Эти аннотации позволяют легко передавать различные наборы данных в тестовые методы. В этом документе рассмотрим аннотации <code>@ValueSource</code>, <code>@EnumSource</code>, <code>@MethodSource</code>, <code>@NullSource</code> и <code>@CsvSource</code>.\n    </p>\n\n    <h2>1. Аннотация @ValueSource</h2>\n    <p>\n        Аннотация <code>@ValueSource</code> позволяет передавать в тестовый метод массив значений. Это полезно для тестирования с простыми типами данных, такими как строки, числа или символы.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ValueSourceTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"hello\", \"world\", \"junit\"})\n    public void testStrings(String input) {\n        assertTrue(input.length() > 0);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1, 2, 3})\n    public void testNumbers(int number) {\n        assertTrue(number > 0);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testStrings</code> выполняется три раза с разными строками, а тест <code>testNumbers</code> — три раза с разными числами.\n    </p>\n\n    <h2>2. Аннотация @EnumSource</h2>\n    <p>\n        Аннотация <code>@EnumSource</code> позволяет передавать в тестовый метод значения перечисления (enum). Это полезно для тестирования всех возможных значений enum.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class EnumSourceTest {\n\n    enum Day {\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n    }\n\n    @ParameterizedTest\n    @EnumSource(Day.class)\n    public void testDays(Day day) {\n        assertNotNull(day);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testDays</code> выполняется для каждого значения перечисления <code>Day</code>.\n    </p>\n\n    <h2>3. Аннотация @MethodSource</h2>\n    <p>\n        Аннотация <code>@MethodSource</code> позволяет передавать в тестовый метод данные из статического метода. Это полезно для сложных наборов данных.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport java.util.stream.Stream;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MethodSourceTest {\n\n    @ParameterizedTest\n    @MethodSource(\"stringProvider\")\n    public void testStrings(String input) {\n        assertTrue(input.length() > 0);\n    }\n\n    static Stream<String> stringProvider() {\n        return Stream.of(\"hello\", \"world\", \"junit\");\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере метод <code>stringProvider</code> возвращает поток строк, которые передаются в тестовый метод <code>testStrings</code>.\n    </p>\n\n    <h2>4. Аннотация @NullSource</h2>\n    <p>\n        Аннотация <code>@NullSource</code> позволяет передавать в тестовый метод значение <code>null</code>. Это полезно для проверки обработки нулевых значений.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.NullSource;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class NullSourceTest {\n\n    @ParameterizedTest\n    @NullSource\n    public void testNull(String input) {\n        assertNull(input);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testNull</code> проверяет, что входное значение равно <code>null</code>.\n    </p>\n\n    <h2>5. Аннотация @CsvSource</h2>\n    <p>\n        Аннотация <code>@CsvSource</code> позволяет передавать в тестовый метод данные в формате CSV. Это полезно для тестирования с несколькими параметрами.\n    </p>\n    <pre><code>\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CsvSourceTest {\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 2, 3\",\n        \"4, 5, 9\",\n        \"10, -5, 5\"\n    })\n    public void testAddition(int a, int b, int expectedSum) {\n        assertEquals(expectedSum, a + b);\n    }\n}\n    </code></pre>\n    <p>\n        В этом примере тест <code>testAddition</code> выполняется три раза с разными наборами данных, переданными в формате CSV.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации <code>@ValueSource</code>, <code>@EnumSource</code>, <code>@MethodSource</code>, <code>@NullSource</code> и <code>@CsvSource</code> предоставляют мощные инструменты для создания параметризованных тестов в JUnit 5. Они позволяют легко передавать различные наборы данных в тестовые методы, что делает тесты более гибкими и удобными для проверки множества сценариев.\n    </p>',8),(127,'Аннотация @Suite,@Order,@DisplayName','<h2>1. Аннотация @Suite</h2>\n    <p>\n        Аннотация <code>@Suite</code> используется для группировки тестов в один набор. Это позволяет запускать несколько классов тестов вместе, что удобно для организации и управления тестами.\n    </p>\n    <h3>Пример использования:</h3>\n    <pre>\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n    TestClass1.class,\n    TestClass2.class\n})\npublic class AllTestsSuite {\n}\n    </pre>\n    \n    <h2>2. Аннотация @Order</h2>\n    <p>\n        Аннотация <code>@Order</code> используется для определения порядка выполнения тестов в рамках класса. Это особенно полезно, если тесты зависят друг от друга. \n    </p>\n    <h3>Пример использования:</h3>\n    <pre>\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\n\npublic class ExampleTests {\n\n    @Test\n    @Order(1)\n    void firstTest() {\n        // ...\n    }\n\n    @Test\n    @Order(2)\n    void secondTest() {\n        // ...\n    }\n}\n    </pre>\n\n    <h2>3. Аннотация @DisplayName</h2>\n    <p>\n        Аннотация <code>@DisplayName</code> используется для задания пользовательских имен тестов, которые будут отображаться в отчетах. Это делает вывод тестов более читаемым и понятным.\n    </p>\n    <h3>Пример использования:</h3>\n    <pre>\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\npublic class DisplayNameExampleTests {\n\n    @Test\n    @DisplayName(\"Тест 1: Проверка функциональности A\")\n    void testFunctionalityA() {\n        // ...\n    }\n\n    @Test\n    @DisplayName(\"Тест 2: Проверка функциональности B\")\n    void testFunctionalityB() {\n        // ...\n    }\n}\n    </pre>',8),(128,'Что такое аннотация','<p>\n        Аннотации - это специальный механизм в языке программирования Java, который позволяет добавлять метаданные к элементам программы, таким как классы, методы, поля и параметры. Аннотации не влияют на выполнение программы, но используются для предоставления информации, которую можно использовать в процессе выполнения или компиляции кода.\n    </p>\n\n    <h2>Основные характеристики аннотаций</h2>\n    <ul>\n        <li>\n            <strong>Метаданные:</strong> Аннотации представляют собой данные о данных. Они могут быть использованы для документирования кода, указывая, как он должен работать или как его использовать.\n        </li>\n        <li>\n            <strong>Не влияют на выполнение:</strong> Аннотации не изменяют поведение программы напрямую. Они используются для передачи информации другим инструментам или библиотекам.\n        </li>\n        <li>\n            <strong>Использование в рефлексии:</strong> Аннотации могут быть извлечены во время выполнения программы с использованием рефлексии, что позволяет динамически реагировать на их наличие и содержание.\n        </li>\n        <li>\n            <strong>Поддержка различных инструментов:</strong> Аннотации широко используются в различных фреймворках и библиотеках (например, Spring, JUnit), чтобы упростить конфигурацию и управление поведением компонентов.\n        </li>\n    </ul>\n\n    <h2>Создание аннотаций</h2>\n    <p>\n        Для создания собственной аннотации в Java необходимо использовать ключевое слово <code>@interface</code>. Аннотация может содержать методы, которые представляют элементы, которые могут быть указаны в аннотации.\n    </p>\n    <h3>Пример создания аннотации:</h3>\n    <pre>\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface CustomAnnotation {\n    String value();\n    int number() default 0;\n}\n    </pre>\n\n    <h2>Типы аннотаций</h2>\n    <p>\n        В Java существует несколько типов аннотаций, включая:\n    </p>\n    <ul>\n        <li>\n            <strong>@Retention:</strong> Определяет, как долго аннотация должна сохраняться (например, SOURCE, CLASS, RUNTIME).\n        </li>\n        <li>\n            <strong>@Target:</strong> Указывает, к каким элементам программы может быть применена аннотация (например, TYPE, METHOD, FIELD).\n        </li>\n        <li>\n            <strong>@Inherited:</strong> Указывает, что аннотация может быть унаследована подклассами.\n        </li>\n        <li>\n            <strong>@Documented:</strong> Указывает, что аннотация должна быть включена в Javadoc.\n        </li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Аннотации в Java предоставляют мощный механизм для добавления метаданных к коду, что упрощает работу с программами, фреймворками и инструментами. Их использование позволяет улучшить читаемость, управляемость и поддержку кода.\n    </p>',6),(129,'Ограничения JUnit в многопоточных приложениях',' <p>JUnit — это популярный фреймворк для модульного тестирования Java-приложений. Однако при работе с многопоточными приложениями он имеет ряд ограничений и сложностей, которые важно учитывать.</p>\n\n    <h2>Основные ограничения JUnit в многопоточных приложениях</h2>\n    <ul>\n        <li><strong>Отсутствие встроенной поддержки многопоточности:</strong> JUnit изначально не предназначен для тестирования многопоточного кода. Он выполняет тесты последовательно, что затрудняет проверку корректности работы потоков.</li>\n        <li><strong>Проблемы с синхронизацией:</strong> Если тест запускает несколько потоков, JUnit не гарантирует их корректное завершение. Это может привести к тому, что тест завершится до завершения работы всех потоков, что вызовет ложные срабатывания или ошибки.</li>\n        <li><strong>Сложность отладки:</strong> Ошибки в многопоточных тестах часто трудно воспроизвести из-за недетерминированного поведения потоков. Это усложняет процесс отладки и анализа.</li>\n        <li><strong>Ограничения на использование <code>assert</code>:</strong> В многопоточных тестах стандартные методы <code>assert</code> могут не сработать, так как они не учитывают состояние потоков. Например, если поток изменяет данные после выполнения <code>assert</code>, результат теста может быть некорректным.</li>\n    </ul>\n\n    <h2>Возможные сложности</h2>\n    <ul>\n        <li><strong>Гонки данных (Race Conditions):</strong> В многопоточных приложениях часто возникают гонки данных, которые сложно выявить с помощью стандартных средств JUnit.</li>\n        <li><strong>Тупики (Deadlocks):</strong> Тестирование на предмет возникновения тупиков требует дополнительных инструментов, так как JUnit не предоставляет встроенных механизмов для их обнаружения.</li>\n        <li><strong>Нестабильность тестов:</strong> Многопоточные тесты могут быть нестабильными из-за зависимости от времени выполнения потоков. Это может привести к ложным срабатываниям или пропуску ошибок.</li>\n    </ul>\n\n    <h2>Рекомендации по тестированию многопоточных приложений</h2>\n    <p>Для преодоления ограничений JUnit можно использовать следующие подходы:</p>\n    <ul>\n        <li><strong>Использование специализированных библиотек:</strong> Например, библиотеки <code>ConcurrentUnit</code> или <code>Awaitility</code> помогают тестировать многопоточный код, предоставляя инструменты для синхронизации и проверки состояния потоков.</li>\n        <li><strong>Ручное управление потоками:</strong> В тестах можно явно создавать и завершать потоки, а также использовать методы <code>join()</code> для ожидания их завершения.</li>\n        <li><strong>Использование моков и заглушек:</strong> Для изоляции многопоточного кода можно использовать моки (например, с помощью библиотеки Mockito) и заглушки, чтобы упростить тестирование.</li>\n        <li><strong>Тестирование на уровне интеграции:</strong> В некоторых случаях многопоточный код проще тестировать на уровне интеграционных тестов, где можно использовать более сложные инструменты для управления потоками.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>JUnit — мощный инструмент для модульного тестирования, но он имеет ограничения при работе с многопоточными приложениями. Для эффективного тестирования таких приложений важно использовать дополнительные библиотеки и подходы, которые помогут справиться с проблемами синхронизации, гонками данных и нестабильностью тестов.</p>',8),(130,'Интеграция JUnit с CI/CD инструментами','<p>JUnit — это популярный фреймворк для модульного тестирования Java-приложений. Его интеграция с инструментами непрерывной интеграции и доставки (CI/CD) позволяет автоматизировать процесс тестирования и обеспечивать высокое качество кода. Рассмотрим, как это можно сделать.</p>\n\n    <h2>Основные этапы интеграции JUnit с CI/CD</h2>\n    <p>Интеграция JUnit с CI/CD включает следующие шаги:</p>\n    <ol>\n        <li><strong>Настройка проекта:</strong> Убедитесь, что ваш проект использует систему сборки, например Maven или Gradle, которая поддерживает запуск тестов JUnit.</li>\n        <li><strong>Добавление тестов:</strong> Напишите тесты с использованием JUnit и разместите их в соответствующем каталоге (например, <code>src/test/java</code>).</li>\n        <li><strong>Настройка CI/CD инструмента:</strong> Выберите CI/CD инструмент (например, Jenkins, GitLab CI, GitHub Actions, CircleCI) и настройте его для автоматического запуска тестов при каждом изменении кода.</li>\n        <li><strong>Запуск тестов:</strong> Настройте CI/CD пайплайн так, чтобы он выполнял команду для запуска тестов (например, <code>mvn test</code> или <code>gradle test</code>).</li>\n        <li><strong>Анализ результатов:</strong> Настройте CI/CD инструмент для анализа результатов тестов и уведомления команды в случае ошибок.</li>\n    </ol>\n\n    <h2>Пример интеграции с популярными CI/CD инструментами</h2>\n\n    <h3>1. Jenkins</h3>\n    <p>Jenkins — один из самых популярных инструментов для CI/CD. Для интеграции JUnit с Jenkins выполните следующие шаги:</p>\n    <ul>\n        <li>Установите Jenkins и настройте проект.</li>\n        <li>Добавьте шаг сборки, который запускает тесты. Например, для Maven используйте команду <code>mvn test</code>.</li>\n        <li>Настройте Jenkins для сбора и отображения результатов тестов в формате JUnit XML (обычно находится в <code>target/surefire-reports</code>).</li>\n        <li>Используйте плагин JUnit для визуализации результатов тестов.</li>\n    </ul>\n\n    <h3>2. GitLab CI</h3>\n    <p>GitLab CI — встроенный инструмент для CI/CD в GitLab. Для интеграции JUnit:</p>\n    <ul>\n        <li>Создайте файл <code>.gitlab-ci.yml</code> в корне вашего проекта.</li>\n        <li>Добавьте шаг для запуска тестов. Например:\n            <pre><code>test:\n  stage: test\n  script:\n    - mvn test\n  artifacts:\n    reports:\n      junit: target/surefire-reports/*.xml</code></pre>\n        </li>\n        <li>GitLab автоматически соберет и отобразит результаты тестов.</li>\n    </ul>\n\n    <h3>3. GitHub Actions</h3>\n    <p>GitHub Actions — это CI/CD инструмент, встроенный в GitHub. Для интеграции JUnit:</p>\n    <ul>\n        <li>Создайте файл workflow в каталоге <code>.github/workflows</code>. Например, <code>ci.yml</code>.</li>\n        <li>Добавьте шаг для запуска тестов:\n            <pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up JDK\n        uses: actions/setup-java@v2\n        with:\n          java-version: \'11\'\n      - name: Run tests\n        run: mvn test\n      - name: Upload test results\n        uses: actions/upload-artifact@v2\n        with:\n          name: test-results\n          path: target/surefire-reports</code></pre>\n        </li>\n        <li>GitHub Actions автоматически запустит тесты и предоставит результаты.</li>\n    </ul>\n\n    <h3>4. CircleCI</h3>\n    <p>CircleCI — это облачный инструмент для CI/CD. Для интеграции JUnit:</p>\n    <ul>\n        <li>Создайте файл конфигурации <code>.circleci/config.yml</code>.</li>\n        <li>Добавьте шаг для запуска тестов:\n            <pre><code>version: 2.1\njobs:\n  test:\n    docker:\n      - image: circleci/openjdk:11-jdk\n    steps:\n      - checkout\n      - run: mvn test\n      - store_test_results:\n          path: target/surefire-reports</code></pre>\n        </li>\n        <li>CircleCI соберет и отобразит результаты тестов.</li>\n    </ul>\n\n    <h2>Преимущества интеграции JUnit с CI/CD</h2>\n    <ul>\n        <li><strong>Автоматизация тестирования:</strong> Тесты запускаются автоматически при каждом изменении кода, что снижает вероятность ошибок.</li>\n        <li><strong>Раннее обнаружение проблем:</strong> Ошибки обнаруживаются на ранних этапах, что упрощает их исправление.</li>\n        <li><strong>Прозрачность:</strong> Результаты тестов доступны всей команде, что улучшает коммуникацию и качество кода.</li>\n        <li><strong>Интеграция с другими инструментами:</strong> CI/CD инструменты можно интегрировать с системами уведомлений, анализа кода и деплоя.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Интеграция JUnit с CI/CD инструментами позволяет автоматизировать процесс тестирования, повысить качество кода и ускорить разработку. Независимо от выбранного инструмента (Jenkins, GitLab CI, GitHub Actions, CircleCI), настройка запуска тестов и анализа результатов является важным шагом для успешной реализации CI/CD.</p>',8),(131,'Обработка зависимых тестов в JUnit','<p>Зависимые тесты — это тесты, которые полагаются на результат выполнения других тестов. Такие зависимости могут усложнить процесс тестирования, так как они делают тесты менее изолированными и более хрупкими. В этом руководстве рассмотрим, как избежать зависимых тестов и как их правильно обрабатывать, если они необходимы.</p>\n\n    <h2>Почему зависимые тесты — это проблема?</h2>\n    <p>Зависимые тесты могут привести к следующим проблемам:</p>\n    <ul>\n        <li><strong>Нестабильность тестов:</strong> Если один тест завершается неудачно, это может повлиять на выполнение других тестов, что затрудняет диагностику проблем.</li>\n        <li><strong>Сложность отладки:</strong> Зависимые тесты сложнее отлаживать, так как ошибка в одном тесте может повлиять на результат выполнения целой группы тестов.</li>\n        <li><strong>Нарушение принципа изоляции:</strong> Тесты должны быть независимыми и изолированными, чтобы их можно было запускать в любом порядке и в любом окружении.</li>\n    </ul>\n\n    <h2>Как избежать зависимых тестов</h2>\n    <p>Чтобы избежать зависимых тестов, следуйте следующим рекомендациям:</p>\n    <ol>\n        <li><strong>Изолируйте тесты:</strong> Каждый тест должен быть самодостаточным и не зависеть от состояния, созданного другими тестами. Используйте методы <code>@BeforeEach</code> и <code>@AfterEach</code> для настройки и очистки состояния перед каждым тестом.</li>\n        <li><strong>Используйте моки и заглушки:</strong> Вместо того чтобы полагаться на результат выполнения другого теста, используйте моки (например, с помощью библиотеки Mockito) для имитации зависимостей.</li>\n        <li><strong>Избегайте глобального состояния:</strong> Не используйте глобальные переменные или статические поля для хранения состояния между тестами. Это может привести к неожиданным побочным эффектам.</li>\n        <li><strong>Тестируйте отдельные компоненты:</strong> Разделяйте тесты на модульные, интеграционные и системные. Модульные тесты должны быть полностью независимыми.</li>\n    </ol>\n\n    <h2>Как обрабатывать зависимые тесты, если они необходимы</h2>\n    <p>Иногда зависимые тесты неизбежны, особенно в интеграционных или end-to-end тестах. В таких случаях можно использовать следующие подходы:</p>\n\n    <h3>1. Использование аннотации <code>@Order</code></h3>\n    <p>JUnit 5 позволяет задавать порядок выполнения тестов с помощью аннотации <code>@Order</code>. Это может быть полезно, если тесты должны выполняться в определенной последовательности.</p>\n    <pre><code>@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class OrderedTests {\n\n    @Test\n    @Order(1)\n    void firstTest() {\n        // Настройка состояния\n    }\n\n    @Test\n    @Order(2)\n    void secondTest() {\n        // Тест, зависящий от firstTest\n    }\n}</code></pre>\n\n    <h3>2. Использование зависимостей через состояние</h3>\n    <p>Если тесты должны делиться состоянием, используйте общие ресурсы, такие как статические поля или внешние хранилища данных. Однако будьте осторожны, чтобы не нарушить изоляцию тестов.</p>\n    <pre><code>public class SharedStateTests {\n\n    private static String sharedState;\n\n    @Test\n    void firstTest() {\n        sharedState = \"setup\";\n        assertEquals(\"setup\", sharedState);\n    }\n\n    @Test\n    void secondTest() {\n        assertNotNull(sharedState); // Зависит от firstTest\n    }\n}</code></pre>\n\n    <h3>3. Использование <code>@Nested</code> для группировки тестов</h3>\n    <p>JUnit 5 позволяет группировать тесты с помощью аннотации <code>@Nested</code>. Это полезно, если зависимые тесты логически связаны.</p>\n    <pre><code>public class NestedTests {\n\n    @Nested\n    class FirstGroup {\n        @Test\n        void firstTest() {\n            // Настройка состояния\n        }\n    }\n\n    @Nested\n    class SecondGroup {\n        @Test\n        void secondTest() {\n            // Тест, зависящий от firstTest\n        }\n    }\n}</code></pre>\n\n    <h3>4. Использование внешних зависимостей</h3>\n    <p>Если тесты зависят от внешних систем (например, базы данных), используйте инструменты для управления состоянием, такие как Docker или тестовые базы данных.</p>\n\n    <h2>Рекомендации по работе с зависимыми тестами</h2>\n    <ul>\n        <li><strong>Минимизируйте зависимости:</strong> Старайтесь свести к минимуму количество зависимых тестов. Если возможно, пересмотрите архитектуру тестов.</li>\n        <li><strong>Документируйте зависимости:</strong> Если тесты зависят друг от друга, обязательно документируйте это, чтобы другие разработчики могли понять логику тестов.</li>\n        <li><strong>Используйте интеграционные тесты:</strong> Если зависимые тесты необходимы, вынесите их в отдельную категорию интеграционных тестов.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Зависимые тесты могут усложнить процесс тестирования, поэтому их следует избегать, насколько это возможно. Если зависимости неизбежны, используйте такие подходы, как аннотация <code>@Order</code>, группировка тестов с помощью <code>@Nested</code> или управление состоянием через общие ресурсы. Главное — сохранять тесты изолированными и легко поддерживаемыми.</p>',8),(132,'Тестирование некорректного кода с использованием JUnit','<p>JUnit — это мощный инструмент для тестирования Java-приложений, который можно использовать не только для проверки корректного поведения, но и для тестирования некорректного кода. Это особенно полезно, когда нужно убедиться, что программа правильно обрабатывает ошибки, исключения или недопустимые входные данные. Рассмотрим, как это можно сделать.</p>\n\n    <h2>Зачем тестировать некорректное поведение?</h2>\n    <p>Тестирование некорректного поведения помогает:</p>\n    <ul>\n        <li><strong>Проверить обработку ошибок:</strong> Убедиться, что программа корректно обрабатывает исключительные ситуации.</li>\n        <li><strong>Улучшить устойчивость:</strong> Гарантировать, что приложение не завершится с ошибкой при недопустимых входных данных.</li>\n        <li><strong>Соответствовать требованиям:</strong> Проверить, что программа ведет себя предсказуемо в нестандартных ситуациях.</li>\n    </ul>\n\n    <h2>Как тестировать некорректное поведение с помощью JUnit</h2>\n    <p>JUnit предоставляет несколько способов для тестирования некорректного поведения:</p>\n\n    <h3>1. Проверка исключений с помощью <code>assertThrows</code></h3>\n    <p>JUnit 5 предоставляет метод <code>assertThrows</code>, который позволяет проверить, что код выбрасывает ожидаемое исключение.</p>\n    <pre><code>@Test\nvoid testInvalidInput() {\n    IllegalArgumentException exception = assertThrows(\n        IllegalArgumentException.class,\n        () -> {\n            // Код, который должен выбросить исключение\n            someMethod(null);\n        }\n    );\n    assertEquals(\"Input cannot be null\", exception.getMessage());\n}</code></pre>\n\n    <h3>2. Использование <code>ExpectedException</code> (JUnit 4)</h3>\n    <p>В JUnit 4 можно использовать правило <code>ExpectedException</code> для проверки исключений.</p>\n    <pre><code>@Rule\npublic ExpectedException thrown = ExpectedException.none();\n\n@Test\npublic void testInvalidInput() {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Input cannot be null\");\n    someMethod(null);\n}</code></pre>\n\n    <h3>3. Проверка некорректных возвращаемых значений</h3>\n    <p>Если метод возвращает некорректное значение вместо выбрасывания исключения, можно использовать стандартные методы <code>assert</code> для проверки.</p>\n    <pre><code>@Test\nvoid testInvalidReturnValue() {\n    int result = someMethod(-1);\n    assertEquals(-1, result); // Проверка некорректного возвращаемого значения\n}</code></pre>\n\n    <h3>4. Тестирование граничных случаев</h3>\n    <p>Граничные случаи — это ситуации, когда входные данные находятся на границе допустимого диапазона. Например, передача пустой строки, нулевого значения или максимально допустимого числа.</p>\n    <pre><code>@Test\nvoid testEmptyString() {\n    String result = someMethod(\"\");\n    assertNull(result); // Проверка обработки пустой строки\n}</code></pre>\n\n    <h3>5. Использование параметризованных тестов</h3>\n    <p>JUnit 5 поддерживает параметризованные тесты, которые позволяют тестировать метод с различными входными данными, включая некорректные.</p>\n    <pre><code>@ParameterizedTest\n@ValueSource(strings = {\"\", \" \", \"invalid\"})\nvoid testInvalidInputs(String input) {\n    assertThrows(IllegalArgumentException.class, () -> someMethod(input));\n}</code></pre>\n\n    <h2>Рекомендации по тестированию некорректного поведения</h2>\n    <ul>\n        <li><strong>Тестируйте все возможные сценарии:</strong> Убедитесь, что тесты покрывают все возможные некорректные сценарии, включая граничные случаи.</li>\n        <li><strong>Используйте понятные сообщения об ошибках:</strong> Убедитесь, что исключения содержат понятные сообщения, которые помогут быстро определить причину ошибки.</li>\n        <li><strong>Избегайте избыточных тестов:</strong> Не создавайте тесты для ситуаций, которые никогда не произойдут в реальной работе программы.</li>\n        <li><strong>Документируйте ожидаемое поведение:</strong> Убедитесь, что документация к тестам четко описывает, какое поведение считается некорректным.</li>\n    </ul>\n\n    <h2>Пример: тестирование метода с некорректными входными данными</h2>\n    <p>Рассмотрим пример метода, который выбрасывает исключение при передаче отрицательного числа:</p>\n    <pre><code>public int calculateSquare(int number) {\n    if (number < 0) {\n        throw new IllegalArgumentException(\"Number cannot be negative\");\n    }\n    return number * number;\n}</code></pre>\n    <p>Тест для проверки некорректного поведения:</p>\n    <pre><code>@Test\nvoid testNegativeInput() {\n    IllegalArgumentException exception = assertThrows(\n        IllegalArgumentException.class,\n        () -> calculateSquare(-1)\n    );\n    assertEquals(\"Number cannot be negative\", exception.getMessage());\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Тестирование некорректного поведения — важная часть разработки, которая помогает убедиться, что программа корректно обрабатывает ошибки и недопустимые входные данные. JUnit предоставляет мощные инструменты для таких тестов, включая <code>assertThrows</code>, параметризованные тесты и поддержку граничных случаев. Используйте эти возможности, чтобы сделать ваше приложение более устойчивым и надежным.</p>',8),(133,'Mock-объекты в тестировании',' <p>Mock-объекты (или моки) — это специальные объекты, которые имитируют поведение реальных объектов в тестах. Они используются для изоляции тестируемого кода от внешних зависимостей, таких как базы данных, сетевые запросы или сложные системы. В этом руководстве мы подробно рассмотрим, что такое mock-объекты, зачем они нужны и как их использовать.</p>\n\n    <h2>Что такое mock-объекты?</h2>\n    <p>Mock-объекты — это объекты, которые:</p>\n    <ul>\n        <li><strong>Имитируют поведение реальных объектов:</strong> Они могут возвращать заранее заданные значения или выбрасывать исключения.</li>\n        <li><strong>Контролируют взаимодействие:</strong> Они позволяют проверять, какие методы были вызваны и с какими параметрами.</li>\n        <li><strong>Изолируют тестируемый код:</strong> Они заменяют реальные зависимости, чтобы тесты были независимыми и быстрыми.</li>\n    </ul>\n\n    <h2>Зачем использовать mock-объекты?</h2>\n    <p>Mock-объекты полезны в следующих случаях:</p>\n    <ul>\n        <li><strong>Тестирование в изоляции:</strong> Они позволяют тестировать отдельные компоненты системы, не завися от внешних систем (например, баз данных или API).</li>\n        <li><strong>Ускорение тестов:</strong> Моки работают быстрее, чем реальные объекты, так как не выполняют сложных операций.</li>\n        <li><strong>Тестирование сложных сценариев:</strong> Они позволяют имитировать редкие или сложные ситуации, такие как ошибки сети или исключения.</li>\n        <li><strong>Упрощение отладки:</strong> Моки помогают локализовать ошибки, так как тестируемый код изолирован от внешних зависимостей.</li>\n    </ul>\n\n    <h2>Как использовать mock-объекты</h2>\n    <p>Для работы с mock-объектами в Java чаще всего используются библиотеки, такие как <strong>Mockito</strong>, <strong>EasyMock</strong> или <strong>JMock</strong>. Рассмотрим пример использования Mockito.</p>\n\n    <h3>1. Подключение Mockito</h3>\n    <p>Для начала добавьте зависимость Mockito в ваш проект. Если вы используете Maven, добавьте следующий фрагмент в <code>pom.xml</code>:</p>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mockito&lt;/groupId&gt;\n    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;\n    &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>2. Создание mock-объекта</h3>\n    <p>Mockito позволяет создавать mock-объекты с помощью метода <code>mock()</code>:</p>\n    <pre><code>import static org.mockito.Mockito.*;\n\n// Создание mock-объекта\nList&lt;String&gt; mockedList = mock(List.class);</code></pre>\n\n    <h3>3. Настройка поведения mock-объекта</h3>\n    <p>Вы можете настроить поведение mock-объекта, чтобы он возвращал определенные значения или выбрасывал исключения:</p>\n    <pre><code>// Настройка возвращаемого значения\nwhen(mockedList.get(0)).thenReturn(\"first\");\n\n// Настройка выбрасывания исключения\nwhen(mockedList.get(1)).thenThrow(new IndexOutOfBoundsException());</code></pre>\n\n    <h3>4. Проверка взаимодействия</h3>\n    <p>Mockito позволяет проверять, какие методы были вызваны и с какими параметрами:</p>\n    <pre><code>// Вызов метода\nmockedList.add(\"one\");\n\n// Проверка, что метод был вызван\nverify(mockedList).add(\"one\");</code></pre>\n\n    <h3>5. Пример использования</h3>\n    <p>Рассмотрим пример тестирования сервиса, который зависит от репозитория:</p>\n    <pre><code>public class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public User getUserById(int id) {\n        return userRepository.findById(id);\n    }\n}</code></pre>\n    <p>Тест с использованием Mockito:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UserServiceTest {\n\n    @Test\n    void testGetUserById() {\n        // Создание mock-объекта\n        UserRepository mockedRepository = mock(UserRepository.class);\n\n        // Настройка поведения\n        when(mockedRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Создание тестируемого объекта\n        UserService userService = new UserService(mockedRepository);\n\n        // Вызов метода\n        User user = userService.getUserById(1);\n\n        // Проверка результата\n        assertNotNull(user);\n        assertEquals(\"John\", user.getName());\n\n        // Проверка взаимодействия\n        verify(mockedRepository).findById(1);\n    }\n}</code></pre>\n\n    <h2>Типы mock-объектов</h2>\n    <p>В зависимости от задач, можно использовать разные типы mock-объектов:</p>\n    <ul>\n        <li><strong>Mock:</strong> Полностью имитирует объект, требует настройки поведения.</li>\n        <li><strong>Spy:</strong> Частично имитирует объект, использует реальные методы, если они не переопределены.</li>\n        <li><strong>Stub:</strong> Упрощенный mock, который возвращает заранее заданные значения.</li>\n    </ul>\n\n    <h2>Рекомендации по использованию mock-объектов</h2>\n    <ul>\n        <li><strong>Не злоупотребляйте моками:</strong> Используйте их только для изоляции тестируемого кода.</li>\n        <li><strong>Тестируйте поведение, а не реализацию:</strong> Убедитесь, что тесты проверяют, что код делает, а не как он это делает.</li>\n        <li><strong>Используйте моки для сложных зависимостей:</strong> Например, для работы с базой данных или внешними API.</li>\n        <li><strong>Документируйте настройку моков:</strong> Это поможет другим разработчикам понять логику тестов.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Mock-объекты — это мощный инструмент для изоляции тестируемого кода и ускорения тестов. Они позволяют имитировать поведение сложных зависимостей и тестировать код в контролируемых условиях. Используя библиотеки, такие как Mockito, вы можете легко создавать и настраивать mock-объекты для своих тестов. Главное — использовать их с умом и не злоупотреблять ими.</p>',8),(134,'Mockito verify',' <p>Одной из ключевых возможностей mock-объектов является проверка того, были ли вызваны определенные методы и с какими параметрами. В библиотеке Mockito для этого используется метод <code>verify</code>. В этом руководстве мы рассмотрим, как использовать <code>verify</code> для проверки вызовов методов на мок-объектах.</p>\n\n    <h2>Что такое verify?</h2>\n    <p><code>verify</code> — это метод библиотеки Mockito, который позволяет проверить, был ли вызван определенный метод на mock-объекте, а также уточнить, сколько раз он был вызван и с какими параметрами.</p>\n\n    <h2>Основы использования verify</h2>\n    <p>Для использования <code>verify</code> необходимо:</p>\n    <ol>\n        <li>Создать mock-объект.</li>\n        <li>Вызвать методы на mock-объекте.</li>\n        <li>Использовать <code>verify</code> для проверки вызовов.</li>\n    </ol>\n\n    <h3>Пример базового использования</h3>\n    <p>Рассмотрим простой пример:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class VerifyExampleTest {\n\n    @Test\n    void testMethodCall() {\n        // Создание mock-объекта\n        List&lt;String&gt; mockedList = mock(List.class);\n\n        // Вызов метода на mock-объекте\n        mockedList.add(\"one\");\n\n        // Проверка, что метод add был вызван с аргументом \"one\"\n        verify(mockedList).add(\"one\");\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы создали mock-объект для интерфейса <code>List</code>.</li>\n        <li>Вызвали метод <code>add(\"one\")</code> на mock-объекте.</li>\n        <li>Использовали <code>verify</code>, чтобы убедиться, что метод <code>add</code> был вызван с аргументом <code>\"one\"</code>.</li>\n    </ul>\n\n    <h2>Проверка количества вызовов</h2>\n    <p>Mockito позволяет проверить, сколько раз был вызван метод. Для этого используются методы:</p>\n    <ul>\n        <li><code>times(n)</code> — метод был вызван ровно <code>n</code> раз.</li>\n        <li><code>atLeast(n)</code> — метод был вызван как минимум <code>n</code> раз.</li>\n        <li><code>atMost(n)</code> — метод был вызван не более <code>n</code> раз.</li>\n        <li><code>never()</code> — метод не был вызван ни разу.</li>\n    </ul>\n\n    <h3>Пример проверки количества вызовов</h3>\n    <pre><code>@Test\nvoid testMethodCallCount() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    mockedList.add(\"one\");\n    mockedList.add(\"one\");\n\n    // Проверка, что метод add был вызван ровно 2 раза\n    verify(mockedList, times(2)).add(\"one\");\n\n    // Проверка, что метод clear не был вызван ни разу\n    verify(mockedList, never()).clear();\n}</code></pre>\n\n    <h2>Проверка порядка вызовов</h2>\n    <p>Mockito позволяет проверить порядок вызовов методов с помощью объекта <code>InOrder</code>.</p>\n    <pre><code>@Test\nvoid testMethodCallOrder() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    mockedList.add(\"one\");\n    mockedList.add(\"two\");\n\n    // Создание объекта для проверки порядка\n    InOrder inOrder = inOrder(mockedList);\n\n    // Проверка порядка вызовов\n    inOrder.verify(mockedList).add(\"one\");\n    inOrder.verify(mockedList).add(\"two\");\n}</code></pre>\n\n    <h2>Проверка аргументов</h2>\n    <p>Mockito позволяет гибко проверять аргументы, переданные в метод. Для этого можно использовать:</p>\n    <ul>\n        <li><code>eq(value)</code> — проверка конкретного значения.</li>\n        <li><code>any()</code> — проверка, что аргумент был передан, но его значение не важно.</li>\n        <li><code>anyString()</code>, <code>anyInt()</code> и т.д. — проверка типа аргумента.</li>\n    </ul>\n\n    <h3>Пример проверки аргументов</h3>\n    <pre><code>@Test\nvoid testMethodCallArguments() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    mockedList.add(\"one\");\n\n    // Проверка, что метод add был вызван с любым аргументом типа String\n    verify(mockedList).add(anyString());\n\n    // Проверка, что метод add был вызван с конкретным аргументом\n    verify(mockedList).add(eq(\"one\"));\n}</code></pre>\n\n    <h2>Проверка исключений</h2>\n    <p>Mockito также позволяет проверить, что метод не был вызван из-за исключения:</p>\n    <pre><code>@Test\nvoid testMethodCallException() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    // Настройка mock-объекта для выбрасывания исключения\n    doThrow(new RuntimeException()).when(mockedList).clear();\n\n    try {\n        mockedList.clear();\n    } catch (RuntimeException e) {\n        // Ожидаемое исключение\n    }\n\n    // Проверка, что метод clear был вызван\n    verify(mockedList).clear();\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Метод <code>verify</code> в Mockito — это мощный инструмент для проверки вызовов методов на mock-объектах. Он позволяет:</p>\n    <ul>\n        <li>Проверять, был ли вызван метод.</li>\n        <li>Контролировать количество вызовов.</li>\n        <li>Проверять порядок вызовов.</li>\n        <li>Анализировать аргументы, переданные в метод.</li>\n    </ul>\n    <p>Используйте <code>verify</code> для создания надежных и точных тестов, которые проверяют не только результат, но и взаимодействие между объектами.</p>',8),(135,'Разница между @Mock и @InjectMocks',' <p>В библиотеке Mockito аннотации <code>@Mock</code> и <code>@InjectMocks</code> используются для создания и управления mock-объектами в тестах. Они упрощают процесс создания тестов, но имеют разные цели и способы использования. В этом руководстве мы рассмотрим, как работают эти аннотации и как они связаны между собой.</p>\n\n    <h2>Аннотация @Mock</h2>\n    <p>Аннотация <code>@Mock</code> используется для создания mock-объекта. Mock-объект — это объект, который имитирует поведение реального объекта, но не выполняет его реальной логики. Вместо этого он возвращает заранее заданные значения или выбрасывает исключения.</p>\n\n    <h3>Как использовать @Mock</h3>\n    <p>Для использования <code>@Mock</code> необходимо:</p>\n    <ol>\n        <li>Добавить аннотацию <code>@Mock</code> к полю, которое должно быть mock-объектом.</li>\n        <li>Инициализировать mock-объекты с помощью <code>MockitoAnnotations.openMocks(this)</code> или использовать <code>@ExtendWith(MockitoExtension.class)</code> в JUnit 5.</li>\n    </ol>\n\n    <h4>Пример использования @Mock</h4>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\npublic class MockExampleTest {\n\n    @Mock\n    private List&lt;String&gt; mockedList;\n\n    @BeforeEach\n    void setUp() {\n        // Инициализация mock-объектов\n        MockitoAnnotations.openMocks(this);\n    }\n\n    @Test\n    void testMock() {\n        // Настройка поведения mock-объекта\n        when(mockedList.get(0)).thenReturn(\"first\");\n\n        // Проверка\n        assertEquals(\"first\", mockedList.get(0));\n    }\n}</code></pre>\n\n    <h2>Аннотация @InjectMocks</h2>\n    <p>Аннотация <code>@InjectMocks</code> используется для создания реального объекта, в который будут внедрены mock-объекты. Это полезно, когда тестируемый класс зависит от других объектов, которые нужно заменить на mock-объекты.</p>\n\n    <h3>Как использовать @InjectMocks</h3>\n    <p>Для использования <code>@InjectMocks</code> необходимо:</p>\n    <ol>\n        <li>Добавить аннотацию <code>@InjectMocks</code> к полю, которое представляет тестируемый объект.</li>\n        <li>Добавить аннотацию <code>@Mock</code> к полям, которые должны быть mock-объектами.</li>\n        <li>Инициализировать mock-объекты и тестируемый объект с помощью <code>MockitoAnnotations.openMocks(this)</code> или <code>@ExtendWith(MockitoExtension.class)</code>.</li>\n    </ol>\n\n    <h4>Пример использования @InjectMocks</h4>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\npublic class InjectMocksExampleTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @BeforeEach\n    void setUp() {\n        // Инициализация mock-объектов и тестируемого объекта\n        MockitoAnnotations.openMocks(this);\n    }\n\n    @Test\n    void testGetUserById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода тестируемого объекта\n        User user = userService.getUserById(1);\n\n        // Проверка результата\n        assertNotNull(user);\n        assertEquals(\"John\", user.getName());\n    }\n}</code></pre>\n\n    <h2>Разница между @Mock и @InjectMocks</h2>\n    <p>Основные различия между <code>@Mock</code> и <code>@InjectMocks</code>:</p>\n    <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Аннотация</th>\n                <th>Назначение</th>\n                <th>Использование</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><code>@Mock</code></td>\n                <td>Создает mock-объект, который имитирует поведение реального объекта.</td>\n                <td>Используется для замены зависимостей тестируемого объекта.</td>\n            </tr>\n            <tr>\n                <td><code>@InjectMocks</code></td>\n                <td>Создает реальный объект, в который внедряются mock-объекты.</td>\n                <td>Используется для создания тестируемого объекта с внедренными mock-зависимостями.</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <h2>Как связаны @Mock и @InjectMocks</h2>\n    <p>Аннотации <code>@Mock</code> и <code>@InjectMocks</code> работают вместе:</p>\n    <ol>\n        <li><code>@Mock</code> создает mock-объекты, которые заменяют зависимости тестируемого объекта.</li>\n        <li><code>@InjectMocks</code> создает тестируемый объект и автоматически внедряет в него mock-объекты.</li>\n    </ol>\n    <p>Это позволяет тестировать объекты в изоляции, не создавая реальных зависимостей.</p>\n\n    <h2>Заключение</h2>\n    <p>Аннотации <code>@Mock</code> и <code>@InjectMocks</code> — это мощные инструменты для создания и управления mock-объектами в тестах. <code>@Mock</code> используется для создания mock-объектов, а <code>@InjectMocks</code> — для создания тестируемого объекта с внедренными mock-зависимостями. Используйте их вместе, чтобы упростить процесс тестирования и изолировать тестируемый код от внешних зависимостей.</p>',8),(136,'Обработка исключений в mock-объектах','<p>При тестировании с использованием mock-объектов иногда необходимо проверить, как код обрабатывает исключения, которые могут быть выброшены методами зависимостей. В библиотеке Mockito можно настроить mock-объект так, чтобы он выбрасывал исключения при вызове определенных методов. В этом руководстве мы рассмотрим, как это сделать.</p>\n\n    <h2>Настройка mock-объекта для выбрасывания исключений</h2>\n    <p>Mockito предоставляет несколько способов для настройки mock-объекта, чтобы он выбрасывал исключения:</p>\n    <ol>\n        <li>Использование <code>when().thenThrow()</code>.</li>\n        <li>Использование <code>doThrow().when()</code>.</li>\n    </ol>\n\n    <h3>1. Использование <code>when().thenThrow()</code></h3>\n    <p>Этот способ подходит для методов, которые возвращают значение. Пример:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MockExceptionExampleTest {\n\n    @Test\n    void testThrowException() {\n        // Создание mock-объекта\n        List&lt;String&gt; mockedList = mock(List.class);\n\n        // Настройка mock-объекта для выбрасывания исключения\n        when(mockedList.get(0)).thenThrow(new IndexOutOfBoundsException(\"Index 0 out of bounds\"));\n\n        // Проверка, что исключение выбрасывается\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class, () -> {\n            mockedList.get(0);\n        });\n\n        assertEquals(\"Index 0 out of bounds\", exception.getMessage());\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы создали mock-объект для интерфейса <code>List</code>.</li>\n        <li>Настроили его так, чтобы метод <code>get(0)</code> выбрасывал исключение <code>IndexOutOfBoundsException</code>.</li>\n        <li>Проверили, что исключение действительно выбрасывается при вызове метода.</li>\n    </ul>\n\n    <h3>2. Использование <code>doThrow().when()</code></h3>\n    <p>Этот способ подходит для методов, которые не возвращают значение (void-методы). Пример:</p>\n    <pre><code>@Test\nvoid testThrowExceptionVoidMethod() {\n    // Создание mock-объекта\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    // Настройка mock-объекта для выбрасывания исключения\n    doThrow(new IllegalStateException(\"List is locked\")).when(mockedList).clear();\n\n    // Проверка, что исключение выбрасывается\n    IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {\n        mockedList.clear();\n    });\n\n    assertEquals(\"List is locked\", exception.getMessage());\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы настроили mock-объект так, чтобы метод <code>clear()</code> выбрасывал исключение <code>IllegalStateException</code>.</li>\n        <li>Проверили, что исключение выбрасывается при вызове метода.</li>\n    </ul>\n\n    <h2>Пример: тестирование обработки исключений в реальном коде</h2>\n    <p>Рассмотрим пример, где тестируемый код должен обрабатывать исключение, выброшенное mock-объектом.</p>\n\n    <h3>Класс для тестирования</h3>\n    <pre><code>public class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public String getUserNameById(int id) {\n        try {\n            User user = userRepository.findById(id);\n            return user.getName();\n        } catch (UserNotFoundException e) {\n            return \"User not found\";\n        }\n    }\n}</code></pre>\n\n    <h3>Тест с использованием mock-объекта</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n\n    @Test\n    void testGetUserNameByIdWhenUserNotFound() {\n        // Настройка mock-объекта для выбрасывания исключения\n        when(userRepository.findById(1)).thenThrow(new UserNotFoundException(\"User not found\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"User not found\", result);\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы создали mock-объект для <code>UserRepository</code>.</li>\n        <li>Настроили его так, чтобы метод <code>findById(1)</code> выбрасывал исключение <code>UserNotFoundException</code>.</li>\n        <li>Проверили, что метод <code>getUserNameById</code> корректно обрабатывает исключение и возвращает ожидаемое значение.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Настройка mock-объектов для выбрасывания исключений — это мощный инструмент для тестирования обработки ошибок в вашем коде. Используя методы <code>when().thenThrow()</code> и <code>doThrow().when()</code>, вы можете имитировать различные сценарии ошибок и убедиться, что ваш код корректно их обрабатывает. Это особенно полезно для тестирования граничных случаев и повышения устойчивости вашего приложения.</p>',8),(137,'ArgumentCaptor в Mockito','  <p><code>ArgumentCaptor</code> — это мощный инструмент в библиотеке Mockito, который позволяет захватывать аргументы, переданные в методы mock-объектов. Это особенно полезно, когда нужно проверить, какие именно аргументы были переданы в метод, или когда аргументы сложные и требуют дополнительной проверки.</p>\n\n    <h2>Что такое ArgumentCaptor?</h2>\n    <p><code>ArgumentCaptor</code> — это объект, который захватывает аргументы, переданные в метод mock-объекта. После вызова метода вы можете получить захваченные аргументы и проверить их значения или состояние.</p>\n\n    <h2>Зачем использовать ArgumentCaptor?</h2>\n    <p><code>ArgumentCaptor</code> полезен в следующих случаях:</p>\n    <ul>\n        <li><strong>Проверка сложных аргументов:</strong> Когда аргументы метода сложные (например, объекты), и нужно проверить их состояние.</li>\n        <li><strong>Проверка нескольких вызовов:</strong> Когда метод вызывается несколько раз с разными аргументами, и нужно проверить каждый из них.</li>\n        <li><strong>Проверка аргументов, которые не возвращаются:</strong> Когда метод не возвращает значение (void), и нужно проверить, какие аргументы были переданы.</li>\n    </ul>\n\n    <h2>Как использовать ArgumentCaptor</h2>\n    <p>Для использования <code>ArgumentCaptor</code> необходимо:</p>\n    <ol>\n        <li>Создать объект <code>ArgumentCaptor</code> для нужного типа аргумента.</li>\n        <li>Использовать <code>verify</code> для захвата аргументов.</li>\n        <li>Проверить захваченные аргументы.</li>\n    </ol>\n\n    <h3>Пример использования ArgumentCaptor</h3>\n    <p>Рассмотрим пример, где мы хотим проверить, какие аргументы были переданы в метод <code>add</code> mock-объекта <code>List</code>:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.util.List;\n\npublic class ArgumentCaptorExampleTest {\n\n    @Mock\n    private List&lt;String&gt; mockedList;\n\n    @Captor\n    private ArgumentCaptor&lt;String&gt; argumentCaptor;\n\n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n\n    @Test\n    void testArgumentCaptor() {\n        // Вызов метода на mock-объекте\n        mockedList.add(\"one\");\n\n        // Захват аргумента, переданного в метод add\n        verify(mockedList).add(argumentCaptor.capture());\n\n        // Проверка захваченного аргумента\n        String capturedArgument = argumentCaptor.getValue();\n        assertEquals(\"one\", capturedArgument);\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы создали mock-объект для интерфейса <code>List</code>.</li>\n        <li>Использовали аннотацию <code>@Captor</code> для создания <code>ArgumentCaptor</code>.</li>\n        <li>Вызвали метод <code>add(\"one\")</code> на mock-объекте.</li>\n        <li>Использовали <code>verify</code> для захвата аргумента, переданного в метод <code>add</code>.</li>\n        <li>Проверили, что захваченный аргумент равен <code>\"one\"</code>.</li>\n    </ul>\n\n    <h2>Захват нескольких аргументов</h2>\n    <p>Если метод вызывается несколько раз, можно захватить все аргументы и проверить их:</p>\n    <pre><code>@Test\nvoid testMultipleArguments() {\n    // Вызов метода на mock-объекте несколько раз\n    mockedList.add(\"one\");\n    mockedList.add(\"two\");\n\n    // Захват всех аргументов, переданных в метод add\n    verify(mockedList, times(2)).add(argumentCaptor.capture());\n\n    // Получение всех захваченных аргументов\n    List&lt;String&gt; capturedArguments = argumentCaptor.getAllValues();\n\n    // Проверка захваченных аргументов\n    assertEquals(2, capturedArguments.size());\n    assertEquals(\"one\", capturedArguments.get(0));\n    assertEquals(\"two\", capturedArguments.get(1));\n}</code></pre>\n\n    <h2>Захват сложных объектов</h2>\n    <p><code>ArgumentCaptor</code> также можно использовать для захвата сложных объектов, таких как пользовательские классы:</p>\n    <pre><code>@Test\nvoid testComplexObjectCapture() {\n    // Создание mock-объекта\n    UserRepository mockedRepository = mock(UserRepository.class);\n\n    // Создание тестируемого объекта\n    UserService userService = new UserService(mockedRepository);\n\n    // Вызов метода\n    userService.createUser(\"John\", 30);\n\n    // Создание ArgumentCaptor для объекта User\n    ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);\n\n    // Захват аргумента, переданного в метод save\n    verify(mockedRepository).save(userCaptor.capture());\n\n    // Проверка захваченного объекта\n    User capturedUser = userCaptor.getValue();\n    assertEquals(\"John\", capturedUser.getName());\n    assertEquals(30, capturedUser.getAge());\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p><code>ArgumentCaptor</code> — это мощный инструмент для захвата и проверки аргументов, переданных в методы mock-объектов. Он особенно полезен для:</p>\n    <ul>\n        <li>Проверки сложных аргументов.</li>\n        <li>Проверки нескольких вызовов метода.</li>\n        <li>Проверки аргументов в void-методах.</li>\n    </ul>\n    <p>Используйте <code>ArgumentCaptor</code> для создания более точных и надежных тестов, которые проверяют не только факт вызова метода, но и его аргументы.</p>',8),(138,'Все методы Mockito',' <p>Mockito — это мощная библиотека для создания mock-объектов и управления их поведением в тестах. В этом руководстве мы рассмотрим все основные методы Mockito, их назначение и примеры использования.</p>\n\n    <h2>Создание mock-объектов</h2>\n    <p>Mockito предоставляет несколько способов создания mock-объектов.</p>\n\n    <h3>1. <code>mock()</code></h3>\n    <p>Создает mock-объект для указанного класса или интерфейса.</p>\n    <pre><code>List&lt;String&gt; mockedList = mock(List.class);</code></pre>\n\n    <h3>2. <code>@Mock</code></h3>\n    <p>Аннотация для создания mock-объекта. Требует инициализации через <code>MockitoAnnotations.openMocks(this)</code> или <code>@ExtendWith(MockitoExtension.class)</code>.</p>\n    <pre><code>@Mock\nList&lt;String&gt; mockedList;</code></pre>\n\n    <h2>Настройка поведения mock-объектов</h2>\n    <p>Mockito позволяет настраивать поведение mock-объектов с помощью различных методов.</p>\n\n    <h3>1. <code>when().thenReturn()</code></h3>\n    <p>Настраивает mock-объект для возврата определенного значения при вызове метода.</p>\n    <pre><code>when(mockedList.get(0)).thenReturn(\"first\");</code></pre>\n\n    <h3>2. <code>when().thenThrow()</code></h3>\n    <p>Настраивает mock-объект для выбрасывания исключения при вызове метода.</p>\n    <pre><code>when(mockedList.get(0)).thenThrow(new IndexOutOfBoundsException());</code></pre>\n\n    <h3>3. <code>doReturn().when()</code></h3>\n    <p>Альтернативный способ настройки возвращаемого значения.</p>\n    <pre><code>doReturn(\"first\").when(mockedList).get(0);</code></pre>\n\n    <h3>4. <code>doThrow().when()</code></h3>\n    <p>Альтернативный способ настройки выбрасывания исключения.</p>\n    <pre><code>doThrow(new IndexOutOfBoundsException()).when(mockedList).get(0);</code></pre>\n\n    <h3>5. <code>doAnswer()</code></h3>\n    <p>Настраивает mock-объект для выполнения пользовательской логики при вызове метода.</p>\n    <pre><code>doAnswer(invocation -> {\n    Object[] args = invocation.getArguments();\n    return \"called with arguments: \" + Arrays.toString(args);\n}).when(mockedList).get(anyInt());</code></pre>\n\n    <h3>6. <code>doNothing()</code></h3>\n    <p>Настраивает mock-объект для игнорирования вызова void-метода.</p>\n    <pre><code>doNothing().when(mockedList).clear();</code></pre>\n\n    <h2>Проверка вызовов методов</h2>\n    <p>Mockito позволяет проверять, были ли вызваны методы mock-объектов и с какими аргументами.</p>\n\n    <h3>1. <code>verify()</code></h3>\n    <p>Проверяет, был ли вызван метод mock-объекта.</p>\n    <pre><code>verify(mockedList).add(\"one\");</code></pre>\n\n    <h3>2. <code>verify().times()</code></h3>\n    <p>Проверяет, сколько раз был вызван метод.</p>\n    <pre><code>verify(mockedList, times(2)).add(\"one\");</code></pre>\n\n    <h3>3. <code>verify().atLeast()</code></h3>\n    <p>Проверяет, что метод был вызван как минимум указанное количество раз.</p>\n    <pre><code>verify(mockedList, atLeast(1)).add(\"one\");</code></pre>\n\n    <h3>4. <code>verify().atMost()</code></h3>\n    <p>Проверяет, что метод был вызван не более указанного количества раз.</p>\n    <pre><code>verify(mockedList, atMost(2)).add(\"one\");</code></pre>\n\n    <h3>5. <code>verify().never()</code></h3>\n    <p>Проверяет, что метод не был вызван ни разу.</p>\n    <pre><code>verify(mockedList, never()).clear();</code></pre>\n\n    <h3>6. <code>verifyNoMoreInteractions()</code></h3>\n    <p>Проверяет, что больше не было взаимодействий с mock-объектом.</p>\n    <pre><code>verifyNoMoreInteractions(mockedList);</code></pre>\n\n    <h2>Захват аргументов</h2>\n    <p>Mockito позволяет захватывать аргументы, переданные в методы mock-объектов.</p>\n\n    <h3>1. <code>ArgumentCaptor</code></h3>\n    <p>Захватывает аргументы для последующей проверки.</p>\n    <pre><code>ArgumentCaptor&lt;String&gt; captor = ArgumentCaptor.forClass(String.class);\nverify(mockedList).add(captor.capture());\nassertEquals(\"one\", captor.getValue());</code></pre>\n\n    <h2>Работа с аннотациями</h2>\n    <p>Mockito предоставляет аннотации для упрощения работы с mock-объектами.</p>\n\n    <h3>1. <code>@Mock</code></h3>\n    <p>Создает mock-объект.</p>\n    <pre><code>@Mock\nList&lt;String&gt; mockedList;</code></pre>\n\n    <h3>2. <code>@Captor</code></h3>\n    <p>Создает <code>ArgumentCaptor</code>.</p>\n    <pre><code>@Captor\nArgumentCaptor&lt;String&gt; captor;</code></pre>\n\n    <h3>3. <code>@Spy</code></h3>\n    <p>Создает spy-объект, который частично имитирует поведение реального объекта.</p>\n    <pre><code>@Spy\nList&lt;String&gt; spiedList = new ArrayList&lt;&gt;();</code></pre>\n\n    <h3>4. <code>@InjectMocks</code></h3>\n    <p>Создает объект и внедряет в него mock-объекты.</p>\n    <pre><code>@InjectMocks\nUserService userService;</code></pre>\n\n    <h2>Дополнительные методы</h2>\n    <p>Mockito предоставляет дополнительные методы для работы с mock-объектами.</p>\n\n    <h3>1. <code>reset()</code></h3>\n    <p>Сбрасывает mock-объект, удаляя все настройки и взаимодействия.</p>\n    <pre><code>reset(mockedList);</code></pre>\n\n    <h3>2. <code>ignoreStubs()</code></h3>\n    <p>Игнорирует stub-методы при проверке взаимодействий.</p>\n    <pre><code>verifyNoMoreInteractions(ignoreStubs(mockedList));</code></pre>\n\n    <h3>3. <code>inOrder()</code></h3>\n    <p>Проверяет порядок вызовов методов.</p>\n    <pre><code>InOrder inOrder = inOrder(mockedList);\ninOrder.verify(mockedList).add(\"one\");\ninOrder.verify(mockedList).add(\"two\");</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Mockito предоставляет богатый набор методов для создания и управления mock-объектами, настройки их поведения, проверки вызовов и захвата аргументов. Используя эти методы, вы можете создавать мощные и гибкие тесты, которые проверяют поведение вашего кода в различных сценариях.</p>',8),(139,'Концепция стабов (stubs) в Mockit',' <p>Стабы (stubs) — это объекты, которые возвращают заранее определенные значения в ответ на вызовы методов. Они используются для имитации поведения реальных объектов в тестах, чтобы изолировать тестируемый код от внешних зависимостей. В этом руководстве мы рассмотрим, что такое стабы, как они применяются в тестировании и как их создавать с помощью Mockito.</p>\n\n    <h2>Что такое стабы?</h2>\n    <p>Стабы — это объекты, которые:</p>\n    <ul>\n        <li><strong>Имитируют поведение реальных объектов:</strong> Они возвращают заранее заданные значения или выбрасывают исключения в ответ на вызовы методов.</li>\n        <li><strong>Используются для изоляции тестируемого кода:</strong> Они заменяют реальные зависимости, чтобы тесты были независимыми и быстрыми.</li>\n        <li><strong>Упрощают тестирование:</strong> Они позволяют тестировать код в контролируемых условиях, не завися от внешних систем.</li>\n    </ul>\n\n    <h2>Зачем использовать стабы?</h2>\n    <p>Стабы полезны в следующих случаях:</p>\n    <ul>\n        <li><strong>Тестирование в изоляции:</strong> Они позволяют тестировать отдельные компоненты системы, не завися от внешних систем (например, баз данных или API).</li>\n        <li><strong>Ускорение тестов:</strong> Стабы работают быстрее, чем реальные объекты, так как не выполняют сложных операций.</li>\n        <li><strong>Тестирование сложных сценариев:</strong> Они позволяют имитировать редкие или сложные ситуации, такие как ошибки сети или исключения.</li>\n        <li><strong>Упрощение отладки:</strong> Стабы помогают локализовать ошибки, так как тестируемый код изолирован от внешних зависимостей.</li>\n    </ul>\n\n    <h2>Как создавать стабы с помощью Mockito</h2>\n    <p>Mockito предоставляет несколько способов для создания стабов.</p>\n\n    <h3>1. Использование <code>when().thenReturn()</code></h3>\n    <p>Этот способ позволяет настроить стаб для возврата определенного значения при вызове метода.</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StubExampleTest {\n\n    @Test\n    void testStub() {\n        // Создание mock-объекта\n        List&lt;String&gt; mockedList = mock(List.class);\n\n        // Настройка стаба для возврата значения\n        when(mockedList.get(0)).thenReturn(\"first\");\n\n        // Проверка\n        assertEquals(\"first\", mockedList.get(0));\n    }\n}</code></pre>\n\n    <h3>2. Использование <code>when().thenThrow()</code></h3>\n    <p>Этот способ позволяет настроить стаб для выбрасывания исключения при вызове метода.</p>\n    <pre><code>@Test\nvoid testStubWithException() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    // Настройка стаба для выбрасывания исключения\n    when(mockedList.get(0)).thenThrow(new IndexOutOfBoundsException());\n\n    // Проверка, что исключение выбрасывается\n    assertThrows(IndexOutOfBoundsException.class, () -> {\n        mockedList.get(0);\n    });\n}</code></pre>\n\n    <h3>3. Использование <code>doReturn().when()</code></h3>\n    <p>Этот способ является альтернативой <code>when().thenReturn()</code> и используется для настройки возвращаемого значения.</p>\n    <pre><code>@Test\nvoid testStubWithDoReturn() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    // Настройка стаба для возврата значения\n    doReturn(\"first\").when(mockedList).get(0);\n\n    // Проверка\n    assertEquals(\"first\", mockedList.get(0));\n}</code></pre>\n\n    <h3>4. Использование <code>doThrow().when()</code></h3>\n    <p>Этот способ является альтернативой <code>when().thenThrow()</code> и используется для настройки выбрасывания исключения.</p>\n    <pre><code>@Test\nvoid testStubWithDoThrow() {\n    List&lt;String&gt; mockedList = mock(List.class);\n\n    // Настройка стаба для выбрасывания исключения\n    doThrow(new IndexOutOfBoundsException()).when(mockedList).get(0);\n\n    // Проверка, что исключение выбрасывается\n    assertThrows(IndexOutOfBoundsException.class, () -> {\n        mockedList.get(0);\n    });\n}</code></pre>\n\n    <h2>Пример использования стабов в реальном коде</h2>\n    <p>Рассмотрим пример, где тестируемый код зависит от внешнего сервиса, который мы заменим стабом.</p>\n\n    <h3>Класс для тестирования</h3>\n    <pre><code>public class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public String getUserNameById(int id) {\n        User user = userRepository.findById(id);\n        return user != null ? user.getName() : \"User not found\";\n    }\n}</code></pre>\n\n    <h3>Тест с использованием стаба</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка стаба для возврата пользователя\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"John\", result);\n    }\n\n    @Test\n    void testGetUserNameByIdWhenUserNotFound() {\n        // Настройка стаба для возврата null\n        when(userRepository.findById(1)).thenReturn(null);\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"User not found\", result);\n    }\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Стабы — это мощный инструмент для изоляции тестируемого кода и имитации поведения внешних зависимостей. Используя Mockito, вы можете легко создавать стабы и настраивать их поведение для различных сценариев. Это позволяет вам тестировать код в контролируемых условиях и убедиться, что он корректно обрабатывает различные ситуации.</p>',8),(140,'Мокирование статических методов с помощью mockStatic()',' <p>Mockito начиная с версии 3.4.0 предоставляет возможность мокирования статических методов с помощью метода <code>mockStatic()</code>. Это позволяет тестировать код, который зависит от статических методов, без необходимости изменять сам код. В этом руководстве мы рассмотрим, как использовать <code>mockStatic()</code> для мокирования статических методов.</p>\n\n    <h2>Зачем мокировать статические методы?</h2>\n    <p>Статические методы часто используются в утилитных классах, и их мокирование может быть полезно в следующих случаях:</p>\n    <ul>\n        <li><strong>Изоляция тестируемого кода:</strong> Мокирование статических методов позволяет изолировать тестируемый код от внешних зависимостей.</li>\n        <li><strong>Тестирование сложных сценариев:</strong> Мокирование позволяет имитировать различные сценарии, такие как ошибки или возврат определенных значений.</li>\n        <li><strong>Ускорение тестов:</strong> Мокирование статических методов может ускорить выполнение тестов, так как не требуется выполнение реальной логики.</li>\n    </ul>\n\n    <h2>Как использовать mockStatic()</h2>\n    <p>Для мокирования статических методов необходимо:</p>\n    <ol>\n        <li>Использовать метод <code>mockStatic()</code> для создания мока статического класса.</li>\n        <li>Настроить поведение статических методов с помощью <code>when()</code>.</li>\n        <li>Закрыть мок после завершения теста с помощью <code>close()</code>.</li>\n    </ol>\n\n    <h3>Пример использования mockStatic()</h3>\n    <p>Рассмотрим пример, где мы мокируем статический метод <code>getCurrentTime()</code> класса <code>TimeUtils</code>:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.MockedStatic;\nimport org.mockito.Mockito;\n\npublic class TimeUtilsTest {\n\n    @Test\n    void testGetCurrentTime() {\n        // Создание мока для статического класса\n        try (MockedStatic&lt;TimeUtils&gt; mockedStatic = Mockito.mockStatic(TimeUtils.class)) {\n            // Настройка поведения статического метода\n            mockedStatic.when(TimeUtils::getCurrentTime).thenReturn(\"12:00\");\n\n            // Вызов метода и проверка результата\n            String currentTime = TimeUtils.getCurrentTime();\n            assertEquals(\"12:00\", currentTime);\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Мы создали мок для статического класса <code>TimeUtils</code> с помощью <code>mockStatic()</code>.</li>\n        <li>Настроили поведение статического метода <code>getCurrentTime()</code> так, чтобы он возвращал значение <code>\"12:00\"</code>.</li>\n        <li>Вызвали метод и проверили, что он возвращает ожидаемое значение.</li>\n        <li>Закрыли мок после завершения теста с помощью <code>try-with-resources</code>.</li>\n    </ul>\n\n    <h2>Пример с несколькими статическими методами</h2>\n    <p>Если класс содержит несколько статических методов, можно настроить поведение каждого из них:</p>\n    <pre><code>@Test\nvoid testMultipleStaticMethods() {\n    try (MockedStatic&lt;TimeUtils&gt; mockedStatic = Mockito.mockStatic(TimeUtils.class)) {\n        // Настройка поведения статических методов\n        mockedStatic.when(TimeUtils::getCurrentTime).thenReturn(\"12:00\");\n        mockedStatic.when(TimeUtils::getCurrentDate).thenReturn(\"2023-10-01\");\n\n        // Вызов методов и проверка результатов\n        assertEquals(\"12:00\", TimeUtils.getCurrentTime());\n        assertEquals(\"2023-10-01\", TimeUtils.getCurrentDate());\n    }\n}</code></pre>\n\n    <h2>Пример с выбрасыванием исключения</h2>\n    <p>Можно настроить статический метод для выбрасывания исключения:</p>\n    <pre><code>@Test\nvoid testStaticMethodThrowsException() {\n    try (MockedStatic&lt;TimeUtils&gt; mockedStatic = Mockito.mockStatic(TimeUtils.class)) {\n        // Настройка поведения статического метода для выбрасывания исключения\n        mockedStatic.when(TimeUtils::getCurrentTime).thenThrow(new IllegalStateException(\"Time service unavailable\"));\n\n        // Проверка, что исключение выбрасывается\n        assertThrows(IllegalStateException.class, TimeUtils::getCurrentTime);\n    }\n}</code></pre>\n\n    <h2>Закрытие мока</h2>\n    <p>Важно закрывать мок после завершения теста, чтобы избежать утечек памяти и непредсказуемого поведения в других тестах. Это можно сделать с помощью <code>try-with-resources</code> или вручную вызвав метод <code>close()</code>.</p>\n\n    <h3>Пример с ручным закрытием</h3>\n    <pre><code>@Test\nvoid testManualClose() {\n    MockedStatic&lt;TimeUtils&gt; mockedStatic = Mockito.mockStatic(TimeUtils.class);\n    try {\n        mockedStatic.when(TimeUtils::getCurrentTime).thenReturn(\"12:00\");\n        assertEquals(\"12:00\", TimeUtils.getCurrentTime());\n    } finally {\n        mockedStatic.close();\n    }\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Мокирование статических методов с помощью <code>mockStatic()</code> — это мощный инструмент для тестирования кода, который зависит от статических методов. Он позволяет изолировать тестируемый код, имитировать различные сценарии и ускорять выполнение тестов. Используйте <code>mockStatic()</code> с осторожностью и не забывайте закрывать моки после завершения тестов.</p>',8),(141,'Структурирование тестов с использованием Mockito','<p>Организация и написание тестов с использованием Mockito требует соблюдения определенных принципов и подходов, чтобы тесты были читаемыми, поддерживаемыми и эффективными. В этом руководстве мы рассмотрим, как структурировать тесты с использованием Mockito, чтобы они были максимально полезными и легко понимаемыми.</p>\n\n    <h2>Основные принципы структурирования тестов</h2>\n    <p>При написании тестов с использованием Mockito важно следовать следующим принципам:</p>\n    <ul>\n        <li><strong>Читаемость:</strong> Тесты должны быть легко читаемыми и понятными.</li>\n        <li><strong>Изоляция:</strong> Каждый тест должен быть изолированным и не зависеть от других тестов.</li>\n        <li><strong>Поддерживаемость:</strong> Тесты должны быть легко поддерживаемыми и расширяемыми.</li>\n        <li><strong>Покрытие:</strong> Тесты должны покрывать все ключевые сценарии и граничные случаи.</li>\n    </ul>\n\n    <h2>Структура тестового класса</h2>\n    <p>Тестовый класс обычно структурируется следующим образом:</p>\n    <ol>\n        <li><strong>Инициализация:</strong> Настройка mock-объектов и тестируемого объекта.</li>\n        <li><strong>Тестовые методы:</strong> Написание тестов для каждого сценария.</li>\n        <li><strong>Очистка:</strong> Очистка ресурсов после выполнения тестов (если необходимо).</li>\n    </ol>\n\n    <h3>Пример структуры тестового класса</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    private UserService userService;\n\n    @BeforeEach\n    void setUp() {\n        // Инициализация mock-объектов и тестируемого объекта\n        MockitoAnnotations.openMocks(this);\n        userService = new UserService(userRepository);\n    }\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"John\", result);\n    }\n\n    @Test\n    void testGetUserNameByIdWhenUserNotFound() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(null);\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"User not found\", result);\n    }\n}</code></pre>\n\n    <h2>Инициализация mock-объектов</h2>\n    <p>Mock-объекты обычно инициализируются в методе, аннотированном <code>@BeforeEach</code>, чтобы каждый тест начинался с чистого состояния.</p>\n    <pre><code>@BeforeEach\nvoid setUp() {\n    MockitoAnnotations.openMocks(this);\n    userService = new UserService(userRepository);\n}</code></pre>\n\n    <h2>Написание тестовых методов</h2>\n    <p>Каждый тестовый метод должен проверять один конкретный сценарий. Тестовые методы обычно структурируются следующим образом:</p>\n    <ol>\n        <li><strong>Настройка:</strong> Настройка поведения mock-объектов.</li>\n        <li><strong>Выполнение:</strong> Вызов тестируемого метода.</li>\n        <li><strong>Проверка:</strong> Проверка результата и взаимодействий.</li>\n    </ol>\n\n    <h3>Пример тестового метода</h3>\n    <pre><code>@Test\nvoid testGetUserNameById() {\n    // Настройка поведения mock-объекта\n    when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n    // Вызов метода и проверка результата\n    String result = userService.getUserNameById(1);\n    assertEquals(\"John\", result);\n\n    // Проверка взаимодействий\n    verify(userRepository).findById(1);\n}</code></pre>\n\n    <h2>Использование аннотаций</h2>\n    <p>Mockito предоставляет аннотации для упрощения создания и управления mock-объектами:</p>\n    <ul>\n        <li><strong>@Mock:</strong> Создает mock-объект.</li>\n        <li><strong>@InjectMocks:</strong> Создает тестируемый объект и внедряет в него mock-объекты.</li>\n        <li><strong>@Captor:</strong> Создает ArgumentCaptor для захвата аргументов.</li>\n    </ul>\n\n    <h3>Пример использования аннотаций</h3>\n    <pre><code>@Mock\nprivate UserRepository userRepository;\n\n@InjectMocks\nprivate UserService userService;\n\n@Captor\nprivate ArgumentCaptor&lt;User&gt; userCaptor;\n\n@BeforeEach\nvoid setUp() {\n    MockitoAnnotations.openMocks(this);\n}</code></pre>\n\n    <h2>Проверка взаимодействий</h2>\n    <p>Mockito позволяет проверять, какие методы были вызваны и с какими аргументами:</p>\n    <pre><code>@Test\nvoid testAddUser() {\n    User user = new User(1, \"John\");\n    userService.addUser(user);\n\n    // Проверка, что метод save был вызван с правильным аргументом\n    verify(userRepository).save(userCaptor.capture());\n    assertEquals(user, userCaptor.getValue());\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Структурирование тестов с использованием Mockito требует соблюдения принципов читаемости, изоляции, поддерживаемости и покрытия. Используйте аннотации для упрощения создания и управления mock-объектами, и следуйте структуре \"настройка-выполнение-проверка\" для написания тестовых методов. Это поможет вам создавать эффективные и легко поддерживаемые тесты.</p>',8),(142,'Лучшие практики использования Mockito','<p>Mockito — это мощная библиотека для создания mock-объектов и управления их поведением в тестах. Однако, чтобы тесты были эффективными, поддерживаемыми и легко читаемыми, важно следовать определенным лучшим практикам. В этом руководстве мы рассмотрим лучшие практики и подходы к использованию Mockito в реальных проектах.</p>\n\n    <h2>1. Используйте аннотации для создания mock-объектов</h2>\n    <p>Mockito предоставляет аннотации, такие как <code>@Mock</code>, <code>@InjectMocks</code> и <code>@Captor</code>, которые упрощают создание и управление mock-объектами. Использование аннотаций делает код более читаемым и уменьшает количество boilerplate кода.</p>\n    <pre><code>@Mock\nprivate UserRepository userRepository;\n\n@InjectMocks\nprivate UserService userService;\n\n@BeforeEach\nvoid setUp() {\n    MockitoAnnotations.openMocks(this);\n}</code></pre>\n\n    <h2>2. Избегайте избыточного мокирования</h2>\n    <p>Мокируйте только те зависимости, которые необходимы для тестирования конкретного сценария. Избыточное мокирование может сделать тесты сложными и трудными для понимания.</p>\n    <pre><code>// Хорошо: мокируем только необходимую зависимость\n@Mock\nprivate UserRepository userRepository;\n\n// Плохо: мокируем все зависимости, даже если они не используются в тесте\n@Mock\nprivate UserRepository userRepository;\n@Mock\nprivate EmailService emailService;\n@Mock\nprivate LoggingService loggingService;</code></pre>\n\n    <h2>3. Используйте <code>verify</code> для проверки взаимодействий</h2>\n    <p>Проверяйте, что методы mock-объектов были вызваны с правильными аргументами и нужное количество раз. Это помогает убедиться, что тестируемый код корректно взаимодействует с зависимостями.</p>\n    <pre><code>@Test\nvoid testAddUser() {\n    User user = new User(1, \"John\");\n    userService.addUser(user);\n\n    // Проверка, что метод save был вызван с правильным аргументом\n    verify(userRepository).save(user);\n}</code></pre>\n\n    <h2>4. Настройте поведение mock-объектов для каждого теста</h2>\n    <p>Настройка поведения mock-объектов должна быть частью тестового метода, чтобы каждый тест был независимым и самодостаточным. Это помогает избежать побочных эффектов между тестами.</p>\n    <pre><code>@Test\nvoid testGetUserNameById() {\n    // Настройка поведения mock-объекта\n    when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n    // Вызов метода и проверка результата\n    String result = userService.getUserNameById(1);\n    assertEquals(\"John\", result);\n}</code></pre>\n\n    <h2>5. Используйте <code>ArgumentCaptor</code> для проверки сложных аргументов</h2>\n    <p>Если метод принимает сложные объекты, используйте <code>ArgumentCaptor</code> для захвата и проверки этих аргументов.</p>\n    <pre><code>@Test\nvoid testAddUser() {\n    User user = new User(1, \"John\");\n    userService.addUser(user);\n\n    // Захват аргумента и проверка\n    ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);\n    verify(userRepository).save(userCaptor.capture());\n    assertEquals(user, userCaptor.getValue());\n}</code></pre>\n\n    <h2>6. Избегайте мокирования статических методов</h2>\n    <p>Мокирование статических методов может привести к сложностям в поддержке и тестировании. Если возможно, избегайте использования статических методов или рефакторите код, чтобы уменьшить их зависимость.</p>\n    <pre><code>// Хорошо: используйте инъекцию зависимостей вместо статических методов\npublic class UserService {\n    private final UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// Плохо: использование статических методов\npublic class UserService {\n    public String getUserNameById(int id) {\n        return UserRepositoryStatic.findById(id).getName();\n    }\n}</code></pre>\n\n    <h2>7. Используйте <code>doThrow</code> для мокирования void-методов</h2>\n    <p>Для мокирования void-методов, которые должны выбрасывать исключения, используйте <code>doThrow</code>.</p>\n    <pre><code>@Test\nvoid testDeleteUserThrowsException() {\n    doThrow(new RuntimeException(\"User not found\")).when(userRepository).delete(1);\n\n    assertThrows(RuntimeException.class, () -> userService.deleteUser(1));\n}</code></pre>\n\n    <h2>8. Очищайте mock-объекты после тестов</h2>\n    <p>Если вы используете статические моки или другие ресурсы, которые требуют очистки, убедитесь, что они очищаются после выполнения тестов. Это помогает избежать утечек памяти и побочных эффектов между тестами.</p>\n    <pre><code>@AfterEach\nvoid tearDown() {\n    reset(userRepository);\n}</code></pre>\n\n    <h2>9. Пишите тесты для граничных случаев</h2>\n    <p>Убедитесь, что ваши тесты покрывают граничные случаи, такие как null-значения, пустые коллекции, исключительные ситуации и т.д.</p>\n    <pre><code>@Test\nvoid testGetUserNameByIdWhenUserNotFound() {\n    when(userRepository.findById(1)).thenReturn(null);\n\n    String result = userService.getUserNameById(1);\n    assertEquals(\"User not found\", result);\n}</code></pre>\n\n    <h2>10. Документируйте тесты</h2>\n    <p>Добавляйте комментарии и описания к тестам, чтобы они были понятны другим разработчикам. Это особенно важно для сложных тестов и граничных случаев.</p>\n    <pre><code>@Test\nvoid testGetUserNameById() {\n    // Настройка поведения mock-объекта\n    when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n    // Вызов метода и проверка результата\n    String result = userService.getUserNameById(1);\n    assertEquals(\"John\", result);\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Следование лучшим практикам использования Mockito помогает создавать эффективные, поддерживаемые и легко читаемые тесты. Используйте аннотации, избегайте избыточного мокирования, проверяйте взаимодействия с помощью <code>verify</code>, настраивайте поведение mock-объектов для каждого теста и документируйте свои тесты. Это поможет вам создавать качественные тесты, которые будут полезны в долгосрочной перспективе.</p>',8),(143,'Тестирование асинхронного кода с использованием Mockito','<p>Тестирование асинхронного кода может быть сложным из-за его недетерминированного поведения и зависимости от времени. Однако Mockito может быть полезен для тестирования таких сценариев, особенно если асинхронный код использует колбэки, Future, CompletableFuture или реактивные потоки. В этом руководстве мы рассмотрим, как применять Mockito для тестирования асинхронных методов.</p>\n\n    <h2>1. Тестирование асинхронного кода с колбэками</h2>\n    <p>Если асинхронный метод использует колбэки, можно использовать <code>Answer</code> для имитации асинхронного поведения.</p>\n\n    <h3>Пример асинхронного метода с колбэком</h3>\n    <pre><code>public interface AsyncService {\n    void performAsyncTask(Callback&lt;String&gt; callback);\n}\n\npublic interface Callback&lt;T&gt; {\n    void onSuccess(T result);\n    void onError(Throwable error);\n}</code></pre>\n\n    <h3>Тест с использованием Mockito</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithCallback() {\n    AsyncService asyncService = mock(AsyncService.class);\n    Callback&lt;String&gt; callback = mock(Callback.class);\n\n    // Настройка mock-объекта для вызова колбэка\n    doAnswer(invocation -> {\n        Callback&lt;String&gt; cb = invocation.getArgument(0);\n        cb.onSuccess(\"Task completed\");\n        return null;\n    }).when(asyncService).performAsyncTask(any(Callback.class));\n\n    // Вызов асинхронного метода\n    asyncService.performAsyncTask(callback);\n\n    // Проверка, что колбэк был вызван с правильным результатом\n    verify(callback).onSuccess(\"Task completed\");\n}</code></pre>\n\n    <h2>2. Тестирование асинхронного кода с Future</h2>\n    <p>Если асинхронный метод возвращает <code>Future</code>, можно использовать <code>thenReturn</code> для возврата заранее заданного результата.</p>\n\n    <h3>Пример асинхронного метода с Future</h3>\n    <pre><code>public interface AsyncService {\n    Future&lt;String&gt; performAsyncTask();\n}</code></pre>\n\n    <h3>Тест с использованием Mockito</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithFuture() throws Exception {\n    AsyncService asyncService = mock(AsyncService.class);\n    Future&lt;String&gt; future = CompletableFuture.completedFuture(\"Task completed\");\n\n    // Настройка mock-объекта для возврата Future\n    when(asyncService.performAsyncTask()).thenReturn(future);\n\n    // Вызов асинхронного метода и проверка результата\n    Future&lt;String&gt; resultFuture = asyncService.performAsyncTask();\n    assertEquals(\"Task completed\", resultFuture.get());\n}</code></pre>\n\n    <h2>3. Тестирование асинхронного кода с CompletableFuture</h2>\n    <p><code>CompletableFuture</code> предоставляет более гибкие возможности для работы с асинхронным кодом. Mockito может быть использован для настройки поведения <code>CompletableFuture</code>.</p>\n\n    <h3>Пример асинхронного метода с CompletableFuture</h3>\n    <pre><code>public interface AsyncService {\n    CompletableFuture&lt;String&gt; performAsyncTask();\n}</code></pre>\n\n    <h3>Тест с использованием Mockito</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithCompletableFuture() throws Exception {\n    AsyncService asyncService = mock(AsyncService.class);\n    CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(\"Task completed\");\n\n    // Настройка mock-объекта для возврата CompletableFuture\n    when(asyncService.performAsyncTask()).thenReturn(future);\n\n    // Вызов асинхронного метода и проверка результата\n    CompletableFuture&lt;String&gt; resultFuture = asyncService.performAsyncTask();\n    assertEquals(\"Task completed\", resultFuture.get());\n}</code></pre>\n\n    <h2>4. Тестирование асинхронного кода с реактивными потоками (Reactive Streams)</h2>\n    <p>Если асинхронный код использует реактивные потоки (например, Project Reactor или RxJava), можно использовать Mockito для настройки поведения Publisher.</p>\n\n    <h3>Пример асинхронного метода с реактивными потоками</h3>\n    <pre><code>public interface AsyncService {\n    Flux&lt;String&gt; performAsyncTask();\n}</code></pre>\n\n    <h3>Тест с использованием Mockito</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithReactiveStreams() {\n    AsyncService asyncService = mock(AsyncService.class);\n    Flux&lt;String&gt; flux = Flux.just(\"Task\", \"completed\");\n\n    // Настройка mock-объекта для возврата Flux\n    when(asyncService.performAsyncTask()).thenReturn(flux);\n\n    // Вызов асинхронного метода и проверка результата\n    List&lt;String&gt; results = asyncService.performAsyncTask().collectList().block();\n    assertEquals(Arrays.asList(\"Task\", \"completed\"), results);\n}</code></pre>\n\n    <h2>5. Использование <code>ArgumentCaptor</code> для захвата асинхронных аргументов</h2>\n    <p>Если асинхронный метод принимает аргументы, которые используются в колбэках или других асинхронных операциях, можно использовать <code>ArgumentCaptor</code> для захвата и проверки этих аргументов.</p>\n\n    <h3>Пример с использованием ArgumentCaptor</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithArgumentCaptor() {\n    AsyncService asyncService = mock(AsyncService.class);\n    Callback&lt;String&gt; callback = mock(Callback.class);\n    ArgumentCaptor&lt;Callback&lt;String&gt;&gt; callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n\n    // Вызов асинхронного метода\n    asyncService.performAsyncTask(callback);\n\n    // Захват колбэка и вызов его метода\n    verify(asyncService).performAsyncTask(callbackCaptor.capture());\n    callbackCaptor.getValue().onSuccess(\"Task completed\");\n\n    // Проверка, что колбэк был вызван с правильным результатом\n    verify(callback).onSuccess(\"Task completed\");\n}</code></pre>\n\n    <h2>6. Использование <code>verify</code> с таймаутами</h2>\n    <p>Для проверки асинхронных вызовов можно использовать <code>verify</code> с таймаутами, чтобы убедиться, что метод был вызван в течение определенного времени.</p>\n\n    <h3>Пример с использованием verify с таймаутом</h3>\n    <pre><code>@Test\nvoid testAsyncMethodWithTimeout() {\n    AsyncService asyncService = mock(AsyncService.class);\n    Callback&lt;String&gt; callback = mock(Callback.class);\n\n    // Вызов асинхронного метода\n    asyncService.performAsyncTask(callback);\n\n    // Проверка, что колбэк был вызван в течение 1 секунды\n    verify(callback, timeout(1000)).onSuccess(\"Task completed\");\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Тестирование асинхронного кода с использованием Mockito требует понимания того, как работает асинхронный код и какие инструменты Mockito можно использовать для его тестирования. Используйте <code>Answer</code> для имитации колбэков, настраивайте <code>Future</code> и <code>CompletableFuture</code>, проверяйте реактивные потоки и используйте <code>ArgumentCaptor</code> для захвата аргументов. Следуя этим подходам, вы сможете эффективно тестировать асинхронный код и убедиться, что он работает корректно.</p>',8),(144,'Интеграция Mockito с JUnit и AssertJ','<p>Mockito часто используется в сочетании с другими библиотеками, такими как JUnit и AssertJ, для создания мощных и выразительных тестов. В этом руководстве мы рассмотрим, как можно комбинировать Mockito с JUnit и AssertJ, чтобы улучшить читаемость и поддерживаемость тестов.</p>\n\n    <h2>1. Интеграция Mockito с JUnit</h2>\n    <p>JUnit — это популярная библиотека для написания модульных тестов в Java. Mockito легко интегрируется с JUnit, предоставляя аннотации и расширения для упрощения создания и управления mock-объектами.</p>\n\n    <h3>Пример использования Mockito с JUnit 5</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"John\", result);\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется аннотация <code>@ExtendWith(MockitoExtension.class)</code> для интеграции Mockito с JUnit 5.</li>\n        <li>Аннотации <code>@Mock</code> и <code>@InjectMocks</code> используются для создания и внедрения mock-объектов.</li>\n    </ul>\n\n    <h2>2. Интеграция Mockito с AssertJ</h2>\n    <p>AssertJ — это библиотека для написания выразительных и читаемых утверждений в тестах. Она может быть использована вместе с Mockito для улучшения читаемости проверок.</p>\n\n    <h3>Пример использования Mockito с AssertJ</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.assertj.core.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата с использованием AssertJ\n        String result = userService.getUserNameById(1);\n        assertThat(result).isEqualTo(\"John\");\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется AssertJ для написания утверждений, что делает тесты более читаемыми.</li>\n        <li>Метод <code>assertThat(result).isEqualTo(\"John\")</code> заменяет <code>assertEquals(\"John\", result)</code> из JUnit.</li>\n    </ul>\n\n    <h2>3. Комбинирование Mockito, JUnit и AssertJ</h2>\n    <p>Mockito, JUnit и AssertJ могут быть использованы вместе для создания мощных и выразительных тестов. Рассмотрим пример, где все три библиотеки используются вместе.</p>\n\n    <h3>Пример комбинирования Mockito, JUnit и AssertJ</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.assertj.core.api.Assertions.*;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата с использованием AssertJ\n        String result = userService.getUserNameById(1);\n        assertThat(result).isEqualTo(\"John\");\n    }\n\n    @Test\n    void testGetUserNameByIdWhenUserNotFound() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(null);\n\n        // Вызов метода и проверка результата с использованием AssertJ\n        String result = userService.getUserNameById(1);\n        assertThat(result).isEqualTo(\"User not found\");\n    }\n\n    @Test\n    void testGetUserNameByIdThrowsException() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenThrow(new RuntimeException(\"Database error\"));\n\n        // Проверка, что исключение выбрасывается\n        RuntimeException exception = assertThrows(RuntimeException.class, () -> {\n            userService.getUserNameById(1);\n        });\n        assertThat(exception.getMessage()).isEqualTo(\"Database error\");\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется JUnit для написания тестов и управления жизненным циклом тестов.</li>\n        <li>Используется Mockito для создания и управления mock-объектами.</li>\n        <li>Используется AssertJ для написания выразительных утверждений.</li>\n    </ul>\n\n    <h2>4. Использование <code>ArgumentCaptor</code> с AssertJ</h2>\n    <p>AssertJ может быть использован для проверки захваченных аргументов с помощью <code>ArgumentCaptor</code>.</p>\n\n    <h3>Пример использования ArgumentCaptor с AssertJ</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.assertj.core.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void testAddUser() {\n        User user = new User(1, \"John\");\n        userService.addUser(user);\n\n        // Захват аргумента и проверка с использованием AssertJ\n        ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);\n        verify(userRepository).save(userCaptor.capture());\n        assertThat(userCaptor.getValue()).isEqualTo(user);\n    }\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Интеграция Mockito с JUnit и AssertJ позволяет создавать мощные, выразительные и легко читаемые тесты. Используйте JUnit для управления тестами, Mockito для создания и управления mock-объектами и AssertJ для написания утверждений. Это сочетание поможет вам создавать качественные тесты, которые будут легко поддерживаться и расширяться.</p>',8),(145,'Роль @RunWith(MockitoJUnitRunner.class) в Mockito','<p>Аннотация <code>@RunWith(MockitoJUnitRunner.class)</code> используется в JUnit 4 для интеграции Mockito с тестовым классом. Она автоматически инициализирует mock-объекты, созданные с помощью аннотации <code>@Mock</code>, и внедряет их в тестируемый объект, созданный с помощью аннотации <code>@InjectMocks</code>. В этом руководстве мы рассмотрим, что делает этот класс и в каких случаях его следует использовать.</p>\n\n    <h2>Что делает @RunWith(MockitoJUnitRunner.class)?</h2>\n    <p><code>MockitoJUnitRunner</code> — это специальный класс-раннер, который выполняет следующие задачи:</p>\n    <ul>\n        <li><strong>Инициализация mock-объектов:</strong> Автоматически создает и инициализирует mock-объекты, помеченные аннотацией <code>@Mock</code>.</li>\n        <li><strong>Внедрение зависимостей:</strong> Автоматически внедряет mock-объекты в тестируемый объект, помеченный аннотацией <code>@InjectMocks</code>.</li>\n        <li><strong>Проверка использования mock-объектов:</strong> Проверяет, что все mock-объекты были использованы в тестах, и выдает предупреждения, если какие-то mock-объекты не были использованы.</li>\n    </ul>\n\n    <h2>Когда использовать @RunWith(MockitoJUnitRunner.class)?</h2>\n    <p><code>@RunWith(MockitoJUnitRunner.class)</code> следует использовать в следующих случаях:</p>\n    <ul>\n        <li><strong>Использование JUnit 4:</strong> Если ваш проект использует JUnit 4, а не JUnit 5, то <code>MockitoJUnitRunner</code> является стандартным способом интеграции Mockito с тестами.</li>\n        <li><strong>Упрощение кода:</strong> Если вы хотите избежать ручной инициализации mock-объектов с помощью <code>MockitoAnnotations.initMocks(this)</code>, то <code>MockitoJUnitRunner</code> автоматически выполнит эту задачу.</li>\n        <li><strong>Проверка использования mock-объектов:</strong> Если вы хотите убедиться, что все созданные mock-объекты были использованы в тестах, <code>MockitoJUnitRunner</code> поможет выявить неиспользуемые mock-объекты.</li>\n    </ul>\n\n    <h2>Пример использования @RunWith(MockitoJUnitRunner.class)</h2>\n    <p>Рассмотрим пример тестового класса, который использует <code>@RunWith(MockitoJUnitRunner.class)</code>:</p>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    public void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"John\", result);\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Аннотация <code>@RunWith(MockitoJUnitRunner.class)</code> указывает, что тестовый класс должен использовать <code>MockitoJUnitRunner</code>.</li>\n        <li>Аннотация <code>@Mock</code> создает mock-объект для <code>UserRepository</code>.</li>\n        <li>Аннотация <code>@InjectMocks</code> создает объект <code>UserService</code> и внедряет в него mock-объект <code>userRepository</code>.</li>\n        <li>Тестовый метод <code>testGetUserNameById</code> проверяет, что метод <code>getUserNameById</code> возвращает ожидаемое значение.</li>\n    </ul>\n\n    <h2>Альтернативы @RunWith(MockitoJUnitRunner.class) в JUnit 5</h2>\n    <p>В JUnit 5 вместо <code>@RunWith(MockitoJUnitRunner.class)</code> используется аннотация <code>@ExtendWith(MockitoExtension.class)</code>. Это более современный и гибкий способ интеграции Mockito с тестами.</p>\n\n    <h3>Пример использования @ExtendWith(MockitoExtension.class)</h3>\n    <pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void testGetUserNameById() {\n        // Настройка поведения mock-объекта\n        when(userRepository.findById(1)).thenReturn(new User(1, \"John\"));\n\n        // Вызов метода и проверка результата\n        String result = userService.getUserNameById(1);\n        assertEquals(\"John\", result);\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Аннотация <code>@ExtendWith(MockitoExtension.class)</code> заменяет <code>@RunWith(MockitoJUnitRunner.class)</code> в JUnit 5.</li>\n        <li>Остальная часть кода остается аналогичной, но используется JUnit 5 вместо JUnit 4.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Аннотация <code>@RunWith(MockitoJUnitRunner.class)</code> используется в JUnit 4 для автоматической инициализации mock-объектов и внедрения их в тестируемый объект. Она упрощает написание тестов и помогает выявить неиспользуемые mock-объекты. В JUnit 5 рекомендуется использовать <code>@ExtendWith(MockitoExtension.class)</code> для аналогичных целей. Выбор между этими аннотациями зависит от версии JUnit, используемой в вашем проекте.</p>',8),(146,'Что такое JDBC и для чего он используется?',' <p>JDBC (Java Database Connectivity) — это стандартный Java API (интерфейс программирования приложений), который позволяет приложениям на Java взаимодействовать с реляционными базами данных. JDBC предоставляет набор классов и интерфейсов, которые позволяют выполнять SQL-запросы, обрабатывать результаты и управлять соединениями с базами данных.</p>\n\n    <h2>Основные функции JDBC</h2>\n    <p>JDBC используется для выполнения следующих задач:</p>\n    <ul>\n        <li><strong>Установка соединения с базой данных:</strong> JDBC позволяет устанавливать соединение с различными базами данных, такими как MySQL, PostgreSQL, Oracle и другими.</li>\n        <li><strong>Выполнение SQL-запросов:</strong> С помощью JDBC можно выполнять SQL-запросы, такие как SELECT, INSERT, UPDATE, DELETE и другие.</li>\n        <li><strong>Обработка результатов запросов:</strong> JDBC предоставляет механизмы для обработки результатов SQL-запросов, таких как наборы данных (ResultSet).</li>\n        <li><strong>Управление транзакциями:</strong> JDBC позволяет управлять транзакциями, включая начало, фиксацию и откат транзакций.</li>\n        <li><strong>Работа с метаданными:</strong> JDBC предоставляет доступ к метаданным базы данных, таким как информация о таблицах, столбцах и индексах.</li>\n    </ul>\n\n    <h2>Основные компоненты JDBC</h2>\n    <p>JDBC состоит из нескольких ключевых компонентов:</p>\n    <ul>\n        <li><strong>JDBC API:</strong> Набор интерфейсов и классов, которые предоставляют методы для взаимодействия с базами данных.</li>\n        <li><strong>JDBC Driver:</strong> Драйвер, который реализует интерфейсы JDBC для конкретной базы данных. Драйвер преобразует вызовы JDBC в вызовы, понятные конкретной СУБД.</li>\n        <li><strong>Connection:</strong> Объект, представляющий соединение с базой данных.</li>\n        <li><strong>Statement:</strong> Объект, который используется для выполнения SQL-запросов.</li>\n        <li><strong>ResultSet:</strong> Объект, который содержит результаты выполнения SQL-запроса.</li>\n    </ul>\n\n    <h2>Пример использования JDBC</h2>\n    <p>Рассмотрим простой пример использования JDBC для выполнения SQL-запроса и обработки результатов:</p>\n    <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class JdbcExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\")) {\n\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"id\");\n                String name = resultSet.getString(\"name\");\n                System.out.println(\"ID: \" + id + \", Name: \" + name);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Устанавливается соединение с базой данных MySQL с помощью <code>DriverManager.getConnection()</code>.</li>\n        <li>Создается объект <code>Statement</code> для выполнения SQL-запроса.</li>\n        <li>Выполняется SQL-запрос <code>SELECT * FROM users</code> и результаты обрабатываются с помощью <code>ResultSet</code>.</li>\n        <li>Результаты выводятся на консоль.</li>\n    </ul>\n\n    <h2>Преимущества JDBC</h2>\n    <p>Использование JDBC имеет несколько преимуществ:</p>\n    <ul>\n        <li><strong>Универсальность:</strong> JDBC поддерживает множество различных баз данных, что делает его универсальным инструментом для работы с базами данных.</li>\n        <li><strong>Простота использования:</strong> JDBC предоставляет простой и понятный API для выполнения SQL-запросов и обработки результатов.</li>\n        <li><strong>Гибкость:</strong> JDBC позволяет выполнять любые SQL-запросы и управлять транзакциями на низком уровне.</li>\n        <li><strong>Интеграция с Java:</strong> JDBC полностью интегрирован с Java, что позволяет использовать его в любых Java-приложениях.</li>\n    </ul>\n\n    <h2>Недостатки JDBC</h2>\n    <p>Несмотря на свои преимущества, JDBC имеет некоторые недостатки:</p>\n    <ul>\n        <li><strong>Низкоуровневое API:</strong> JDBC требует написания большого количества кода для выполнения простых операций, таких как выполнение запросов и обработка результатов.</li>\n        <li><strong>Отсутствие ORM:</strong> JDBC не предоставляет функциональности объектно-реляционного отображения (ORM), что может усложнить работу с объектами в приложении.</li>\n        <li><strong>Управление ресурсами:</strong> JDBC требует ручного управления ресурсами, такими как соединения и запросы, что может привести к утечкам ресурсов, если не использовать try-with-resources.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>JDBC — это мощный инструмент для взаимодействия Java-приложений с реляционными базами данных. Он предоставляет универсальный и гибкий API для выполнения SQL-запросов, обработки результатов и управления соединениями. Несмотря на некоторые недостатки, JDBC остается важным инструментом в арсенале Java-разработчика, особенно в случаях, когда требуется низкоуровневое управление базами данных.</p>',13),(147,'Основные компоненты JDBC',' <p>JDBC (Java Database Connectivity) — это стандартный API для взаимодействия Java-приложений с реляционными базами данных. JDBC состоит из нескольких ключевых компонентов, которые обеспечивают выполнение SQL-запросов, обработку результатов и управление соединениями с базой данных. В этом руководстве мы рассмотрим основные компоненты JDBC и их роль в работе с базами данных.</p>\n\n    <h2>1. JDBC API</h2>\n    <p>JDBC API — это набор интерфейсов и классов, которые предоставляют методы для взаимодействия с базами данных. Основные интерфейсы и классы JDBC API включают:</p>\n    <ul>\n        <li><strong>java.sql.DriverManager:</strong> Управляет подключением к базе данных и создает объекты <code>Connection</code>.</li>\n        <li><strong>java.sql.Connection:</strong> Представляет соединение с базой данных.</li>\n        <li><strong>java.sql.Statement:</strong> Используется для выполнения SQL-запросов.</li>\n        <li><strong>java.sql.PreparedStatement:</strong> Расширяет <code>Statement</code> и позволяет выполнять параметризованные SQL-запросы.</li>\n        <li><strong>java.sql.CallableStatement:</strong> Используется для вызова хранимых процедур в базе данных.</li>\n        <li><strong>java.sql.ResultSet:</strong> Представляет результат выполнения SQL-запроса и позволяет обрабатывать данные.</li>\n        <li><strong>java.sql.ResultSetMetaData:</strong> Предоставляет информацию о структуре и свойствах <code>ResultSet</code>.</li>\n        <li><strong>java.sql.DatabaseMetaData:</strong> Предоставляет информацию о базе данных, такую как список таблиц, столбцов и индексов.</li>\n    </ul>\n\n    <h2>2. JDBC Driver</h2>\n    <p>JDBC Driver — это драйвер, который реализует интерфейсы JDBC для конкретной базы данных. Драйвер преобразует вызовы JDBC в вызовы, понятные конкретной СУБД. Существует несколько типов JDBC драйверов:</p>\n    <ul>\n        <li><strong>Тип 1: JDBC-ODBC Bridge:</strong> Использует ODBC драйвер для подключения к базе данных. Устаревший и не рекомендуется к использованию.</li>\n        <li><strong>Тип 2: Native-API Driver:</strong> Использует клиентские библиотеки базы данных для взаимодействия с СУБД.</li>\n        <li><strong>Тип 3: Network Protocol Driver:</strong> Использует промежуточный сервер для взаимодействия с базой данных.</li>\n        <li><strong>Тип 4: Thin Driver:</strong> Полностью написан на Java и напрямую взаимодействует с базой данных через сетевой протокол.</li>\n    </ul>\n\n    <h2>3. Connection</h2>\n    <p><code>Connection</code> — это объект, который представляет соединение с базой данных. Он используется для создания объектов <code>Statement</code>, <code>PreparedStatement</code> и <code>CallableStatement</code>, а также для управления транзакциями.</p>\n    <pre><code>Connection connection = DriverManager.getConnection(url, user, password);</code></pre>\n\n    <h2>4. Statement</h2>\n    <p><code>Statement</code> — это объект, который используется для выполнения SQL-запросов. Он может выполнять как простые запросы, так и запросы с параметрами.</p>\n    <pre><code>Statement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");</code></pre>\n\n    <h2>5. PreparedStatement</h2>\n    <p><code>PreparedStatement</code> — это расширение <code>Statement</code>, которое позволяет выполнять параметризованные SQL-запросы. Это повышает производительность и безопасность, так как запросы компилируются только один раз.</p>\n    <pre><code>PreparedStatement preparedStatement = connection.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\npreparedStatement.setInt(1, 1);\nResultSet resultSet = preparedStatement.executeQuery();</code></pre>\n\n    <h2>6. CallableStatement</h2>\n    <p><code>CallableStatement</code> — это объект, который используется для вызова хранимых процедур в базе данных. Он позволяет передавать входные и выходные параметры.</p>\n    <pre><code>CallableStatement callableStatement = connection.prepareCall(\"{call get_user_name(?, ?)}\");\ncallableStatement.setInt(1, 1);\ncallableStatement.registerOutParameter(2, Types.VARCHAR);\ncallableStatement.execute();\nString userName = callableStatement.getString(2);</code></pre>\n\n    <h2>7. ResultSet</h2>\n    <p><code>ResultSet</code> — это объект, который содержит результаты выполнения SQL-запроса. Он позволяет перемещаться по строкам результата и извлекать данные.</p>\n    <pre><code>ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\nwhile (resultSet.next()) {\n    int id = resultSet.getInt(\"id\");\n    String name = resultSet.getString(\"name\");\n    System.out.println(\"ID: \" + id + \", Name: \" + name);\n}</code></pre>\n\n    <h2>8. ResultSetMetaData</h2>\n    <p><code>ResultSetMetaData</code> — это объект, который предоставляет информацию о структуре и свойствах <code>ResultSet</code>, такие как количество столбцов, их имена и типы данных.</p>\n    <pre><code>ResultSetMetaData metaData = resultSet.getMetaData();\nint columnCount = metaData.getColumnCount();\nfor (int i = 1; i <= columnCount; i++) {\n    System.out.println(\"Column name: \" + metaData.getColumnName(i));\n    System.out.println(\"Column type: \" + metaData.getColumnTypeName(i));\n}</code></pre>\n\n    <h2>9. DatabaseMetaData</h2>\n    <p><code>DatabaseMetaData</code> — это объект, который предоставляет информацию о базе данных, такую как список таблиц, столбцов, индексов и других метаданных.</p>\n    <pre><code>DatabaseMetaData databaseMetaData = connection.getMetaData();\nResultSet tables = databaseMetaData.getTables(null, null, \"%\", null);\nwhile (tables.next()) {\n    System.out.println(\"Table name: \" + tables.getString(\"TABLE_NAME\"));\n}</code></pre>\n\n    <h2>Заключение</h2>\n    <p>Основные компоненты JDBC, такие как <code>Connection</code>, <code>Statement</code>, <code>PreparedStatement</code>, <code>CallableStatement</code>, <code>ResultSet</code>, <code>ResultSetMetaData</code> и <code>DatabaseMetaData</code>, обеспечивают выполнение SQL-запросов, обработку результатов и управление соединениями с базой данных. Понимание этих компонентов и их роли в JDBC помогает разработчикам эффективно работать с базами данных в Java-приложениях.</p>',13),(148,'Spring boot',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Spring Boot</u> &mdash; это проект, целью которого является упрощение процесса создания, конфигурации и развертывания приложений. Это делается за счет предоставления &quot;готовых к использованию&quot; настроек по умолчанию, что позволяет быстро и легко начать работу над новыми проектами.</p>\n\n<p>Основные преимущества:</p>\n\n<p><strong>1. Быстрый старт: </strong>Предлагает ряд стартовых зависимостей (starters), которые автоматически настраивают Spring и связанные с ним компоненты для конкретных сценариев использования, позволяя разработчикам сосредоточиться на бизнес-логике приложения.</p>\n\n<p><strong>2. Автоконфигурация:</strong> Автоматически конфигурирует ваше приложение на основе добавленных в проект библиотек, снижая необходимость в ручной настройке и XML-конфигурациях.</p>\n\n<p><strong>3. Встроенные сервера приложений: </strong>Позволяет легко встраивать серверы приложений, такие как Tomcat, Jetty или Undertow, непосредственно в ваше приложение, упрощая развертывание и тестирование.</p>\n\n<p><strong>4. Управление зависимостями:</strong> Управляет версиями всех зависимостей, гарантируя совместимость и устраняя конфликты.</p>\n\n<p><strong>5. Продуктивность и независимость:</strong> Приложения, созданные с помощью него, могут быть независимыми и самодостаточными, что облегчает их развертывание и запуск.</p>\n\n<p><strong>6. Простота в развертывании: </strong>Приложения могут быть легко упакованы в один исполняемый JAR-файл с включенными всеми необходимыми зависимостями, что делает процесс развертывания простым и удобным.</p>\n\n<p><strong>7. Актуаторы:</strong> Spring Boot предоставляет актуаторы, предоставляющие готовые конечные точки для мониторинга и управления вашим приложением во время его выполнения.</p>\n\n<p><strong>8. Поддержка разработки:</strong> Spring Boot включает в себя инструменты для горячей перезагрузки кода и автоматической перекомпиляции, ускоряя процесс разработки.</p>\n\n<p>Spring Boot значительно упрощает процесс разработки приложений на основе Spring, обеспечивая быстрый старт и минимизацию конфигурации, что делает его идеальным инструментом для разработчиков, стремящихся быстро создавать и развертывать микросервисы и веб-приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(149,'Подключение к базе данных с помощью JDBC','<p>Подключение к базе данных с использованием JDBC (Java Database Connectivity) является важным шагом для выполнения SQL-запросов и взаимодействия с данными. В этом руководстве мы рассмотрим, как установить соединение с базой данных с помощью JDBC, включая необходимые шаги и пример кода.</p>\n\n    <h2>Шаги для подключения к базе данных с помощью JDBC</h2>\n    <p>Для подключения к базе данных с использованием JDBC необходимо выполнить следующие шаги:</p>\n    <ol>\n        <li><strong>Загрузить JDBC драйвер:</strong> Убедитесь, что драйвер для вашей базы данных загружен и доступен в classpath.</li>\n        <li><strong>Установить соединение:</strong> Используйте <code>DriverManager.getConnection()</code> для установления соединения с базой данных.</li>\n        <li><strong>Выполнить SQL-запросы:</strong> Используйте объекты <code>Statement</code>, <code>PreparedStatement</code> или <code>CallableStatement</code> для выполнения SQL-запросов.</li>\n        <li><strong>Обработать результаты:</strong> Используйте объект <code>ResultSet</code> для обработки результатов выполнения запросов.</li>\n        <li><strong>Закрыть соединение:</strong> После завершения работы с базой данных обязательно закройте соединение, чтобы освободить ресурсы.</li>\n    </ol>\n\n    <h2>Пример подключения к базе данных MySQL</h2>\n    <p>Рассмотрим пример подключения к базе данных MySQL с использованием JDBC:</p>\n    <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class JdbcConnectionExample {\n    public static void main(String[] args) {\n        // URL для подключения к базе данных MySQL\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        // Имя пользователя и пароль\n        String user = \"root\";\n        String password = \"password\";\n\n        // Объект для хранения соединения с базой данных\n        Connection connection = null;\n\n        try {\n            // Шаг 1: Загрузить JDBC драйвер\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\n            // Шаг 2: Установить соединение с базой данных\n            connection = DriverManager.getConnection(url, user, password);\n\n            // Шаг 3: Создать объект Statement для выполнения SQL-запросов\n            Statement statement = connection.createStatement();\n\n            // Шаг 4: Выполнить SQL-запрос\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\n\n            // Шаг 5: Обработать результаты\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"id\");\n                String name = resultSet.getString(\"name\");\n                System.out.println(\"ID: \" + id + \", Name: \" + name);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // Шаг 6: Закрыть соединение\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется драйвер MySQL (<code>com.mysql.cj.jdbc.Driver</code>).</li>\n        <li>Устанавливается соединение с базой данных MySQL с помощью <code>DriverManager.getConnection()</code>.</li>\n        <li>Создается объект <code>Statement</code> для выполнения SQL-запроса.</li>\n        <li>Результаты запроса обрабатываются с помощью объекта <code>ResultSet</code>.</li>\n        <li>Соединение закрывается в блоке <code>finally</code>, чтобы гарантировать освобождение ресурсов.</li>\n    </ul>\n\n    <h2>Использование try-with-resources</h2>\n    <p>Для упрощения управления ресурсами можно использовать конструкцию <code>try-with-resources</code>, которая автоматически закрывает ресурсы после завершения блока <code>try</code>:</p>\n    <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class JdbcConnectionExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\")) {\n\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"id\");\n                String name = resultSet.getString(\"name\");\n                System.out.println(\"ID: \" + id + \", Name: \" + name);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется <code>try-with-resources</code> для автоматического закрытия <code>Connection</code>, <code>Statement</code> и <code>ResultSet</code>.</li>\n        <li>Код становится более компактным и безопасным, так как ресурсы автоматически закрываются даже в случае исключения.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Подключение к базе данных с использованием JDBC включает загрузку драйвера, установление соединения, выполнение SQL-запросов и обработку результатов. Использование конструкции <code>try-with-resources</code> упрощает управление ресурсами и делает код более безопасным. Следуя этим шагам, вы сможете эффективно взаимодействовать с базами данных в своих Java-приложениях.</p>',13),(150,'Connection, Statement и ResultSet в контексте JDBC',' <p>В JDBC (Java Database Connectivity) ключевыми компонентами для взаимодействия с базами данных являются <code>Connection</code>, <code>Statement</code> и <code>ResultSet</code>. Эти компоненты играют важную роль в выполнении SQL-запросов, обработке результатов и управлении соединениями с базой данных. В этом руководстве мы рассмотрим, что представляют собой эти компоненты и как они используются в JDBC.</p>\n\n    <h2>1. Connection</h2>\n    <p><code>Connection</code> — это объект, который представляет соединение с базой данных. Он используется для создания объектов <code>Statement</code>, <code>PreparedStatement</code> и <code>CallableStatement</code>, а также для управления транзакциями.</p>\n\n    <h3>Основные методы <code>Connection</code>:</h3>\n    <ul>\n        <li><strong>createStatement():</strong> Создает объект <code>Statement</code> для выполнения SQL-запросов.</li>\n        <li><strong>prepareStatement(String sql):</strong> Создает объект <code>PreparedStatement</code> для выполнения параметризованных SQL-запросов.</li>\n        <li><strong>prepareCall(String sql):</strong> Создает объект <code>CallableStatement</code> для вызова хранимых процедур.</li>\n        <li><strong>commit():</strong> Фиксирует текущую транзакцию.</li>\n        <li><strong>rollback():</strong> Откатывает текущую транзакцию.</li>\n        <li><strong>close():</strong> Закрывает соединение с базой данных.</li>\n    </ul>\n\n    <h3>Пример использования <code>Connection</code>:</h3>\n    <pre><code>Connection connection = DriverManager.getConnection(url, user, password);\nStatement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\nconnection.close();</code></pre>\n\n    <h2>2. Statement</h2>\n    <p><code>Statement</code> — это объект, который используется для выполнения SQL-запросов. Он может выполнять как простые запросы, так и запросы с параметрами.</p>\n\n    <h3>Основные методы <code>Statement</code>:</h3>\n    <ul>\n        <li><strong>executeQuery(String sql):</strong> Выполняет SQL-запрос и возвращает объект <code>ResultSet</code> с результатами.</li>\n        <li><strong>executeUpdate(String sql):</strong> Выполняет SQL-запрос, который изменяет данные (INSERT, UPDATE, DELETE), и возвращает количество затронутых строк.</li>\n        <li><strong>execute(String sql):</strong> Выполняет SQL-запрос, который может возвращать несколько результатов.</li>\n        <li><strong>close():</strong> Закрывает объект <code>Statement</code>.</li>\n    </ul>\n\n    <h3>Пример использования <code>Statement</code>:</h3>\n    <pre><code>Statement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\nwhile (resultSet.next()) {\n    int id = resultSet.getInt(\"id\");\n    String name = resultSet.getString(\"name\");\n    System.out.println(\"ID: \" + id + \", Name: \" + name);\n}\nstatement.close();</code></pre>\n\n    <h2>3. ResultSet</h2>\n    <p><code>ResultSet</code> — это объект, который содержит результаты выполнения SQL-запроса. Он позволяет перемещаться по строкам результата и извлекать данные.</p>\n\n    <h3>Основные методы <code>ResultSet</code>:</h3>\n    <ul>\n        <li><strong>next():</strong> Перемещает курсор на следующую строку результата.</li>\n        <li><strong>getInt(String columnName):</strong> Возвращает значение указанного столбца как <code>int</code>.</li>\n        <li><strong>getString(String columnName):</strong> Возвращает значение указанного столбца как <code>String</code>.</li>\n        <li><strong>getBoolean(String columnName):</strong> Возвращает значение указанного столбца как <code>boolean</code>.</li>\n        <li><strong>close():</strong> Закрывает объект <code>ResultSet</code>.</li>\n    </ul>\n\n    <h3>Пример использования <code>ResultSet</code>:</h3>\n    <pre><code>ResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\nwhile (resultSet.next()) {\n    int id = resultSet.getInt(\"id\");\n    String name = resultSet.getString(\"name\");\n    System.out.println(\"ID: \" + id + \", Name: \" + name);\n}\nresultSet.close();</code></pre>\n\n    <h2>Заключение</h2>\n    <p><code>Connection</code>, <code>Statement</code> и <code>ResultSet</code> являются ключевыми компонентами JDBC, которые обеспечивают выполнение SQL-запросов, обработку результатов и управление соединениями с базой данных. Понимание этих компонентов и их роли в JDBC помогает разработчикам эффективно работать с базами данных в Java-приложениях.</p>',13),(151,'PreparedStatement в JDBC',' <p><code>PreparedStatement</code> — это интерфейс в JDBC, который расширяет <code>Statement</code> и позволяет выполнять параметризованные SQL-запросы. Он предоставляет несколько преимуществ по сравнению с обычным <code>Statement</code>, таких как повышение производительности, безопасность и удобство использования. В этом руководстве мы рассмотрим, что такое <code>PreparedStatement</code>, как его использовать и в чем его преимущества.</p>\n\n    <h2>Что такое PreparedStatement?</h2>\n    <p><code>PreparedStatement</code> — это объект, который используется для выполнения параметризованных SQL-запросов. В отличие от <code>Statement</code>, <code>PreparedStatement</code> позволяет использовать параметры (placeholders) в SQL-запросе, которые затем могут быть заменены конкретными значениями перед выполнением запроса.</p>\n\n    <h3>Пример использования PreparedStatement:</h3>\n    <pre><code>String sql = \"SELECT * FROM users WHERE id = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setInt(1, 1); // Устанавливаем значение параметра\nResultSet resultSet = preparedStatement.executeQuery();</code></pre>\n\n    <h2>Преимущества PreparedStatement</h2>\n    <p><code>PreparedStatement</code> имеет несколько преимуществ по сравнению с обычным <code>Statement</code>:</p>\n\n    <h3>1. Повышение производительности</h3>\n    <p><code>PreparedStatement</code> компилируется только один раз при создании, а затем может быть выполнен многократно с разными параметрами. Это значительно повышает производительность, особенно при выполнении одного и того же запроса с разными значениями.</p>\n    <pre><code>String sql = \"INSERT INTO users (name, age) VALUES (?, ?)\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\npreparedStatement.setString(1, \"John\");\npreparedStatement.setInt(2, 30);\npreparedStatement.executeUpdate();\n\npreparedStatement.setString(1, \"Alice\");\npreparedStatement.setInt(2, 25);\npreparedStatement.executeUpdate();</code></pre>\n\n    <h3>2. Безопасность от SQL-инъекций</h3>\n    <p>Использование параметров в <code>PreparedStatement</code> предотвращает SQL-инъекции, так как параметры автоматически экранируются перед выполнением запроса. Это делает приложение более безопасным.</p>\n    <pre><code>String sql = \"SELECT * FROM users WHERE username = ? AND password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setString(1, username);\npreparedStatement.setString(2, password);\nResultSet resultSet = preparedStatement.executeQuery();</code></pre>\n\n    <h3>3. Удобство использования</h3>\n    <p><code>PreparedStatement</code> упрощает работу с параметрами, так как позволяет использовать методы <code>setXXX()</code> для установки значений параметров. Это делает код более читаемым и поддерживаемым.</p>\n    <pre><code>String sql = \"UPDATE users SET age = ? WHERE id = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setInt(1, 35);\npreparedStatement.setInt(2, 1);\npreparedStatement.executeUpdate();</code></pre>\n\n    <h3>4. Поддержка сложных типов данных</h3>\n    <p><code>PreparedStatement</code> поддерживает установку сложных типов данных, таких как даты, большие объекты (BLOB, CLOB) и массивы, с помощью соответствующих методов <code>setXXX()</code>.</p>\n    <pre><code>String sql = \"INSERT INTO documents (name, content) VALUES (?, ?)\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setString(1, \"document.pdf\");\npreparedStatement.setBlob(2, new FileInputStream(\"document.pdf\"));\npreparedStatement.executeUpdate();</code></pre>\n\n    <h2>Пример использования PreparedStatement</h2>\n    <p>Рассмотрим пример использования <code>PreparedStatement</code> для выполнения параметризованного SQL-запроса:</p>\n    <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic class PreparedStatementExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password)) {\n            String sql = \"SELECT * FROM users WHERE age > ?\";\n            PreparedStatement preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 25);\n\n            ResultSet resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"id\");\n                String name = resultSet.getString(\"name\");\n                int age = resultSet.getInt(\"age\");\n                System.out.println(\"ID: \" + id + \", Name: \" + name + \", Age: \" + age);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется <code>PreparedStatement</code> для выполнения параметризованного SQL-запроса.</li>\n        <li>Параметр <code>age > ?</code> заменяется значением 25 с помощью метода <code>setInt()</code>.</li>\n        <li>Результаты запроса обрабатываются с помощью объекта <code>ResultSet</code>.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p><code>PreparedStatement</code> — это мощный инструмент в JDBC, который позволяет выполнять параметризованные SQL-запросы с повышенной производительностью, безопасностью и удобством. Использование <code>PreparedStatement</code> рекомендуется для всех случаев, когда требуется выполнение SQL-запросов с параметрами, так как это помогает избежать SQL-инъекций и улучшает производительность приложения.</p>',13),(152,'Пул соединений в JDBC',' <p>Пул соединений (Connection Pool) — это механизм управления соединениями с базой данных, который позволяет повторно использовать уже установленные соединения вместо создания новых для каждого запроса. Это значительно повышает производительность и эффективность работы с базой данных, особенно в многопользовательских приложениях. В этом руководстве мы рассмотрим, что такое пул соединений, как он работает и как его использовать в JDBC.</p>\n\n    <h2>Что такое пул соединений?</h2>\n    <p>Пул соединений — это набор заранее созданных и готовых к использованию соединений с базой данных. Вместо того чтобы каждый раз создавать новое соединение и закрывать его после выполнения запроса, приложение берет соединение из пула, использует его, а затем возвращает обратно в пул для повторного использования.</p>\n\n    <h2>Преимущества пула соединений</h2>\n    <p>Использование пула соединений предоставляет несколько преимуществ:</p>\n    <ul>\n        <li><strong>Повышение производительности:</strong> Создание и закрытие соединений с базой данных — это дорогостоящие операции. Пул соединений позволяет избежать этих накладных расходов, повторно используя существующие соединения.</li>\n        <li><strong>Улучшение масштабируемости:</strong> Пул соединений позволяет эффективно управлять ограниченными ресурсами базы данных, что особенно важно в многопользовательских приложениях.</li>\n        <li><strong>Упрощение управления соединениями:</strong> Пул соединений автоматически управляет жизненным циклом соединений, включая их создание, проверку и закрытие.</li>\n        <li><strong>Снижение нагрузки на базу данных:</strong> Пул соединений ограничивает количество одновременно открытых соединений, что помогает избежать перегрузки базы данных.</li>\n    </ul>\n\n    <h2>Как работает пул соединений?</h2>\n    <p>Пул соединений работает следующим образом:</p>\n    <ol>\n        <li><strong>Инициализация:</strong> При запуске приложения создается пул соединений с заданным количеством соединений.</li>\n        <li><strong>Получение соединения:</strong> Когда приложению требуется соединение с базой данных, оно запрашивает его из пула. Если в пуле есть доступное соединение, оно возвращается приложению. Если все соединения заняты, приложение может либо ждать, пока соединение освободится, либо создать новое соединение (в зависимости от настроек пула).</li>\n        <li><strong>Использование соединения:</strong> Приложение использует соединение для выполнения SQL-запросов.</li>\n        <li><strong>Возврат соединения:</strong> После завершения работы с соединением приложение возвращает его в пул для повторного использования.</li>\n        <li><strong>Закрытие пула:</strong> При завершении работы приложения все соединения в пуле закрываются.</li>\n    </ol>\n\n    <h2>Использование пула соединений в JDBC</h2>\n    <p>Для использования пула соединений в JDBC можно использовать библиотеки, такие как <strong>HikariCP</strong>, <strong>Apache DBCP</strong> или <strong>C3P0</strong>. Рассмотрим пример использования пула соединений с помощью библиотеки HikariCP.</p>\n\n    <h3>Пример использования HikariCP</h3>\n    <p>Для начала необходимо добавить зависимость HikariCP в ваш проект. Если вы используете Maven, добавьте следующий фрагмент в <code>pom.xml</code>:</p>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;\n    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;\n    &lt;version&gt;5.0.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <p>Теперь рассмотрим пример использования HikariCP для создания пула соединений:</p>\n    <pre><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic class ConnectionPoolExample {\n    public static void main(String[] args) {\n        // Настройка пула соединений\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\n        config.setUsername(\"root\");\n        config.setPassword(\"password\");\n        config.setMaximumPoolSize(10); // Максимальное количество соединений в пуле\n\n        // Создание пула соединений\n        HikariDataSource dataSource = new HikariDataSource(config);\n\n        try (Connection connection = dataSource.getConnection();\n             PreparedStatement preparedStatement = connection.prepareStatement(\"SELECT * FROM users\");\n             ResultSet resultSet = preparedStatement.executeQuery()) {\n\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"id\");\n                String name = resultSet.getString(\"name\");\n                System.out.println(\"ID: \" + id + \", Name: \" + name);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // Закрытие пула соединений\n            dataSource.close();\n        }\n    }\n}</code></pre>\n    <p>В этом примере:</p>\n    <ul>\n        <li>Используется HikariCP для создания пула соединений с базой данных MySQL.</li>\n        <li>Настраивается максимальное количество соединений в пуле (10).</li>\n        <li>Соединение берется из пула с помощью <code>dataSource.getConnection()</code>.</li>\n        <li>После завершения работы соединение автоматически возвращается в пул благодаря использованию <code>try-with-resources</code>.</li>\n        <li>Пул соединений закрывается в блоке <code>finally</code>.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Пул соединений — это мощный механизм, который позволяет эффективно управлять соединениями с базой данных, повышая производительность и масштабируемость приложения. Использование пула соединений в JDBC с помощью библиотек, таких как HikariCP, Apache DBCP или C3P0, помогает снизить нагрузку на базу данных и упростить управление соединениями. Это особенно важно в многопользовательских приложениях, где количество одновременных запросов может быть очень большим.</p>',13),(153,'Управление транзакциями в JDBC',' <p>В JDBC транзакции управляются с помощью методов <code>setAutoCommit</code>, <code>commit</code> и <code>rollback</code>.</p>\n    \n    <h2>Пример кода</h2>\n    <pre>\n<code>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class TransactionExample {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n\n        try {\n            // Установка соединения с базой данных\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            // Выключение автоматической фиксации\n            connection.setAutoCommit(false);\n            statement = connection.createStatement();\n            \n            // Выполнение SQL-запросов\n            statement.executeUpdate(\"INSERT INTO accounts (name, balance) VALUES (\'Alice\', 1000)\");\n            statement.executeUpdate(\"INSERT INTO accounts (name, balance) VALUES (\'Bob\', 500)\");\n\n            // Фиксация транзакции\n            connection.commit();\n            System.out.println(\"Транзакция завершена успешно.\");\n        } catch (SQLException e) {\n            // В случае ошибки откатить транзакцию\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                    System.out.println(\"Транзакция откатена.\");\n                } catch (SQLException ex) {\n                    ex.printStackTrace();\n                }\n            }\n            e.printStackTrace();\n        } finally {\n            // Закрытие ресурсов\n            try {\n                if (statement != null) statement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code>\n    </pre>\n    \n    <h2>Объяснение</h2>\n    <ul>\n        <li><strong>setAutoCommit(false)</strong>: отключает автоматическую фиксацию транзакций.</li>\n        <li><strong>commit()</strong>: фиксирует изменения в базе данных.</li>\n        <li><strong>rollback()</strong>: откатывает транзакцию в случае ошибки.</li>\n    </ul>',13),(154,'Обработка исключений в JDBC','<p>При работе с JDBC важно правильно обрабатывать исключения, чтобы избежать сбоев в работе приложения и обеспечить корректное завершение операций с базой данных.</p>\n    \n    <h2>Пример кода</h2>\n    <pre>\n<code>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class ExceptionHandlingExample {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n\n        try {\n            // Установка соединения с базой данных\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            statement = connection.createStatement();\n            \n            // Выполнение SQL-запроса\n            statement.executeUpdate(\"INSERT INTO accounts (name, balance) VALUES (\'Alice\', 1000)\");\n        } catch (SQLException e) {\n            // Обработка SQLException\n            System.err.println(\"Ошибка SQL: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            // Закрытие ресурсов\n            try {\n                if (statement != null) statement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                System.err.println(\"Ошибка при закрытии ресурсов: \" + e.getMessage());\n            }\n        }\n    }\n}\n</code>\n    </pre>\n    \n    <h2>Объяснение</h2>\n    <ul>\n        <li><strong>try-catch</strong>: блок <code>try</code> используется для выполнения кода, который может вызвать исключение, а блок <code>catch</code> для обработки этого исключения.</li>\n        <li><strong>SQLException</strong>: это специфичное исключение для ошибок, связанных с SQL. Оно содержит информацию о возникшей ошибке.</li>\n        <li><strong>finally</strong>: блок <code>finally</code> выполняется всегда, даже если произошло исключение, и используется для закрытия ресурсов, таких как соединения и операторы.</li>\n    </ul>',13),(155,'Batch Processing в JDBC','<p><strong>Batch Processing</strong> (пакетная обработка) — это механизм в JDBC, позволяющий группировать несколько SQL-запросов в один пакет и отправлять их в базу данных одним вызовом. Это значительно повышает производительность, особенно при выполнении большого количества однотипных операций.</p>\n    \n    <h2>Когда использовать Batch Processing?</h2>\n    <ul>\n        <li>Когда нужно выполнить несколько операций <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code>.</li>\n        <li>Когда количество операций велико, и выполнение их по одной займет много времени.</li>\n        <li>Когда требуется минимизировать сетевой трафик между приложением и базой данных.</li>\n    </ul>\n    \n    <h2>Пример использования Batch Processing</h2>\n    <pre>\n<code>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class BatchProcessingExample {\n    public static void main(String[] args) {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n\n        try {\n            // Установка соединения с базой данных\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            \n            // Подготовка SQL-запроса\n            String sql = \"INSERT INTO accounts (name, balance) VALUES (?, ?)\";\n            preparedStatement = connection.prepareStatement(sql);\n            \n            // Добавление операций в пакет\n            preparedStatement.setString(1, \"Alice\");\n            preparedStatement.setInt(2, 1000);\n            preparedStatement.addBatch();\n            \n            preparedStatement.setString(1, \"Bob\");\n            preparedStatement.setInt(2, 500);\n            preparedStatement.addBatch();\n            \n            preparedStatement.setString(1, \"Charlie\");\n            preparedStatement.setInt(2, 750);\n            preparedStatement.addBatch();\n            \n            // Выполнение пакета\n            int[] results = preparedStatement.executeBatch();\n            System.out.println(\"Пакет выполнен успешно. Количество обработанных строк: \" + results.length);\n        } catch (SQLException e) {\n            System.err.println(\"Ошибка при выполнении Batch Processing: \" + e.getMessage());\n        } finally {\n            // Закрытие ресурсов\n            try {\n                if (preparedStatement != null) preparedStatement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                System.err.println(\"Ошибка при закрытии ресурсов: \" + e.getMessage());\n            }\n        }\n    }\n}\n</code>\n    </pre>\n    \n    <h2>Основные методы Batch Processing</h2>\n    <ul>\n        <li><strong>addBatch()</strong>: добавляет SQL-запрос в пакет.</li>\n        <li><strong>executeBatch()</strong>: отправляет все запросы из пакета в базу данных. Возвращает массив результатов, где каждый элемент указывает количество строк, затронутых соответствующим запросом.</li>\n        <li><strong>clearBatch()</strong>: очищает пакет от всех запросов.</li>\n    </ul>\n\n    <h2>Преимущества Batch Processing</h2>\n    <ul>\n        <li>Снижение сетевого трафика за счет отправки нескольких запросов одним вызовом.</li>\n        <li>Повышение производительности за счет оптимизации выполнения операций на стороне базы данных.</li>\n        <li>Упрощение кода за счет группировки операций в один пакет.</li>\n    </ul>',13),(156,'Улучшение производительности в JDBC','<p>Производительность работы с базой данных в JDBC может быть улучшена за счет оптимизации кода и использования правильных подходов. Вот основные рекомендации:</p>\n    \n    <h2>Рекомендации по улучшению производительности</h2>\n    <ul>\n        <li><strong>Использование пула соединений</strong>: Создание и закрытие соединений — это дорогостоящая операция. Используйте пулы соединений, такие как <code>HikariCP</code> или <code>Apache DBCP</code>.</li>\n        <li><strong>Использование Batch Processing</strong>: Группируйте несколько SQL-запросов в один пакет с помощью методов <code>addBatch()</code> и <code>executeBatch()</code>.</li>\n        <li><strong>Оптимизация SQL-запросов</strong>: Избегайте сложных запросов, используйте индексы и оптимизируйте структуру базы данных.</li>\n        <li><strong>Использование PreparedStatement</strong>: Подготовленные запросы (<code>PreparedStatement</code>) кэшируются и выполняются быстрее, чем обычные запросы (<code>Statement</code>).</li>\n        <li><strong>Минимизация сетевых вызовов</strong>: Избегайте частых небольших запросов. Используйте выборку данных большими порциями.</li>\n        <li><strong>Отключение автокоммита</strong>: Отключите автокоммит (<code>setAutoCommit(false)</code>), чтобы управлять транзакциями вручную.</li>\n        <li><strong>Использование кэширования</strong>: Кэшируйте часто используемые данные, чтобы избежать повторных запросов к базе данных.</li>\n    </ul>\n    \n    <h2>Пример оптимизации с Batch Processing и PreparedStatement</h2>\n    <pre>\n<code>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class PerformanceOptimizationExample {\n    public static void main(String[] args) {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n\n        try {\n            // Установка соединения с базой данных\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            connection.setAutoCommit(false); // Отключение автокоммита\n            \n            // Использование PreparedStatement\n            String sql = \"INSERT INTO accounts (name, balance) VALUES (?, ?)\";\n            preparedStatement = connection.prepareStatement(sql);\n            \n            // Добавление операций в пакет\n            for (int i = 1; i <= 1000; i++) {\n                preparedStatement.setString(1, \"User\" + i);\n                preparedStatement.setInt(2, i * 100);\n                preparedStatement.addBatch();\n                \n                // Выполнять пакет каждые 100 запросов\n                if (i % 100 == 0) {\n                    preparedStatement.executeBatch();\n                    preparedStatement.clearBatch();\n                }\n            }\n            \n            // Выполнение оставшихся запросов\n            preparedStatement.executeBatch();\n            // Фиксация транзакции\n            connection.commit();\n            System.out.println(\"Пакетная обработка завершена успешно.\");\n        } catch (SQLException e) {\n            System.err.println(\"Ошибка при выполнении запроса: \" + e.getMessage());\n            try {\n                if (connection != null) connection.rollback(); // Откат транзакции\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n        } finally {\n            // Закрытие ресурсов\n            try {\n                if (preparedStatement != null) preparedStatement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                System.err.println(\"Ошибка при закрытии ресурсов: \" + e.getMessage());\n            }\n        }\n    }\n}\n</code>\n    </pre>\n    \n    <h2>Использование пула соединений</h2>\n    <p>Пример настройки пула соединений с использованием HikariCP:</p>\n    <pre>\n<code>\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class ConnectionPoolExample {\n    public static void main(String[] args) {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\n        config.setUsername(\"user\");\n        config.setPassword(\"password\");\n        config.setMaximumPoolSize(10); // Максимальное количество соединений\n\n        HikariDataSource dataSource = new HikariDataSource(config);\n\n        try (Connection connection = dataSource.getConnection()) {\n            // Используйте соединение для выполнения запросов\n            System.out.println(\"Соединение успешно получено из пула.\");\n        } catch (SQLException e) {\n            System.err.println(\"Ошибка при получении соединения: \" + e.getMessage());\n        }\n    }\n}\n</code>\n    </pre>\n    \n    <h2>Итог</h2>\n    <p>Используя пулы соединений, пакетную обработку, подготовленные запросы и другие методы оптимизации, можно значительно повысить производительность работы с базой данных в JDBC.</p>',13),(157,'Кэширование данных в JDBC','<h1>Кэширование данных в контексте JDBC</h1>\n    <p>Кэширование данных — это процесс сохранения часто запрашиваемых данных в памяти для ускорения доступа к ним и снижения нагрузки на базу данных. В контексте JDBC кэширование помогает уменьшить количество обращений к базе данных, что повышает производительность приложения.</p>\n\n    <h2>Зачем нужно кэширование в JDBC?</h2>\n    <ul>\n        <li><strong>Снижение нагрузки на базу данных:</strong> Повторяющиеся запросы обрабатываются из кэша, а не из БД.</li>\n        <li><strong>Ускорение работы приложения:</strong> Доступ к данным из памяти быстрее, чем выполнение SQL-запросов.</li>\n        <li><strong>Оптимизация ресурсов:</strong> Уменьшение сетевых задержек и нагрузки на сервер БД.</li>\n    </ul>\n\n    <h2>Как реализовать кэширование данных?</h2>\n    <p>Кэширование можно реализовать несколькими способами:</p>\n\n    <h3>1. Использование встроенного кэша СУБД</h3>\n    <p>Некоторые базы данных (например, MySQL, Oracle) предоставляют встроенные механизмы кэширования запросов. Например, в MySQL можно включить кэш запросов:</p>\n    <pre><code>-- Включение кэша запросов в MySQL\nSET GLOBAL query_cache_size = 1000000;\nSET GLOBAL query_cache_type = ON;</code></pre>\n\n    <h3>2. Кэширование на уровне приложения</h3>\n    <p>Реализация кэша в самом приложении с использованием структур данных или библиотек кэширования.</p>\n\n    <h4>Пример: Простой кэш с использованием HashMap</h4>\n    <pre><code>import java.sql.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JdbcCacheExample {\n    private static final Map&lt;String, ResultSet&gt; cache = new HashMap&lt;&gt;();\n\n    public static ResultSet getCachedData(Connection connection, String sql) throws SQLException {\n        if (cache.containsKey(sql)) {\n            return cache.get(sql); // Возвращаем данные из кэша\n        } else {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(sql);\n            cache.put(sql, resultSet); // Сохраняем результат в кэш\n            return resultSet;\n        }\n    }\n\n    public static void clearCache() {\n        cache.clear();\n    }\n}</code></pre>\n\n    <h3>3. Использование библиотек кэширования</h3>\n    <p>Библиотеки, такие как <strong>Ehcache</strong>, <strong>Caffeine</strong> или <strong>Guava Cache</strong>, предоставляют продвинутые функции кэширования.</p>\n\n    <h4>Пример с использованием Ehcache:</h4>\n    <pre><code>import org.ehcache.Cache;\nimport org.ehcache.CacheManager;\nimport org.ehcache.config.builders.CacheConfigurationBuilder;\nimport org.ehcache.config.builders.CacheManagerBuilder;\nimport org.ehcache.config.builders.ResourcePoolsBuilder;\n\npublic class EhcacheExample {\n    private static CacheManager cacheManager;\n    private static Cache&lt;String, ResultSet&gt; cache;\n\n    static {\n        cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build();\n        cacheManager.init();\n\n        cache = cacheManager.createCache(\"sqlCache\",\n            CacheConfigurationBuilder.newCacheConfigurationBuilder(\n                String.class, \n                ResultSet.class,\n                ResourcePoolsBuilder.heap(100) // Максимум 100 записей в кэше\n            )\n        );\n    }\n\n    public static ResultSet getCachedData(String sql, Connection connection) throws SQLException {\n        if (cache.containsKey(sql)) {\n            return cache.get(sql);\n        } else {\n            Statement statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(sql);\n            cache.put(sql, resultSet);\n            return resultSet;\n        }\n    }\n\n    public static void shutdown() {\n        cacheManager.close();\n    }\n}</code></pre>\n\n    <h3>4. Кэширование через ORM-фреймворки</h3>\n    <p>Фреймворки, такие как Hibernate, предоставляют встроенные механизмы кэширования (L1, L2-кэш). Например:</p>\n    <pre><code>// Настройка кэша второго уровня в Hibernate\n&lt;property name=\"hibernate.cache.use_second_level_cache\" value=\"true\"/&gt;\n&lt;property name=\"hibernate.cache.region.factory_class\" value=\"org.hibernate.cache.ehcache.EhCacheRegionFactory\"/&gt;</code></pre>\n\n    <h2>Рекомендации по кэшированию</h2>\n    <ul>\n        <li><strong>Управление актуальностью данных:</strong> Установите TTL (время жизни) для записей в кэше.</li>\n        <li><strong>Инвалидация кэша:</strong> Обновляйте кэш при изменении данных в базе.</li>\n        <li><strong>Используйте LRU (Least Recently Used):</strong> Удаляйте редко используемые данные из кэша.</li>\n        <li><strong>Мониторинг:</strong> Следите за использованием памяти и производительностью кэша.</li>\n    </ul>\n\n    <h2>Недостатки кэширования</h2>\n    <ul>\n        <li><strong>Риск устаревания данных:</strong> Кэш может содержать неактуальные данные.</li>\n        <li><strong>Расход памяти:</strong> Кэш потребляет оперативную память приложения.</li>\n        <li><strong>Сложность реализации:</strong> Требуется дополнительный код для управления кэшем.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Кэширование данных в JDBC — это эффективный способ оптимизации работы с базой данных. Вы можете использовать встроенные механизмы СУБД, ручное кэширование через коллекции, специализированные библиотеки или ORM-фреймворки. Важно правильно управлять жизненным циклом кэша и учитывать возможные риски, такие как устаревание данных.</p>',13),(158,'DataSource и DriverManager в JDBC','<p>В JDBC существует два основных способа получения соединения с базой данных: через <code>DriverManager</code> и через <code>DataSource</code>. Эти подходы отличаются по своей функциональности, гибкости и использованию в современных приложениях. В этом руководстве мы рассмотрим, что такое <code>DataSource</code>, как он отличается от <code>DriverManager</code>, и в каких случаях лучше использовать каждый из них.</p>\n\n    <h2>Что такое DriverManager?</h2>\n    <p><code>DriverManager</code> — это устаревший класс в JDBC, который используется для установления соединения с базой данных. Он работает на основе регистрации драйверов и предоставляет статический метод <code>getConnection()</code> для создания соединений.</p>\n\n    <h3>Пример использования DriverManager:</h3>\n    <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DriverManagerExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try {\n            // Регистрация драйвера (не требуется для JDBC 4.0+)\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\n            // Получение соединения через DriverManager\n            Connection connection = DriverManager.getConnection(url, user, password);\n            System.out.println(\"Соединение установлено!\");\n\n            // Закрытие соединения\n            connection.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n\n    <h2>Что такое DataSource?</h2>\n    <p><code>DataSource</code> — это более современный и гибкий интерфейс в JDBC, который предоставляет абстракцию для получения соединений с базой данных. В отличие от <code>DriverManager</code>, <code>DataSource</code> поддерживает пул соединений, управление транзакциями и другие расширенные функции.</p>\n\n    <h3>Пример использования DataSource:</h3>\n    <pre><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class DataSourceExample {\n    public static void main(String[] args) {\n        // Настройка DataSource с использованием HikariCP\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\n        config.setUsername(\"root\");\n        config.setPassword(\"password\");\n        config.setMaximumPoolSize(10); // Максимальное количество соединений в пуле\n\n        HikariDataSource dataSource = new HikariDataSource(config);\n\n        try (Connection connection = dataSource.getConnection()) {\n            System.out.println(\"Соединение установлено через DataSource!\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            dataSource.close();\n        }\n    }\n}</code></pre>\n\n    <h2>Основные различия между DataSource и DriverManager</h2>\n    <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Характеристика</th>\n                <th>DriverManager</th>\n                <th>DataSource</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><strong>Пул соединений</strong></td>\n                <td>Не поддерживает</td>\n                <td>Поддерживает (например, через HikariCP, Apache DBCP)</td>\n            </tr>\n            <tr>\n                <td><strong>Управление транзакциями</strong></td>\n                <td>Нет встроенной поддержки</td>\n                <td>Поддерживает (например, через JTA)</td>\n            </tr>\n            <tr>\n                <td><strong>Гибкость</strong></td>\n                <td>Ограниченная</td>\n                <td>Высокая (можно настраивать параметры соединений)</td>\n            </tr>\n            <tr>\n                <td><strong>Производительность</strong></td>\n                <td>Низкая (каждое соединение создается заново)</td>\n                <td>Высокая (соединения берутся из пула)</td>\n            </tr>\n            <tr>\n                <td><strong>Использование в современных приложениях</strong></td>\n                <td>Редко</td>\n                <td>Широко используется</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <h2>Преимущества DataSource</h2>\n    <ul>\n        <li><strong>Пул соединений:</strong> Уменьшает накладные расходы на создание и закрытие соединений.</li>\n        <li><strong>Гибкость:</strong> Позволяет настраивать параметры соединений, такие как таймауты, размер пула и т.д.</li>\n        <li><strong>Поддержка транзакций:</strong> Интеграция с JTA (Java Transaction API) для управления распределенными транзакциями.</li>\n        <li><strong>Простота использования:</strong> Современные библиотеки, такие как HikariCP, упрощают настройку и использование.</li>\n    </ul>\n\n    <h2>Когда использовать DriverManager?</h2>\n    <p><code>DriverManager</code> может быть полезен в простых приложениях или для учебных целей, где не требуется высокая производительность или управление пулом соединений. Однако в современных приложениях рекомендуется использовать <code>DataSource</code>.</p>\n\n    <h2>Заключение</h2>\n    <p><code>DataSource</code> — это более мощный и гибкий способ работы с соединениями в JDBC по сравнению с <code>DriverManager</code>. Он поддерживает пул соединений, управление транзакциями и другие расширенные функции, что делает его предпочтительным выбором для современных приложений. Использование <code>DataSource</code> с библиотеками, такими как HikariCP, позволяет значительно повысить производительность и масштабируемость приложения.</p>',13),(159,'Оптимизация запросов в JDBC',' <p>Оптимизация запросов в JDBC — это важный аспект разработки высокопроизводительных приложений, работающих с базами данных. Правильная оптимизация позволяет снизить нагрузку на базу данных, уменьшить время выполнения запросов и улучшить общую производительность приложения. В этом руководстве мы рассмотрим основные способы оптимизации запросов в JDBC.</p>\n\n    <h2>1. Использование PreparedStatement</h2>\n    <p><code>PreparedStatement</code> позволяет компилировать SQL-запросы один раз и выполнять их многократно с разными параметрами. Это уменьшает накладные расходы на компиляцию запросов и повышает производительность.</p>\n    <pre><code>String sql = \"SELECT * FROM users WHERE id = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setInt(1, 1);\nResultSet resultSet = preparedStatement.executeQuery();</code></pre>\n\n    <h2>2. Использование пакетной обработки (Batch Processing)</h2>\n    <p>Пакетная обработка позволяет выполнять несколько SQL-запросов за один вызов базы данных, что уменьшает количество сетевых запросов и повышает производительность.</p>\n    <pre><code>String sql = \"INSERT INTO users (name, age) VALUES (?, ?)\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\npreparedStatement.setString(1, \"John\");\npreparedStatement.setInt(2, 30);\npreparedStatement.addBatch();\n\npreparedStatement.setString(1, \"Alice\");\npreparedStatement.setInt(2, 25);\npreparedStatement.addBatch();\n\npreparedStatement.executeBatch();</code></pre>\n\n    <h2>3. Использование пула соединений</h2>\n    <p>Пул соединений позволяет повторно использовать соединения с базой данных, что уменьшает накладные расходы на создание и закрытие соединений. Пример использования HikariCP:</p>\n    <pre><code>HikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\nconfig.setUsername(\"root\");\nconfig.setPassword(\"password\");\nconfig.setMaximumPoolSize(10);\n\nHikariDataSource dataSource = new HikariDataSource(config);\nConnection connection = dataSource.getConnection();</code></pre>\n\n    <h2>4. Оптимизация SQL-запросов</h2>\n    <p>Правильно написанные SQL-запросы могут значительно повысить производительность. Вот несколько советов:</p>\n    <ul>\n        <li><strong>Используйте индексы:</strong> Убедитесь, что запросы используют индексы для ускорения поиска.</li>\n        <li><strong>Избегайте SELECT *:</strong> Выбирайте только необходимые столбцы.</li>\n        <li><strong>Используйте JOIN вместо подзапросов:</strong> JOIN обычно работает быстрее, чем вложенные подзапросы.</li>\n        <li><strong>Ограничивайте количество строк:</strong> Используйте LIMIT или TOP для выборки только нужного количества строк.</li>\n    </ul>\n\n    <h2>5. Использование кэширования</h2>\n    <p>Кэширование результатов запросов позволяет уменьшить количество обращений к базе данных. Пример использования Ehcache:</p>\n    <pre><code>Cache&lt;String, ResultSet&gt; cache = cacheManager.getCache(\"sqlCache\", String.class, ResultSet.class);\nif (cache.containsKey(sql)) {\n    return cache.get(sql);\n} else {\n    ResultSet resultSet = statement.executeQuery(sql);\n    cache.put(sql, resultSet);\n    return resultSet;\n}</code></pre>\n\n    <h2>6. Использование транзакций</h2>\n    <p>Транзакции позволяют объединять несколько операций в одну логическую единицу, что уменьшает количество обращений к базе данных и повышает производительность.</p>\n    <pre><code>connection.setAutoCommit(false);\n\ntry {\n    // Выполнение нескольких операций\n    statement.executeUpdate(\"INSERT INTO users (name, age) VALUES (\'John\', 30)\");\n    statement.executeUpdate(\"UPDATE accounts SET balance = balance - 100 WHERE user_id = 1\");\n\n    connection.commit(); // Фиксация транзакции\n} catch (SQLException e) {\n    connection.rollback(); // Откат транзакции в случае ошибки\n}</code></pre>\n\n    <h2>7. Использование правильных типов данных</h2>\n    <p>Использование правильных типов данных для столбцов и параметров запросов может улучшить производительность. Например, используйте <code>setInt()</code> для целых чисел и <code>setString()</code> для строк.</p>\n\n    <h2>8. Оптимизация работы с ResultSet</h2>\n    <p>При работе с <code>ResultSet</code> учитывайте следующие рекомендации:</p>\n    <ul>\n        <li><strong>Используйте <code>fetchSize</code>:</strong> Установите размер выборки для уменьшения количества сетевых запросов.</li>\n        <li><strong>Закрывайте ResultSet:</strong> Всегда закрывайте <code>ResultSet</code> после использования, чтобы освободить ресурсы.</li>\n    </ul>\n    <pre><code>statement.setFetchSize(100); // Установка размера выборки\nResultSet resultSet = statement.executeQuery(\"SELECT * FROM users\");\nwhile (resultSet.next()) {\n    // Обработка данных\n}\nresultSet.close();</code></pre>\n\n    <h2>9. Использование хранимых процедур</h2>\n    <p>Хранимые процедуры выполняются на стороне базы данных, что уменьшает сетевые задержки и повышает производительность.</p>\n    <pre><code>CallableStatement callableStatement = connection.prepareCall(\"{call get_user_name(?, ?)}\");\ncallableStatement.setInt(1, 1);\ncallableStatement.registerOutParameter(2, Types.VARCHAR);\ncallableStatement.execute();\nString userName = callableStatement.getString(2);</code></pre>\n\n    <h2>10. Мониторинг и анализ запросов</h2>\n    <p>Используйте инструменты для мониторинга и анализа запросов, такие как:</p>\n    <ul>\n        <li><strong>EXPLAIN:</strong> Анализируйте план выполнения запросов в SQL.</li>\n        <li><strong>Профилирование:</strong> Используйте профилировщики для выявления узких мест в производительности.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>Оптимизация запросов в JDBC — это комплексный процесс, который включает использование <code>PreparedStatement</code>, пакетной обработки, пула соединений, кэширования и других методов. Следуя этим рекомендациям, вы сможете значительно повысить производительность вашего приложения и снизить нагрузку на базу данных.</p>',13),(160,'Идемпотентные и неидемпотентные методы HTTP','<p>В протоколе HTTP методы делятся на идемпотентные и неидемпотентные. Это разделение важно для понимания того, как методы влияют на состояние ресурса и как их можно безопасно использовать в распределенных системах. В этом руководстве мы рассмотрим, что такое идемпотентность, какие методы HTTP являются идемпотентными, а какие — нет, и как это влияет на разработку веб-приложений.</p>\n\n    <h2>Что такое идемпотентность?</h2>\n    <p>Идемпотентность — это свойство метода HTTP, которое означает, что многократное выполнение одного и того же запроса с одинаковыми параметрами приводит к одному и тому же результату. Иными словами, если метод идемпотентен, то повторные запросы не изменяют состояние сервера после первого успешного выполнения.</p>\n\n    <h2>Идемпотентные методы HTTP</h2>\n    <p>Следующие методы HTTP являются идемпотентными:</p>\n    <ul>\n        <li><strong>GET:</strong> Используется для получения данных с сервера. Многократные GET-запросы к одному и тому же ресурсу не изменяют состояние сервера.</li>\n        <li><strong>HEAD:</strong> Аналогичен GET, но возвращает только заголовки ответа без тела. Также не изменяет состояние сервера.</li>\n        <li><strong>PUT:</strong> Используется для обновления или создания ресурса. Многократные PUT-запросы с одинаковыми данными приводят к одному и тому же состоянию ресурса.</li>\n        <li><strong>DELETE:</strong> Используется для удаления ресурса. После первого успешного DELETE-запроса ресурс удаляется, и последующие запросы не изменяют состояние сервера.</li>\n        <li><strong>OPTIONS:</strong> Используется для получения информации о поддерживаемых методах для ресурса. Не изменяет состояние сервера.</li>\n    </ul>\n\n    <h3>Пример идемпотентного метода (PUT):</h3>\n    <pre><code>PUT /users/1 HTTP/1.1\nContent-Type: application/json\n\n{\n    \"name\": \"John\",\n    \"age\": 30\n}</code></pre>\n    <p>Многократное выполнение этого запроса приведет к тому, что пользователь с ID 1 будет иметь имя \"John\" и возраст 30, независимо от количества выполненных запросов.</p>\n\n    <h2>Неидемпотентные методы HTTP</h2>\n    <p>Следующие методы HTTP не являются идемпотентными:</p>\n    <ul>\n        <li><strong>POST:</strong> Используется для создания нового ресурса или выполнения действий, которые изменяют состояние сервера. Каждый POST-запрос может создавать новый ресурс или изменять состояние сервера по-разному.</li>\n        <li><strong>PATCH:</strong> Используется для частичного обновления ресурса. Многократные PATCH-запросы могут приводить к разным состояниям ресурса в зависимости от содержимого запроса.</li>\n    </ul>\n\n    <h3>Пример неидемпотентного метода (POST):</h3>\n    <pre><code>POST /users HTTP/1.1\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 25\n}</code></pre>\n    <p>Каждый выполненный POST-запрос создаст нового пользователя с именем \"Alice\" и возрастом 25, что приведет к созданию нескольких ресурсов.</p>\n\n    <h2>Почему важно понимать идемпотентность?</h2>\n    <ul>\n        <li><strong>Безопасность:</strong> Идемпотентные методы можно безопасно повторять в случае сбоев сети или сервера, так как они не изменяют состояние сервера после первого успешного выполнения.</li>\n        <li><strong>Кэширование:</strong> Идемпотентные методы, такие как GET, могут быть кэшированы, что повышает производительность приложения.</li>\n        <li><strong>Распределенные системы:</strong> В распределенных системах идемпотентность помогает избежать дублирования операций и обеспечивает согласованность данных.</li>\n    </ul>\n\n    <h2>Примеры использования идемпотентных и неидемпотентных методов</h2>\n    <h3>Идемпотентный метод (GET):</h3>\n    <pre><code>GET /users/1 HTTP/1.1</code></pre>\n    <p>Этот запрос всегда возвращает данные пользователя с ID 1, независимо от количества выполненных запросов.</p>\n\n    <h3>Неидемпотентный метод (POST):</h3>\n    <pre><code>POST /orders HTTP/1.1\nContent-Type: application/json\n\n{\n    \"product\": \"Laptop\",\n    \"quantity\": 1\n}</code></pre>\n    <p>Каждый выполненный POST-запрос создает новый заказ, что приводит к изменению состояния сервера.</p>\n\n    <h2>Заключение</h2>\n    <p>Идемпотентность — это важное свойство методов HTTP, которое помогает разработчикам создавать безопасные и надежные веб-приложения. Идемпотентные методы, такие как GET, PUT и DELETE, можно безопасно повторять, что делает их идеальными для использования в распределенных системах. Неидемпотентные методы, такие как POST и PATCH, требуют осторожности, так как их повторное выполнение может привести к нежелательным изменениям состояния сервера.</p>',14),(161,'Inversion of Control (IoC) и Dependency Injection (DI) в Spring','<h2>Что такое Inversion of Control (IoC)?</h2>\n    <p>\n        <strong>Inversion of Control (IoC)</strong> — это принцип разработки программного обеспечения, при котором управление потоком выполнения программы передается от приложения внешнему фреймворку или контейнеру. Вместо того чтобы приложение само управляло созданием и жизненным циклом объектов, это делает контейнер IoC.\n    </p>\n    <p>\n        В контексте Spring, IoC реализуется через <strong>Spring IoC Container</strong>, который управляет объектами (бинами), их созданием, конфигурацией и связыванием.\n    </p>\n\n    <h2>Что такое Dependency Injection (DI)?</h2>\n    <p>\n        <strong>Dependency Injection (DI)</strong> — это паттерн проектирования, который является реализацией принципа IoC. Он позволяет внедрять зависимости в объекты вместо того, чтобы объекты сами создавали или искали свои зависимости.\n    </p>\n    <p>\n        DI делает код более гибким, тестируемым и поддерживаемым, так как зависимости могут быть легко заменены или изменены без изменения самого класса.\n    </p>\n\n    <h2>Как IoC и DI реализованы в Spring?</h2>\n    <p>\n        В Spring IoC и DI реализуются с помощью <strong>Spring IoC Container</strong>, который состоит из двух основных интерфейсов:\n    </p>\n    <ul>\n        <li>\n            <strong>BeanFactory</strong> — базовый интерфейс, предоставляющий минимальную функциональность для управления бинами.\n        </li>\n        <li>\n            <strong>ApplicationContext</strong> — расширенный интерфейс, который добавляет дополнительные функции, такие как интеграция с AOP, поддержка интернационализации и событийная модель.\n        </li>\n    </ul>\n\n    <h3>Основные способы внедрения зависимостей в Spring:</h3>\n    <ol>\n        <li>\n            <strong>Constructor Injection (Внедрение через конструктор):</strong>\n            <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n        </li>\n        <li>\n            <strong>Setter Injection (Внедрение через сеттер):</strong>\n            <pre><code>@Component\npublic class MyService {\n    private MyRepository repository;\n\n    @Autowired\n    public void setRepository(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n        </li>\n        <li>\n            <strong>Field Injection (Внедрение через поле):</strong>\n            <pre><code>@Component\npublic class MyService {\n    @Autowired\n    private MyRepository repository;\n}</code></pre>\n        </li>\n    </ol>\n\n    <h3>Пример конфигурации с использованием аннотаций:</h3>\n    <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public MyRepository myRepository() {\n        return new MyRepository();\n    }\n\n    @Bean\n    public MyService myService() {\n        return new MyService(myRepository());\n    }\n}</code></pre>\n\n    <h3>Пример конфигурации с использованием XML:</h3>\n    <pre><code>&lt;beans&gt;\n    &lt;bean id=\"myRepository\" class=\"com.example.MyRepository\"/&gt;\n    &lt;bean id=\"myService\" class=\"com.example.MyService\"&gt;\n        &lt;constructor-arg ref=\"myRepository\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n\n    <h2>Преимущества использования IoC и DI в Spring:</h2>\n    <ul>\n        <li>Упрощение тестирования за счет возможности внедрения mock-объектов.</li>\n        <li>Уменьшение связанности (coupling) между компонентами.</li>\n        <li>Гибкость в конфигурации и управлении зависимостями.</li>\n        <li>Упрощение поддержки и расширения приложения.</li>\n    </ul>\n',3),(162,'Типы Dependency Injection в Spring','<p>\n        В Spring Framework существует три основных типа внедрения зависимостей (Dependency Injection, DI). Каждый из них имеет свои особенности и используется в зависимости от требований и предпочтений разработчика.\n    </p>\n\n    <h2>1. Constructor Injection (Внедрение через конструктор)</h2>\n    <p>\n        <strong>Constructor Injection</strong> — это способ внедрения зависимостей через конструктор класса. Этот метод рекомендуется использовать, так как он обеспечивает неизменяемость зависимостей и явно указывает на обязательные зависимости.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Зависимости явно указаны в конструкторе.</li>\n        <li>Объект создается в валидном состоянии (все зависимости инициализированы).</li>\n        <li>Подходит для обязательных зависимостей.</li>\n    </ul>\n\n    <h2>2. Setter Injection (Внедрение через сеттер)</h2>\n    <p>\n        <strong>Setter Injection</strong> — это способ внедрения зависимостей через сеттер-методы. Этот метод используется, когда зависимости являются опциональными или могут изменяться в течение жизненного цикла объекта.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>@Component\npublic class MyService {\n    private MyRepository repository;\n\n    @Autowired\n    public void setRepository(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Гибкость в изменении зависимостей после создания объекта.</li>\n        <li>Подходит для опциональных зависимостей.</li>\n    </ul>\n\n    <h2>3. Field Injection (Внедрение через поле)</h2>\n    <p>\n        <strong>Field Injection</strong> — это способ внедрения зависимостей напрямую в поля класса с использованием аннотации <code>@Autowired</code>. Этот метод наименее предпочтителен, так как он скрывает зависимости и усложняет тестирование.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>@Component\npublic class MyService {\n    @Autowired\n    private MyRepository repository;\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Минимальный объем кода.</li>\n        <li>Простота использования.</li>\n    </ul>\n    <p>\n        <strong>Недостатки:</strong>\n    </p>\n    <ul>\n        <li>Зависимости скрыты и не видны в конструкторе или сеттерах.</li>\n        <li>Сложность тестирования без Spring-контейнера.</li>\n    </ul>\n\n    <h2>Какой тип Dependency Injection выбрать?</h2>\n    <p>\n        Выбор типа DI зависит от конкретной ситуации:\n    </p>\n    <ul>\n        <li>Используйте <strong>Constructor Injection</strong> для обязательных зависимостей.</li>\n        <li>Используйте <strong>Setter Injection</strong> для опциональных или изменяемых зависимостей.</li>\n        <li>Избегайте <strong>Field Injection</strong>, если это возможно, чтобы сохранить явность и тестируемость кода.</li>\n    </ul>\n\n    <h2>Пример использования всех типов DI в одном классе:</h2>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository; // Constructor Injection\n    private MyHelper helper; // Setter Injection\n    @Autowired\n    private MyLogger logger; // Field Injection\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n\n    @Autowired\n    public void setHelper(MyHelper helper) {\n        this.helper = helper;\n    }\n}</code></pre>',3),(163,'Spring ApplicationContext и BeanFactory','<p>\n        <strong>ApplicationContext</strong> — это центральный интерфейс в Spring Framework, который представляет собой контейнер IoC (Inversion of Control). Он отвечает за создание, конфигурацию и управление бинами (объектами) в приложении. ApplicationContext расширяет функциональность <code>BeanFactory</code> и предоставляет дополнительные возможности, такие как поддержка AOP, интернационализация, публикация событий и многое другое.\n    </p>\n\n    <h3>Основные функции ApplicationContext:</h3>\n    <ul>\n        <li>Управление жизненным циклом бинов.</li>\n        <li>Автоматическое связывание зависимостей (Dependency Injection).</li>\n        <li>Поддержка конфигурации через аннотации, XML и Java-код.</li>\n        <li>Публикация и обработка событий (Event Handling).</li>\n        <li>Интеграция с AOP (Aspect-Oriented Programming).</li>\n        <li>Поддержка интернационализации (i18n).</li>\n        <li>Загрузка ресурсов (например, файлов).</li>\n    </ul>\n\n    <h3>Пример создания ApplicationContext:</h3>\n    <pre><code>// Использование аннотаций\nAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// Использование XML-конфигурации\nClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");</code></pre>\n\n    <h2>Что такое BeanFactory?</h2>\n    <p>\n        <strong>BeanFactory</strong> — это базовый интерфейс для управления бинами в Spring. Он предоставляет минимальную функциональность для работы с бинами, включая их создание, конфигурацию и доступ к ним. BeanFactory является основой для <code>ApplicationContext</code>, но не поддерживает дополнительные функции, такие как AOP, события или интернационализация.\n    </p>\n\n    <h3>Основные функции BeanFactory:</h3>\n    <ul>\n        <li>Создание и управление бинами.</li>\n        <li>Внедрение зависимостей (Dependency Injection).</li>\n        <li>Поддержка ленивой инициализации бинов (Lazy Initialization).</li>\n    </ul>\n\n    <h3>Пример использования BeanFactory:</h3>\n    <pre><code>XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"beans.xml\"));\nMyBean myBean = factory.getBean(MyBean.class);</code></pre>\n\n    <h2>Чем ApplicationContext отличается от BeanFactory?</h2>\n    <p>\n        <strong>ApplicationContext</strong> и <strong>BeanFactory</strong> являются контейнерами IoC, но ApplicationContext предоставляет больше возможностей и функциональности. Вот основные различия:\n    </p>\n\n    <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Характеристика</th>\n                <th>BeanFactory</th>\n                <th>ApplicationContext</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><strong>Функциональность</strong></td>\n                <td>Минимальная (только управление бинами и DI).</td>\n                <td>Расширенная (AOP, события, интернационализация и др.).</td>\n            </tr>\n            <tr>\n                <td><strong>Инициализация бинов</strong></td>\n                <td>Ленивая (бины создаются при первом запросе).</td>\n                <td>По умолчанию все бины создаются при запуске (Eager Initialization).</td>\n            </tr>\n            <tr>\n                <td><strong>Поддержка аннотаций</strong></td>\n                <td>Нет.</td>\n                <td>Да (например, <code>@Autowired</code>, <code>@Component</code>).</td>\n            </tr>\n            <tr>\n                <td><strong>Публикация событий</strong></td>\n                <td>Нет.</td>\n                <td>Да (Event Handling).</td>\n            </tr>\n            <tr>\n                <td><strong>Интернационализация (i18n)</strong></td>\n                <td>Нет.</td>\n                <td>Да.</td>\n            </tr>\n            <tr>\n                <td><strong>Интеграция с AOP</strong></td>\n                <td>Нет.</td>\n                <td>Да.</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <h2>Когда использовать BeanFactory?</h2>\n    <p>\n        <strong>BeanFactory</strong> используется в редких случаях, когда требуется минимальная функциональность и ленивая инициализация бинов. Например, в приложениях с ограниченными ресурсами, где важно отложить создание объектов до момента их использования.\n    </p>\n\n    <h2>Когда использовать ApplicationContext?</h2>\n    <p>\n        <strong>ApplicationContext</strong> является стандартным выбором для большинства Spring-приложений. Он предоставляет все необходимые функции для разработки современных приложений, включая поддержку аннотаций, AOP, событий и интернационализации.\n    </p>\n\n    <h2>Пример использования ApplicationContext и BeanFactory:</h2>\n    <pre><code>// Использование ApplicationContext\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\nMyService myService = context.getBean(MyService.class);\n\n// Использование BeanFactory\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"beans.xml\"));\nMyBean myBean = factory.getBean(MyBean.class);</code></pre>',3),(164,'Spring Configuration и способы конфигурации','<h2>Что такое Spring Configuration?</h2>\n    <p>\n        <strong>Spring Configuration</strong> — это процесс настройки и определения бинов (объектов) и их зависимостей в Spring-приложении. Конфигурация позволяет Spring IoC Container управлять созданием и связыванием объектов, а также настраивать их свойства.\n    </p>\n\n    <h2>Способы конфигурации в Spring</h2>\n    <p>\n        В Spring существует несколько способов конфигурации приложения. Основные из них:\n    </p>\n\n    <h3>1. XML-конфигурация</h3>\n    <p>\n        Это классический способ конфигурации, при котором бины и их зависимости описываются в XML-файлах. Этот метод был популярен в ранних версиях Spring, но сейчас используется реже.\n    </p>\n    <h4>Пример XML-конфигурации:</h4>\n    <pre><code>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"myService\" class=\"com.example.MyService\"&gt;\n        &lt;property name=\"repository\" ref=\"myRepository\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=\"myRepository\" class=\"com.example.MyRepository\"/&gt;\n&lt;/beans&gt;</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Централизованная конфигурация.</li>\n        <li>Подходит для legacy-проектов.</li>\n    </ul>\n    <p>\n        <strong>Недостатки:</strong>\n    </p>\n    <ul>\n        <li>Многословность и сложность поддержки.</li>\n        <li>Отсутствие проверки типов на этапе компиляции.</li>\n    </ul>\n\n    <h3>2. Аннотационная конфигурация</h3>\n    <p>\n        Этот способ использует аннотации для настройки бинов и их зависимостей. Он более современный и удобный, чем XML-конфигурация.\n    </p>\n    <h4>Пример аннотационной конфигурации:</h4>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n}\n\n@Repository\npublic class MyRepository {\n    // Реализация репозитория\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Минимальный объем кода.</li>\n        <li>Проверка типов на этапе компиляции.</li>\n        <li>Удобство использования.</li>\n    </ul>\n    <p>\n        <strong>Недостатки:</strong>\n    </p>\n    <ul>\n        <li>Конфигурация распределена по классам.</li>\n        <li>Может быть сложно отследить все зависимости.</li>\n    </ul>\n\n    <h3>3. Java-based конфигурация</h3>\n    <p>\n        Этот способ использует Java-классы для конфигурации бинов. Он сочетает в себе преимущества XML и аннотаций, предоставляя гибкость и удобство.\n    </p>\n    <h4>Пример Java-based конфигурации:</h4>\n    <pre><code>@Configuration\npublic class AppConfig {\n\n    @Bean\n    public MyRepository myRepository() {\n        return new MyRepository();\n    }\n\n    @Bean\n    public MyService myService() {\n        return new MyService(myRepository());\n    }\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Типобезопасность и проверка на этапе компиляции.</li>\n        <li>Гибкость и удобство.</li>\n        <li>Возможность использования условной логики.</li>\n    </ul>\n    <p>\n        <strong>Недостатки:</strong>\n    </p>\n    <ul>\n        <li>Требует написания дополнительных классов.</li>\n    </ul>\n\n    <h3>4. Конфигурация через свойства (Properties)</h3>\n    <p>\n        Spring позволяет настраивать бины и их свойства с использованием файлов свойств (например, <code>application.properties</code> или <code>application.yml</code>). Этот способ часто используется в Spring Boot.\n    </p>\n    <h4>Пример конфигурации через свойства:</h4>\n    <pre><code># application.properties\napp.name=MyApplication\napp.version=1.0.0</code></pre>\n    <p>\n        <strong>Пример использования в коде:</strong>\n    </p>\n    <pre><code>@Component\npublic class AppConfig {\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${app.version}\")\n    private String appVersion;\n\n    // Геттеры и сеттеры\n}</code></pre>\n    <p>\n        <strong>Преимущества:</strong>\n    </p>\n    <ul>\n        <li>Простота и удобство.</li>\n        <li>Поддержка внешней конфигурации.</li>\n    </ul>\n    <p>\n        <strong>Недостатки:</strong>\n    </p>\n    <ul>\n        <li>Ограниченная гибкость для сложных конфигураций.</li>\n    </ul>\n\n    <h2>Какой способ конфигурации выбрать?</h2>\n    <p>\n        Выбор способа конфигурации зависит от требований проекта:\n    </p>\n    <ul>\n        <li>Используйте <strong>XML-конфигурацию</strong> для legacy-проектов или если требуется централизованная конфигурация.</li>\n        <li>Используйте <strong>аннотационную конфигурацию</strong> для современных проектов с минимальной конфигурацией.</li>\n        <li>Используйте <strong>Java-based конфигурацию</strong> для гибкости и типобезопасности.</li>\n        <li>Используйте <strong>конфигурацию через свойства</strong> для настройки параметров приложения.</li>\n    </ul>\n\n    <h2>Пример комбинированной конфигурации:</h2>\n    <pre><code>@Configuration\n@PropertySource(\"classpath:application.properties\")\npublic class AppConfig {\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Bean\n    public MyService myService() {\n        return new MyService(myRepository());\n    }\n\n    @Bean\n    public MyRepository myRepository() {\n        return new MyRepository();\n    }\n}</code></pre>',3),(165,'Spring Profiles и их использование',' <h2>Что такое Spring Profiles?</h2>\n    <p>\n        <strong>Spring Profiles</strong> — это механизм в Spring Framework, который позволяет разделять конфигурацию приложения в зависимости от окружения или условий. С помощью профилей можно активировать различные наборы бинов, конфигураций и свойств для разных сред, таких как разработка, тестирование или производство.\n    </p>\n\n    <h2>Для чего используются Spring Profiles?</h2>\n    <p>\n        Spring Profiles используются для:\n    </p>\n    <ul>\n        <li>Разделения конфигурации для разных сред (development, test, production).</li>\n        <li>Активации или деактивации бинов в зависимости от окружения.</li>\n        <li>Управления настройками приложения через свойства (properties) для разных профилей.</li>\n        <li>Упрощения переключения между конфигурациями без изменения кода.</li>\n    </ul>\n\n    <h2>Как создать и использовать Spring Profiles?</h2>\n\n    <h3>1. Определение профилей</h3>\n    <p>\n        Профили могут быть определены в конфигурационных файлах (XML, Java-based конфигурация) или через аннотации.\n    </p>\n\n    <h4>Пример Java-based конфигурации:</h4>\n    <pre><code>@Configuration\n@Profile(\"development\")\npublic class DevConfig {\n    @Bean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n@Configuration\n@Profile(\"production\")\npublic class ProdConfig {\n    @Bean\n    public DataSource dataSource() {\n        return DataSourceBuilder.create()\n            .url(\"jdbc:mysql://localhost:3306/mydb\")\n            .username(\"root\")\n            .password(\"password\")\n            .build();\n    }\n}</code></pre>\n\n    <h4>Пример XML-конфигурации:</h4>\n    <pre><code>&lt;beans profile=\"development\"&gt;\n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder\"&gt;\n        &lt;property name=\"type\" value=\"H2\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n&lt;beans profile=\"production\"&gt;\n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\n        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/&gt;\n        &lt;property name=\"username\" value=\"root\"/&gt;\n        &lt;property name=\"password\" value=\"password\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n\n    <h3>2. Активация профилей</h3>\n    <p>\n        Профили могут быть активированы несколькими способами:\n    </p>\n\n    <h4>Через свойства (application.properties или application.yml):</h4>\n    <pre><code># application.properties\nspring.profiles.active=development</code></pre>\n\n    <h4>Через переменные окружения:</h4>\n    <pre><code>export SPRING_PROFILES_ACTIVE=production</code></pre>\n\n    <h4>Программно в коде:</h4>\n    <pre><code>SpringApplication application = new SpringApplication(MyApp.class);\napplication.setAdditionalProfiles(\"production\");\napplication.run(args);</code></pre>\n\n    <h3>3. Использование профилей в свойствах</h3>\n    <p>\n        Spring позволяет определять свойства для конкретных профилей. Например, можно создать отдельные файлы <code>application-dev.properties</code> и <code>application-prod.properties</code>.\n    </p>\n\n    <h4>Пример:</h4>\n    <pre><code># application-dev.properties\napp.name=MyApp (Development)\napp.url=http://localhost:8080\n\n# application-prod.properties\napp.name=MyApp (Production)\napp.url=https://myapp.com</code></pre>\n\n    <h2>Пример использования профилей</h2>\n    <p>\n        Предположим, у нас есть приложение, которое использует разные базы данных для разработки и производства.\n    </p>\n\n    <h3>Конфигурация для разработки (development):</h3>\n    <pre><code>@Configuration\n@Profile(\"development\")\npublic class DevConfig {\n    @Bean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}</code></pre>\n\n    <h3>Конфигурация для производства (production):</h3>\n    <pre><code>@Configuration\n@Profile(\"production\")\npublic class ProdConfig {\n    @Bean\n    public DataSource dataSource() {\n        return DataSourceBuilder.create()\n            .url(\"jdbc:mysql://localhost:3306/mydb\")\n            .username(\"root\")\n            .password(\"password\")\n            .build();\n    }\n}</code></pre>\n\n    <h3>Активация профиля:</h3>\n    <pre><code># application.properties\nspring.profiles.active=development</code></pre>\n\n    <h2>Преимущества использования Spring Profiles</h2>\n    <ul>\n        <li>Упрощение управления конфигурацией для разных сред.</li>\n        <li>Возможность использования разных настроек и бинов в зависимости от окружения.</li>\n        <li>Гибкость и удобство при развертывании приложения.</li>\n    </ul>\n',3),(166,'Аннотация @Autowired и способы автоматического связывания','<h2>Что такое аннотация @Autowired?</h2>\n    <p>\n        <strong>@Autowired</strong> — это аннотация в Spring Framework, которая используется для автоматического связывания (autowiring) зависимостей. Она позволяет Spring IoC Container внедрять зависимости в поля, конструкторы или методы без явного указания их в конфигурации.\n    </p>\n\n    <h2>Как работает @Autowired?</h2>\n    <p>\n        Когда Spring встречает аннотацию <code>@Autowired</code>, он пытается найти подходящий бин (объект) в контейнере и внедрить его в указанное поле, конструктор или метод. Если подходящий бин не найден, Spring выбрасывает исключение, если не указано иное.\n    </p>\n\n    <h3>Пример использования @Autowired:</h3>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n}\n\n@Repository\npublic class MyRepository {\n    // Реализация репозитория\n}</code></pre>\n\n    <h2>Способы автоматического связывания (autowiring)</h2>\n    <p>\n        В Spring существует несколько способов автоматического связывания зависимостей:\n    </p>\n\n    <h3>1. Constructor Injection (Внедрение через конструктор)</h3>\n    <p>\n        Зависимости внедряются через конструктор класса. Это рекомендуемый способ, так как он обеспечивает неизменяемость зависимостей и явно указывает на обязательные зависимости.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n\n    <h3>2. Setter Injection (Внедрение через сеттер)</h3>\n    <p>\n        Зависимости внедряются через сеттер-методы. Этот способ используется, когда зависимости являются опциональными или могут изменяться в течение жизненного цикла объекта.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyService {\n    private MyRepository repository;\n\n    @Autowired\n    public void setRepository(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n\n    <h3>3. Field Injection (Внедрение через поле)</h3>\n    <p>\n        Зависимости внедряются напрямую в поля класса. Этот способ наименее предпочтителен, так как он скрывает зависимости и усложняет тестирование.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyService {\n    @Autowired\n    private MyRepository repository;\n}</code></pre>\n\n    <h3>4. Method Injection (Внедрение через метод)</h3>\n    <p>\n        Зависимости внедряются через произвольные методы. Этот способ используется реже, но может быть полезен в некоторых случаях.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyService {\n    private MyRepository repository;\n\n    @Autowired\n    public void configureRepository(MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n\n    <h2>Типы автоматического связывания (autowiring modes)</h2>\n    <p>\n        В Spring существует несколько режимов автоматического связывания, которые можно указать в XML-конфигурации:\n    </p>\n\n    <ul>\n        <li>\n            <strong>no</strong> — автоматическое связывание отключено. Зависимости должны быть указаны явно.\n        </li>\n        <li>\n            <strong>byName</strong> — Spring ищет бин с именем, соответствующим имени свойства.\n        </li>\n        <li>\n            <strong>byType</strong> — Spring ищет бин, тип которого соответствует типу свойства. Если найдено несколько бинов, выбрасывается исключение.\n        </li>\n        <li>\n            <strong>constructor</strong> — Spring пытается связать зависимости через конструктор.\n        </li>\n    </ul>\n\n    <h2>Пример использования разных типов autowiring в XML:</h2>\n    <pre><code>&lt;bean id=\"myService\" class=\"com.example.MyService\" autowire=\"byType\"/&gt;\n&lt;bean id=\"myRepository\" class=\"com.example.MyRepository\"/&gt;</code></pre>\n\n    <h2>Как работает @Autowired с несколькими бинами одного типа?</h2>\n    <p>\n        Если в контейнере Spring найдено несколько бинов одного типа, Spring выбрасывает исключение <code>NoUniqueBeanDefinitionException</code>. Чтобы решить эту проблему, можно использовать аннотацию <code>@Qualifier</code> для указания конкретного бина.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyService {\n    private final MyRepository repository;\n\n    @Autowired\n    public MyService(@Qualifier(\"myRepositoryImpl\") MyRepository repository) {\n        this.repository = repository;\n    }\n}</code></pre>\n\n    <h2>Преимущества использования @Autowired</h2>\n    <ul>\n        <li>Упрощение конфигурации за счет автоматического связывания зависимостей.</li>\n        <li>Минимальный объем кода.</li>\n        <li>Гибкость в выборе способа внедрения зависимостей.</li>\n    </ul>\n\n    <h2>Недостатки использования @Autowired</h2>\n    <ul>\n        <li>Скрытость зависимостей при использовании Field Injection.</li>\n        <li>Сложность тестирования без Spring-контейнера.</li>\n        <li>Возможность возникновения ошибок, если подходящий бин не найден.</li>\n    </ul>\n',3),(167,'Аннотации @Component, @Service, @Repository, @Controller','<h2>Что такое @Component, @Service, @Repository, @Controller?</h2>\n    <p>\n        В Spring Framework аннотации <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> и <code>@Controller</code> используются для обозначения классов как Spring-бинов. Эти аннотации позволяют Spring IoC Container автоматически обнаруживать и регистрировать бины в контексте приложения.\n    </p>\n\n    <h2>Основные различия</h2>\n    <p>\n        Хотя все эти аннотации выполняют одну и ту же основную функцию (регистрация бинов), они используются для разных слоев приложения и имеют семантические различия. Это помогает лучше структурировать код и делает его более читаемым.\n    </p>\n\n    <h3>1. @Component</h3>\n    <p>\n        <strong>@Component</strong> — это базовая аннотация, которая указывает, что класс является Spring-бином. Она используется для любых компонентов, которые не относятся к конкретным слоям приложения (например, сервисы, репозитории, контроллеры).\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\npublic class MyComponent {\n    // Логика компонента\n}</code></pre>\n    <p>\n        <strong>Использование:</strong> Универсальная аннотация для любых бинов.\n    </p>\n\n    <h3>2. @Service</h3>\n    <p>\n        <strong>@Service</strong> — это специализированная версия аннотации <code>@Component</code>, которая используется для обозначения классов, содержащих бизнес-логику или сервисный слой приложения.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Service\npublic class MyService {\n    // Бизнес-логика\n}</code></pre>\n    <p>\n        <strong>Использование:</strong> Классы, реализующие бизнес-логику.\n    </p>\n\n    <h3>3. @Repository</h3>\n    <p>\n        <strong>@Repository</strong> — это специализированная версия аннотации <code>@Component</code>, которая используется для классов, работающих с данными (например, DAO или репозитории). Эта аннотация также автоматически перехватывает исключения, связанные с доступом к данным, и преобразует их в Spring-исключения.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Repository\npublic class MyRepository {\n    // Логика доступа к данным\n}</code></pre>\n    <p>\n        <strong>Использование:</strong> Классы, работающие с базами данных или другими источниками данных.\n    </p>\n\n    <h3>4. @Controller</h3>\n    <p>\n        <strong>@Controller</strong> — это специализированная версия аннотации <code>@Component</code>, которая используется для классов, представляющих слой контроллера в веб-приложениях. Обычно такие классы обрабатывают HTTP-запросы и возвращают ответы.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Controller\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String sayHello() {\n        return \"hello\";\n    }\n}</code></pre>\n    <p>\n        <strong>Использование:</strong> Классы, обрабатывающие HTTP-запросы.\n    </p>\n\n    <h2>Сравнение аннотаций</h2>\n    <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Аннотация</th>\n                <th>Назначение</th>\n                <th>Использование</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><code>@Component</code></td>\n                <td>Универсальная аннотация для любых бинов.</td>\n                <td>Любые компоненты, не относящиеся к конкретным слоям.</td>\n            </tr>\n            <tr>\n                <td><code>@Service</code></td>\n                <td>Классы, содержащие бизнес-логику.</td>\n                <td>Сервисный слой приложения.</td>\n            </tr>\n            <tr>\n                <td><code>@Repository</code></td>\n                <td>Классы, работающие с данными.</td>\n                <td>Доступ к базам данных или другим источникам данных.</td>\n            </tr>\n            <tr>\n                <td><code>@Controller</code></td>\n                <td>Классы, обрабатывающие HTTP-запросы.</td>\n                <td>Веб-контроллеры.</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <h2>Почему важно использовать специализированные аннотации?</h2>\n    <p>\n        Использование специализированных аннотаций (<code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>) вместо универсальной <code>@Component</code> имеет несколько преимуществ:\n    </p>\n    <ul>\n        <li><strong>Семантическая ясность:</strong> Код становится более читаемым и понятным, так как аннотации указывают на роль класса в приложении.</li>\n        <li><strong>Дополнительные возможности:</strong> Например, <code>@Repository</code> автоматически перехватывает исключения, связанные с доступом к данным.</li>\n        <li><strong>Упрощение настройки:</strong> Spring может автоматически применять специфические настройки для классов с определенными аннотациями.</li>\n    </ul>\n\n    <h2>Пример использования всех аннотаций в одном приложении</h2>\n    <pre><code>@Controller\npublic class MyController {\n    private final MyService myService;\n\n    @Autowired\n    public MyController(MyService myService) {\n        this.myService = myService;\n    }\n\n    @GetMapping(\"/data\")\n    public String getData() {\n        return myService.fetchData();\n    }\n}\n\n@Service\npublic class MyService {\n    private final MyRepository myRepository;\n\n    @Autowired\n    public MyService(MyRepository myRepository) {\n        this.myRepository = myRepository;\n    }\n\n    public String fetchData() {\n        return myRepository.getData();\n    }\n}\n\n@Repository\npublic class MyRepository {\n    public String getData() {\n        return \"Data from repository\";\n    }\n}</code></pre>',3),(168,'Автоконфигурация (Auto-Configuration) в Spring Boot','<h2>Что такое автоконфигурация в Spring Boot?</h2>\n    <p>\n        <strong>Автоконфигурация (Auto-Configuration)</strong> — это одна из ключевых особенностей Spring Boot, которая автоматически настраивает приложение на основе зависимостей, добавленных в проект. Она позволяет разработчикам быстро создавать приложения, минимизируя ручную настройку.\n    </p>\n    <p>\n        Spring Boot анализирует классы в classpath и автоматически настраивает бины, необходимые для работы приложения. Например, если в проекте есть зависимость <code>spring-boot-starter-data-jpa</code>, Spring Boot автоматически настроит DataSource, EntityManager и другие компоненты, связанные с JPA.\n    </p>\n\n    <h2>Как работает автоконфигурация?</h2>\n    <p>\n        Автоконфигурация в Spring Boot работает на основе следующих механизмов:\n    </p>\n\n    <h3>1. Файлы <code>spring.factories</code></h3>\n    <p>\n        Spring Boot использует файлы <code>spring.factories</code>, которые находятся в библиотеках. Эти файлы содержат список классов автоконфигурации, которые должны быть применены при запуске приложения.\n    </p>\n    <h4>Пример содержимого <code>spring.factories</code>:</h4>\n    <pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.MyAutoConfiguration</code></pre>\n\n    <h3>2. Аннотация <code>@EnableAutoConfiguration</code></h3>\n    <p>\n        Аннотация <code>@EnableAutoConfiguration</code> (которая включена в <code>@SpringBootApplication</code>) активирует механизм автоконфигурации. Она сканирует classpath и применяет соответствующие конфигурации.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}</code></pre>\n\n    <h3>3. Условная логика с аннотациями <code>@Conditional</code></h3>\n    <p>\n        Spring Boot использует условные аннотации, такие как <code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code>, <code>@ConditionalOnProperty</code>, чтобы определить, должна ли применяться конкретная автоконфигурация.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Configuration\n@ConditionalOnClass(DataSource.class)\npublic class DataSourceAutoConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}</code></pre>\n\n    <h2>Как создается автоконфигурация?</h2>\n    <p>\n        Автоконфигурация создается с помощью классов, помеченных аннотацией <code>@Configuration</code>, и условных аннотаций. Эти классы определяют, какие бины должны быть созданы при определенных условиях.\n    </p>\n\n    <h3>Пример автоконфигурации:</h3>\n    <pre><code>@Configuration\n@ConditionalOnClass(MyService.class)\npublic class MyAutoConfiguration {\n\n    @Bean\n    @ConditionalOnMissingBean\n    public MyService myService() {\n        return new MyService();\n    }\n}</code></pre>\n    <p>\n        В этом примере бин <code>MyService</code> будет создан только в том случае, если класс <code>MyService</code> присутствует в classpath и если бин <code>MyService</code> еще не был создан вручную.\n    </p>\n\n    <h2>Как отключить автоконфигурацию?</h2>\n    <p>\n        Иногда может потребоваться отключить определенные автоконфигурации. Это можно сделать с помощью свойства <code>spring.autoconfigure.exclude</code> в файле <code>application.properties</code> или <code>application.yml</code>.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code># application.properties\nspring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code></pre>\n\n    <h2>Преимущества автоконфигурации</h2>\n    <ul>\n        <li><strong>Минимальная конфигурация:</strong> Spring Boot автоматически настраивает приложение, что позволяет быстро начать разработку.</li>\n        <li><strong>Гибкость:</strong> Автоконфигурацию можно переопределить или отключить, если это необходимо.</li>\n        <li><strong>Соглашения по конфигурации:</strong> Spring Boot использует \"opinionated defaults\" (разумные настройки по умолчанию), что упрощает разработку.</li>\n    </ul>\n\n    <h2>Недостатки автоконфигурации</h2>\n    <ul>\n        <li><strong>Сложность отладки:</strong> Автоконфигурация может быть сложной для понимания, если что-то идет не так.</li>\n        <li><strong>Ограниченная гибкость:</strong> В некоторых случаях автоматические настройки могут не подходить для специфических требований.</li>\n    </ul>\n\n    <h2>Пример работы автоконфигурации</h2>\n    <p>\n        Предположим, у нас есть зависимость <code>spring-boot-starter-data-jpa</code> в проекте. Spring Boot автоматически настроит следующие компоненты:\n    </p>\n    <ul>\n        <li><strong>DataSource:</strong> Если в classpath есть H2, Spring Boot создаст встроенную базу данных H2.</li>\n        <li><strong>EntityManager:</strong> Автоматически настраивается JPA EntityManager.</li>\n        <li><strong>TransactionManager:</strong> Настраивается менеджер транзакций.</li>\n    </ul>\n\n    <h3>Пример автоматической настройки DataSource:</h3>\n    <pre><code>@Configuration\n@ConditionalOnClass(DataSource.class)\npublic class DataSourceAutoConfiguration {\n\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}</code></pre>',3),(169,'application.properties и application.yml в Spring Boot','<h2>Что такое application.properties и application.yml?</h2>\n    <p>\n        <strong>application.properties</strong> и <strong>application.yml</strong> — это файлы конфигурации, используемые в Spring Boot для настройки параметров приложения. Они позволяют задавать свойства, такие как настройки базы данных, порт сервера, параметры логирования и многое другое.\n    </p>\n\n    <h3>Основные различия:</h3>\n    <ul>\n        <li><strong>application.properties</strong> — текстовый файл, где свойства задаются в формате <code>key=value</code>.</li>\n        <li><strong>application.yml</strong> — файл в формате YAML (YAML Ain\'t Markup Language), который использует структуру с отступами для представления данных.</li>\n    </ul>\n\n    <h2>Формат application.properties</h2>\n    <p>\n        Файл <code>application.properties</code> использует простой формат <code>key=value</code>. Каждая строка содержит одно свойство.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code># Настройки сервера\nserver.port=8080\nserver.servlet.context-path=/myapp\n\n# Настройки базы данных\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=secret\n\n# Логирование\nlogging.level.org.springframework=INFO\nlogging.level.com.example=DEBUG</code></pre>\n\n    <h2>Формат application.yml</h2>\n    <p>\n        Файл <code>application.yml</code> использует формат YAML, который более читабелен и поддерживает вложенные структуры. Отступы играют важную роль в определении структуры данных.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code># Настройки сервера\nserver:\n  port: 8080\n  servlet:\n    context-path: /myapp\n\n# Настройки базы данных\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: secret\n\n# Логирование\nlogging:\n  level:\n    org.springframework: INFO\n    com.example: DEBUG</code></pre>\n\n    <h2>Как используются application.properties и application.yml?</h2>\n    <p>\n        Spring Boot автоматически загружает файлы <code>application.properties</code> или <code>application.yml</code> из следующих мест:\n    </p>\n    <ul>\n        <li>Корневой каталог classpath (обычно <code>src/main/resources</code>).</li>\n        <li>Текущий каталог, где запускается приложение.</li>\n        <li>Каталог <code>config</code> внутри текущего каталога.</li>\n        <li>Каталог <code>config</code> в корне classpath.</li>\n    </ul>\n\n    <h3>Приоритет загрузки:</h3>\n    <p>\n        Если файлы конфигурации находятся в нескольких местах, Spring Boot использует следующий порядок приоритета (от высшего к низшему):\n    </p>\n    <ol>\n        <li>Каталог <code>config</code> в текущем каталоге.</li>\n        <li>Текущий каталог.</li>\n        <li>Каталог <code>config</code> в classpath.</li>\n        <li>Корневой каталог classpath.</li>\n    </ol>\n\n    <h2>Пример использования свойств в коде</h2>\n    <p>\n        Свойства из <code>application.properties</code> или <code>application.yml</code> можно использовать в коде с помощью аннотации <code>@Value</code> или через <code>@ConfigurationProperties</code>.\n    </p>\n\n    <h3>Использование <code>@Value</code>:</h3>\n    <pre><code>@Component\npublic class MyComponent {\n\n    @Value(\"${server.port}\")\n    private int serverPort;\n\n    @Value(\"${spring.datasource.username}\")\n    private String dbUsername;\n\n    public void printConfig() {\n        System.out.println(\"Server Port: \" + serverPort);\n        System.out.println(\"DB Username: \" + dbUsername);\n    }\n}</code></pre>\n\n    <h3>Использование <code>@ConfigurationProperties</code>:</h3>\n    <pre><code>@Component\n@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceConfig {\n\n    private String url;\n    private String username;\n    private String password;\n\n    // Геттеры и сеттеры\n\n    public void printConfig() {\n        System.out.println(\"URL: \" + url);\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}</code></pre>\n\n    <h2>Профили в application.properties и application.yml</h2>\n    <p>\n        Spring Boot поддерживает профили, которые позволяют настраивать приложение для разных сред (например, development, production). Для этого используются файлы с именами <code>application-{profile}.properties</code> или <code>application-{profile}.yml</code>.\n    </p>\n\n    <h3>Пример для development профиля:</h3>\n    <pre><code># application-dev.properties\nserver.port=8081\nspring.datasource.url=jdbc:h2:mem:devdb</code></pre>\n\n    <h3>Пример для production профиля:</h3>\n    <pre><code># application-prod.properties\nserver.port=8080\nspring.datasource.url=jdbc:mysql://localhost:3306/proddb</code></pre>\n\n    <h3>Активация профиля:</h3>\n    <p>\n        Профиль можно активировать через свойство <code>spring.profiles.active</code>:\n    </p>\n    <pre><code># application.properties\nspring.profiles.active=dev</code></pre>\n\n    <h2>Преимущества и недостатки</h2>\n    <h3>Преимущества:</h3>\n    <ul>\n        <li><strong>Простота:</strong> Легко настраивать приложение без изменения кода.</li>\n        <li><strong>Гибкость:</strong> Поддержка профилей позволяет адаптировать приложение для разных сред.</li>\n        <li><strong>Читаемость:</strong> Формат YAML более удобен для сложных структур.</li>\n    </ul>\n\n    <h3>Недостатки:</h3>\n    <ul>\n        <li><strong>Ошибки в формате:</strong> В YAML важно соблюдать отступы, иначе файл не будет работать.</li>\n        <li><strong>Переопределение:</strong> Если свойства заданы в нескольких местах, это может привести к путанице.</li>\n    </ul>',3),(170,'Переопределение настроек Spring Boot','<h2>Как можно переопределить настройки Spring Boot?</h2>\n    <p>\n        Spring Boot предоставляет несколько способов переопределения настроек приложения. Это позволяет гибко настраивать приложение для разных сред (development, production) или в зависимости от внешних условий.\n    </p>\n\n    <h2>Способы переопределения настроек</h2>\n\n    <h3>1. Использование файлов конфигурации</h3>\n    <p>\n        Spring Boot автоматически загружает настройки из файлов <code>application.properties</code> или <code>application.yml</code>, расположенных в различных местах. Настройки из файлов с более высоким приоритетом переопределяют настройки из файлов с более низким приоритетом.\n    </p>\n    <h4>Порядок загрузки файлов конфигурации (от высшего к низшему приоритету):</h4>\n    <ol>\n        <li>Каталог <code>config</code> в текущем каталоге.</li>\n        <li>Текущий каталог.</li>\n        <li>Каталог <code>config</code> в classpath.</li>\n        <li>Корневой каталог classpath.</li>\n    </ol>\n\n    <h3>2. Использование профилей</h3>\n    <p>\n        Spring Boot поддерживает профили, которые позволяют настраивать приложение для разных сред. Для этого используются файлы с именами <code>application-{profile}.properties</code> или <code>application-{profile}.yml</code>.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code># application-dev.properties\nserver.port=8081\nspring.datasource.url=jdbc:h2:mem:devdb\n\n# application-prod.properties\nserver.port=8080\nspring.datasource.url=jdbc:mysql://localhost:3306/proddb</code></pre>\n    <p>\n        Профиль можно активировать через свойство <code>spring.profiles.active</code>:\n    </p>\n    <pre><code># application.properties\nspring.profiles.active=dev</code></pre>\n\n    <h3>3. Использование переменных окружения</h3>\n    <p>\n        Настройки Spring Boot можно переопределить с помощью переменных окружения. Это особенно полезно при развертывании приложения в облачных средах или контейнерах.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>export SPRING_DATASOURCE_URL=jdbc:mysql://localhost:3306/mydb\nexport SPRING_DATASOURCE_USERNAME=root\nexport SPRING_DATASOURCE_PASSWORD=secret</code></pre>\n\n    <h3>4. Использование аргументов командной строки</h3>\n    <p>\n        Настройки можно переопределить, передавая аргументы командной строки при запуске приложения.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>java -jar myapp.jar --server.port=8081 --spring.datasource.url=jdbc:h2:mem:testdb</code></pre>\n\n    <h3>5. Использование внешних файлов конфигурации</h3>\n    <p>\n        Spring Boot позволяет загружать настройки из внешних файлов конфигурации, указанных через свойство <code>spring.config.location</code>.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>java -jar myapp.jar --spring.config.location=file:/path/to/config/</code></pre>\n\n    <h3>6. Использование аннотации <code>@PropertySource</code></h3>\n    <p>\n        Аннотация <code>@PropertySource</code> позволяет загружать настройки из пользовательских файлов свойств.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Configuration\n@PropertySource(\"classpath:custom.properties\")\npublic class CustomConfig {\n    @Value(\"${custom.property}\")\n    private String customProperty;\n\n    // Геттеры и сеттеры\n}</code></pre>\n\n    <h3>7. Использование <code>@ConfigurationProperties</code></h3>\n    <p>\n        Аннотация <code>@ConfigurationProperties</code> позволяет связывать свойства из файлов конфигурации с полями класса.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@Component\n@ConfigurationProperties(prefix = \"app\")\npublic class AppConfig {\n    private String name;\n    private String version;\n\n    // Геттеры и сеттеры\n}</code></pre>\n\n    <h2>Пример переопределения настроек</h2>\n    <p>\n        Предположим, у нас есть приложение, которое использует разные настройки для development и production сред.\n    </p>\n\n    <h3>Файл <code>application-dev.properties</code>:</h3>\n    <pre><code>server.port=8081\nspring.datasource.url=jdbc:h2:mem:devdb</code></pre>\n\n    <h3>Файл <code>application-prod.properties</code>:</h3>\n    <pre><code>server.port=8080\nspring.datasource.url=jdbc:mysql://localhost:3306/proddb</code></pre>\n\n    <h3>Активация профиля через переменную окружения:</h3>\n    <pre><code>export SPRING_PROFILES_ACTIVE=prod</code></pre>\n\n    <h3>Активация профиля через аргумент командной строки:</h3>\n    <pre><code>java -jar myapp.jar --spring.profiles.active=prod</code></pre>\n\n    <h2>Преимущества переопределения настроек</h2>\n    <ul>\n        <li><strong>Гибкость:</strong> Возможность адаптировать приложение для разных сред.</li>\n        <li><strong>Удобство:</strong> Настройки можно изменять без изменения кода.</li>\n        <li><strong>Безопасность:</strong> Конфиденциальные данные (например, пароли) можно хранить в переменных окружения.</li>\n    </ul>\n\n    <h2>Недостатки переопределения настроек</h2>\n    <ul>\n        <li><strong>Сложность управления:</strong> Множество источников настроек может привести к путанице.</li>\n        <li><strong>Ошибки:</strong> Неправильное указание приоритетов может привести к неожиданным результатам.</li>\n    </ul>\n',3),(171,'Spring Boot Starter и примеры',' <h2>Что такое Spring Boot Starter?</h2>\n    <p>\n        <strong>Spring Boot Starter</strong> — это специальные зависимости, которые упрощают настройку и использование различных технологий в Spring Boot-приложениях. Каждый стартер предоставляет набор зависимостей, необходимых для работы с определенной технологией (например, базы данных, веб-приложения, безопасность и т.д.).\n    </p>\n    <p>\n        Стартеры позволяют разработчикам быстро подключать функциональность, не заботясь о ручном добавлении всех необходимых зависимостей и их совместимости.\n    </p>\n\n    <h2>Как работают Spring Boot Starter?</h2>\n    <p>\n        Каждый стартер представляет собой Maven- или Gradle-зависимость, которая включает в себя:\n    </p>\n    <ul>\n        <li>Основные библиотеки для работы с технологией.</li>\n        <li>Автоконфигурации, которые автоматически настраивают приложение.</li>\n        <li>Дополнительные зависимости, необходимые для работы.</li>\n    </ul>\n    <p>\n        Например, если вы добавляете стартер для работы с базой данных, Spring Boot автоматически настроит DataSource, подключится к базе данных и предоставит необходимые бины.\n    </p>\n\n    <h2>Примеры Spring Boot Starter</h2>\n\n    <h3>1. <code>spring-boot-starter-web</code></h3>\n    <p>\n        Стартер для создания веб-приложений с использованием Spring MVC. Включает в себя зависимости для работы с Tomcat, Spring Web и JSON.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>2. <code>spring-boot-starter-data-jpa</code></h3>\n    <p>\n        Стартер для работы с JPA (Java Persistence API) и базами данных. Включает в себя зависимости для Hibernate, Spring Data JPA и JDBC.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>3. <code>spring-boot-starter-security</code></h3>\n    <p>\n        Стартер для добавления безопасности в приложение. Включает в себя зависимости для Spring Security, аутентификации и авторизации.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>4. <code>spring-boot-starter-thymeleaf</code></h3>\n    <p>\n        Стартер для использования Thymeleaf в качестве шаблонизатора для веб-приложений. Включает в себя зависимости для Thymeleaf и Spring Web.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>5. <code>spring-boot-starter-test</code></h3>\n    <p>\n        Стартер для тестирования Spring Boot-приложений. Включает в себя зависимости для JUnit, Mockito, Spring Test и других библиотек для тестирования.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>6. <code>spring-boot-starter-actuator</code></h3>\n    <p>\n        Стартер для добавления мониторинга и управления приложением через HTTP-эндпоинты. Включает в себя зависимости для Spring Boot Actuator.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>7. <code>spring-boot-starter-data-mongodb</code></h3>\n    <p>\n        Стартер для работы с MongoDB. Включает в себя зависимости для Spring Data MongoDB и драйвер MongoDB.\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h3>8. <code>spring-boot-starter-cache</code></h3>\n    <p>\n        Стартер для добавления поддержки кэширования в приложение. Включает в себя зависимости для Spring Cache и различные реализации кэша (например, EhCache, Caffeine).\n    </p>\n    <h4>Пример использования в Maven:</h4>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h2>Преимущества использования Spring Boot Starter</h2>\n    <ul>\n        <li><strong>Упрощение конфигурации:</strong> Стартеры автоматически настраивают приложение.</li>\n        <li><strong>Совместимость:</strong> Все зависимости в стартере уже протестированы на совместимость.</li>\n        <li><strong>Быстрый старт:</strong> Позволяют быстро добавить функциональность в приложение.</li>\n        <li><strong>Гибкость:</strong> Можно комбинировать несколько стартеров для создания сложных приложений.</li>\n    </ul>\n\n    <h2>Недостатки использования Spring Boot Starter</h2>\n    <ul>\n        <li><strong>Избыточность:</strong> Некоторые стартеры могут включать ненужные зависимости.</li>\n        <li><strong>Ограниченная кастомизация:</strong> Автоконфигурации могут не подходить для специфических требований.</li>\n    </ul>',3),(172,'Создание REST API с помощью Spring Boot',' <h2>Что такое REST API?</h2>\n    <p>\n        <strong>REST API</strong> (Representational State Transfer Application Programming Interface) — это архитектурный стиль для создания веб-сервисов, который использует HTTP-методы (GET, POST, PUT, DELETE и др.) для взаимодействия с ресурсами. REST API широко используется для создания веб-приложений и мобильных приложений.\n    </p>\n\n    <h2>Как создать REST API с помощью Spring Boot?</h2>\n    <p>\n        Spring Boot упрощает создание REST API благодаря встроенной поддержке Spring MVC и аннотациям, которые позволяют быстро создавать контроллеры и методы для обработки HTTP-запросов.\n    </p>\n\n    <h3>Шаги для создания REST API:</h3>\n    <ol>\n        <li>Создать Spring Boot-приложение.</li>\n        <li>Добавить зависимости для Spring Web.</li>\n        <li>Создать модель данных (Entity).</li>\n        <li>Создать репозиторий для работы с данными.</li>\n        <li>Создать контроллер для обработки HTTP-запросов.</li>\n        <li>Настроить приложение (опционально).</li>\n    </ol>\n\n    <h2>1. Создание Spring Boot-приложения</h2>\n    <p>\n        Используйте <a href=\"https://start.spring.io/\" target=\"_blank\">Spring Initializr</a> для создания нового проекта. Выберите зависимости:\n    </p>\n    <ul>\n        <li><strong>Spring Web</strong> — для создания REST API.</li>\n        <li><strong>Spring Data JPA</strong> — для работы с базой данных (опционально).</li>\n        <li><strong>H2 Database</strong> — для встроенной базы данных (опционально).</li>\n    </ul>\n\n    <h2>2. Добавление зависимостей</h2>\n    <p>\n        Если вы создаете проект вручную, добавьте следующие зависимости в <code>pom.xml</code> (для Maven) или <code>build.gradle</code> (для Gradle).\n    </p>\n    <h3>Пример для Maven:</h3>\n    <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n\n    <h2>3. Создание модели данных (Entity)</h2>\n    <p>\n        Создайте класс, который будет представлять модель данных. Например, класс <code>Product</code> для товаров.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>package com.example.demo;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\n\n@Entity\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private double price;\n\n    // Геттеры и сеттеры\n}</code></pre>\n\n    <h2>4. Создание репозитория</h2>\n    <p>\n        Создайте интерфейс репозитория для работы с данными. Spring Data JPA автоматически предоставит реализацию.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>package com.example.demo;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n}</code></pre>\n\n    <h2>5. Создание контроллера</h2>\n    <p>\n        Создайте контроллер, который будет обрабатывать HTTP-запросы и возвращать данные.\n    </p>\n    <h3>Пример:</h3>\n    <pre><code>package com.example.demo;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @GetMapping\n    public List&lt;Product&gt; getAllProducts() {\n        return productRepository.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public Product getProductById(@PathVariable Long id) {\n        return productRepository.findById(id).orElseThrow(() -> new RuntimeException(\"Product not found\"));\n    }\n\n    @PostMapping\n    public Product createProduct(@RequestBody Product product) {\n        return productRepository.save(product);\n    }\n\n    @PutMapping(\"/{id}\")\n    public Product updateProduct(@PathVariable Long id, @RequestBody Product productDetails) {\n        Product product = productRepository.findById(id).orElseThrow(() -> new RuntimeException(\"Product not found\"));\n        product.setName(productDetails.getName());\n        product.setPrice(productDetails.getPrice());\n        return productRepository.save(product);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void deleteProduct(@PathVariable Long id) {\n        productRepository.deleteById(id);\n    }\n}</code></pre>\n\n    <h2>6. Настройка приложения (опционально)</h2>\n    <p>\n        Настройте приложение через файл <code>application.properties</code> или <code>application.yml</code>. Например, можно настроить порт сервера или подключение к базе данных.\n    </p>\n    <h3>Пример <code>application.properties</code>:</h3>\n    <pre><code>server.port=8080\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.driverClassName=org.h2.Driver\nspring.datasource.username=sa\nspring.datasource.password=password\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.h2.console.enabled=true</code></pre>\n\n    <h2>Пример работы REST API</h2>\n    <p>\n        После запуска приложения вы можете использовать следующие HTTP-запросы:\n    </p>\n    <ul>\n        <li><strong>GET /api/products</strong> — получить список всех товаров.</li>\n        <li><strong>GET /api/products/{id}</strong> — получить товар по ID.</li>\n        <li><strong>POST /api/products</strong> — создать новый товар.</li>\n        <li><strong>PUT /api/products/{id}</strong> — обновить товар по ID.</li>\n        <li><strong>DELETE /api/products/{id}</strong> — удалить товар по ID.</li>\n    </ul>\n\n    <h2>Преимущества использования Spring Boot для создания REST API</h2>\n    <ul>\n        <li><strong>Простота:</strong> Минимальная конфигурация и встроенные зависимости.</li>\n        <li><strong>Гибкость:</strong> Поддержка различных баз данных и технологий.</li>\n        <li><strong>Масштабируемость:</strong> Легко добавлять новые функции и расширять API.</li>\n        <li><strong>Интеграция:</strong> Поддержка Spring Security, Spring Data и других модулей.</li>\n    </ul>',3),(173,'Аннотация @SpringBootApplication',' <p>\n        <strong>@SpringBootApplication</strong> — это основная аннотация, которая используется для запуска Spring Boot-приложения. Она объединяет в себе несколько других аннотаций, которые упрощают настройку и запуск приложения.\n    </p>\n    <p>\n        Эта аннотация обычно применяется к главному классу приложения, который содержит метод <code>main</code>.\n    </p>\n\n    <h2>Из каких аннотаций состоит @SpringBootApplication?</h2>\n    <p>\n        Аннотация <code>@SpringBootApplication</code> является комбинацией трех основных аннотаций:\n    </p>\n    <ol>\n        <li><strong>@SpringBootConfiguration</strong></li>\n        <li><strong>@EnableAutoConfiguration</strong></li>\n        <li><strong>@ComponentScan</strong></li>\n    </ol>\n\n    <h3>1. @SpringBootConfiguration</h3>\n    <p>\n        Эта аннотация указывает, что класс является конфигурационным классом Spring Boot. Она является специализированной версией аннотации <code>@Configuration</code>, которая используется для определения бинов и конфигураций.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@SpringBootConfiguration\npublic class MyAppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyService();\n    }\n}</code></pre>\n\n    <h3>2. @EnableAutoConfiguration</h3>\n    <p>\n        Эта аннотация включает механизм автоконфигурации Spring Boot. Она автоматически настраивает приложение на основе зависимостей, добавленных в проект. Например, если в проекте есть зависимость <code>spring-boot-starter-data-jpa</code>, Spring Boot автоматически настроит DataSource и EntityManager.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@EnableAutoConfiguration\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}</code></pre>\n\n    <h3>3. @ComponentScan</h3>\n    <p>\n        Эта аннотация сканирует пакеты приложения на наличие компонентов, таких как контроллеры, сервисы, репозитории и другие бины. Она автоматически регистрирует их в Spring-контейнере.\n    </p>\n    <h4>Пример:</h4>\n    <pre><code>@ComponentScan(basePackages = \"com.example\")\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}</code></pre>\n\n    <h2>Пример использования @SpringBootApplication</h2>\n    <p>\n        Вот как выглядит типичный главный класс Spring Boot-приложения с аннотацией <code>@SpringBootApplication</code>:\n    </p>\n    <pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}</code></pre>\n\n    <h2>Что происходит при использовании @SpringBootApplication?</h2>\n    <p>\n        Когда вы используете аннотацию <code>@SpringBootApplication</code>, Spring Boot выполняет следующие действия:\n    </p>\n    <ul>\n        <li>Сканирует пакеты приложения на наличие компонентов (<code>@ComponentScan</code>).</li>\n        <li>Автоматически настраивает приложение на основе зависимостей (<code>@EnableAutoConfiguration</code>).</li>\n        <li>Регистрирует конфигурационные классы (<code>@SpringBootConfiguration</code>).</li>\n    </ul>\n\n    <h2>Преимущества использования @SpringBootApplication</h2>\n    <ul>\n        <li><strong>Упрощение конфигурации:</strong> Объединяет несколько аннотаций в одну.</li>\n        <li><strong>Автоматизация:</strong> Автоматически настраивает приложение на основе зависимостей.</li>\n        <li><strong>Гибкость:</strong> Позволяет легко добавлять новые компоненты и конфигурации.</li>\n    </ul>\n\n    <h2>Недостатки использования @SpringBootApplication</h2>\n    <ul>\n        <li><strong>Скрытость:</strong> Некоторые настройки могут быть неочевидными из-за автоматической конфигурации.</li>\n        <li><strong>Ограниченная кастомизация:</strong> В некоторых случаях может потребоваться ручная настройка.</li>\n    </ul>\n',3),(174,'Запуск Spring Boot приложения',' <h1>Запуск Spring Boot приложения</h1>\n\n    <h2>Способы запуска Spring Boot приложения</h2>\n    <p>\n        Spring Boot предоставляет несколько способов запуска приложения. Выбор способа зависит от среды разработки, окружения и требований к развертыванию.\n    </p>\n\n    <h3>1. Запуск из IDE (IntelliJ IDEA, Eclipse, VS Code)</h3>\n    <p>\n        Самый простой способ запустить Spring Boot приложение — это использовать интегрированную среду разработки (IDE), такую как IntelliJ IDEA, Eclipse или Visual Studio Code.\n    </p>\n    <h4>Шаги для запуска:</h4>\n    <ol>\n        <li>Откройте проект в IDE.</li>\n        <li>Найдите главный класс приложения (обычно он помечен аннотацией <code>@SpringBootApplication</code>).</li>\n        <li>Щелкните правой кнопкой мыши на главном классе и выберите <strong>Run</strong> или <strong>Debug</strong>.</li>\n    </ol>\n    <h4>Пример главного класса:</h4>\n    <pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}</code></pre>\n\n    <h3>2. Запуск с помощью Maven</h3>\n    <p>\n        Если вы используете Maven в качестве системы сборки, вы можете запустить приложение с помощью команды <code>mvn spring-boot:run</code>.\n    </p>\n    <h4>Шаги для запуска:</h4>\n    <ol>\n        <li>Откройте терминал в корневой директории проекта.</li>\n        <li>Выполните команду:</li>\n    </ol>\n    <pre><code>mvn spring-boot:run</code></pre>\n\n    <h3>3. Запуск с помощью Gradle</h3>\n    <p>\n        Если вы используете Gradle, вы можете запустить приложение с помощью команды <code>gradle bootRun</code>.\n    </p>\n    <h4>Шаги для запуска:</h4>\n    <ol>\n        <li>Откройте терминал в корневой директории проекта.</li>\n        <li>Выполните команду:</li>\n    </ol>\n    <pre><code>gradle bootRun</code></pre>\n\n    <h3>4. Запуск из командной строки</h3>\n    <p>\n        Вы можете запустить Spring Boot приложение из командной строки, используя собранный JAR-файл.\n    </p>\n    <h4>Шаги для запуска:</h4>\n    <ol>\n        <li>Соберите проект с помощью Maven или Gradle:</li>\n    </ol>\n    <pre><code># Для Maven\nmvn clean package\n\n# Для Gradle\ngradle build</code></pre>\n    <ol start=\"2\">\n        <li>Перейдите в директорию <code>target</code> (для Maven) или <code>build/libs</code> (для Gradle).</li>\n        <li>Запустите JAR-файл:</li>\n    </ol>\n    <pre><code>java -jar имя-вашего-файла.jar</code></pre>\n\n    <h3>5. Запуск в Docker</h3>\n    <p>\n        Spring Boot приложение можно упаковать в Docker-контейнер и запустить его в изолированной среде.\n    </p>\n    <h4>Шаги для запуска:</h4>\n    <ol>\n        <li>Создайте Dockerfile в корневой директории проекта:</li>\n    </ol>\n    <pre><code># Используем базовый образ Java\nFROM openjdk:17-jdk-alpine\n\n# Копируем JAR-файл в контейнер\nCOPY target/имя-вашего-файла.jar app.jar\n\n# Указываем точку входа\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]</code></pre>\n    <ol start=\"2\">\n        <li>Соберите Docker-образ:</li>\n    </ol>\n    <pre><code>docker build -t имя-вашего-образа .</code></pre>\n    <ol start=\"3\">\n        <li>Запустите Docker-контейнер:</li>\n    </ol>\n    <pre><code>docker run -p 8080:8080 имя-вашего-образа</code></pre>\n\n    <h3>6. Запуск в облачной среде</h3>\n    <p>\n        Spring Boot приложения можно развертывать в облачных платформах, таких как AWS, Google Cloud, Heroku и других.\n    </p>\n    <h4>Пример для Heroku:</h4>\n    <ol>\n        <li>Установите Heroku CLI и войдите в систему:</li>\n    </ol>\n    <pre><code>heroku login</code></pre>\n    <ol start=\"2\">\n        <li>Создайте новое приложение Heroku:</li>\n    </ol>\n    <pre><code>heroku create</code></pre>\n    <ol start=\"3\">\n        <li>Разверните приложение:</li>\n    </ol>\n    <pre><code>git push heroku main</code></pre>\n\n    <h2>Преимущества различных способов запуска</h2>\n    <ul>\n        <li><strong>IDE:</strong> Удобство и простота для разработки и отладки.</li>\n        <li><strong>Maven/Gradle:</strong> Подходит для локального тестирования и CI/CD.</li>\n        <li><strong>Командная строка:</strong> Универсальный способ для развертывания на сервере.</li>\n        <li><strong>Docker:</strong> Изоляция и переносимость приложения.</li>\n        <li><strong>Облачные платформы:</strong> Масштабируемость и высокая доступность.</li>\n    </ul>\n\n    <h2>Недостатки различных способов запуска</h2>\n    <ul>\n        <li><strong>IDE:</strong> Зависимость от среды разработки.</li>\n        <li><strong>Maven/Gradle:</strong> Требует установки соответствующих инструментов.</li>\n        <li><strong>Командная строка:</strong> Менее удобен для отладки.</li>\n        <li><strong>Docker:</strong> Требует знаний Docker и настройки контейнеров.</li>\n        <li><strong>Облачные платформы:</strong> Может быть дорогостоящим и сложным для настройки.</li>\n    </ul>\n',3),(175,'Spring Boot Actuator','<p>\n        <strong>Spring Boot Actuator</strong> — это модуль в экосистеме Spring Boot, который предоставляет готовые функции для мониторинга и управления приложением в production-среде. Он позволяет разработчикам и администраторам получать информацию о состоянии приложения, его метриках, health-check и других аспектах работы.\n    </p>\n\n    <h2>Для чего используется Spring Boot Actuator?</h2>\n    <p>\n        Spring Boot Actuator используется для:\n    </p>\n    <ul>\n        <li><strong>Мониторинга состояния приложения:</strong> Actuator предоставляет эндпоинты, которые позволяют проверять работоспособность приложения (health), его метрики (metrics), информацию о конфигурации (config) и многое другое.</li>\n        <li><strong>Диагностики проблем:</strong> Actuator помогает выявлять и устранять проблемы, предоставляя доступ к логам, трассировке запросов и другим диагностическим данным.</li>\n        <li><strong>Управления приложением:</strong> Actuator позволяет выполнять такие операции, как остановка приложения (shutdown), изменение уровня логирования (loggers) и другие действия.</li>\n        <li><strong>Сбора метрик:</strong> Actuator интегрируется с системами мониторинга, такими как Prometheus, Grafana и другими, для сбора и анализа метрик производительности.</li>\n    </ul>\n\n    <h2>Основные возможности Spring Boot Actuator</h2>\n    <p>\n        Actuator предоставляет множество встроенных эндпоинтов, таких как:\n    </p>\n    <ul>\n        <li><strong>/health:</strong> Проверка состояния приложения (например, готово ли оно к работе).</li>\n        <li><strong>/metrics:</strong> Получение метрик приложения (количество запросов, использование памяти и т.д.).</li>\n        <li><strong>/info:</strong> Получение общей информации о приложении (версия, описание и т.д.).</li>\n        <li><strong>/env:</strong> Просмотр переменных окружения и конфигурации приложения.</li>\n        <li><strong>/loggers:</strong> Управление уровнями логирования.</li>\n        <li><strong>/trace:</strong> Просмотр последних запросов и их трассировки.</li>\n    </ul>\n\n    <h2>Как подключить Spring Boot Actuator?</h2>\n    <p>\n        Для подключения Actuator в Spring Boot приложении достаточно добавить зависимость в файл <code>pom.xml</code> (для Maven) или <code>build.gradle</code> (для Gradle):\n    </p>\n    <pre>\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n    </pre>\n    <p>\n        После этого Actuator будет доступен по соответствующим эндпоинтам.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Spring Boot Actuator — это мощный инструмент для мониторинга и управления Spring Boot приложениями. Он упрощает диагностику проблем, сбор метрик и управление приложением в production-среде, что делает его незаменимым для разработчиков и DevOps-инженеров.\n    </p>',3),(176,'Настройка логгирования в Spring Boot','<h1>Настройка логгирования в Spring Boot</h1>\n    <p>\n        Логгирование — это важная часть разработки и эксплуатации приложений. Spring Boot предоставляет гибкие возможности для настройки логгирования с использованием популярных библиотек, таких как <strong>Logback</strong>, <strong>Log4j2</strong> и <strong>Java Util Logging</strong>.\n    </p>\n\n    <h2>1. Использование файла <code>application.properties</code> или <code>application.yml</code></h2>\n    <p>\n        Spring Boot позволяет настраивать логгирование через конфигурационные файлы. Вот основные параметры:\n    </p>\n    <h3>Пример настройки в <code>application.properties</code>:</h3>\n    <pre>\n# Уровень логирования для корневого логгера\nlogging.level.root=INFO\n\n# Уровень логирования для конкретного пакета\nlogging.level.org.springframework.web=DEBUG\nlogging.level.com.example=TRACE\n\n# Настройка вывода логов в файл\nlogging.file.name=app.log\nlogging.file.path=/var/logs/myapp\n\n# Настройка формата логов\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n\nlogging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\n    </pre>\n\n    <h3>Пример настройки в <code>application.yml</code>:</h3>\n    <pre>\nlogging:\n  level:\n    root: INFO\n    org.springframework.web: DEBUG\n    com.example: TRACE\n  file:\n    name: app.log\n    path: /var/logs/myapp\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n    </pre>\n\n    <h2>2. Использование файла конфигурации Logback</h2>\n    <p>\n        Если вам нужна более сложная настройка, вы можете использовать файл конфигурации Logback (<code>logback-spring.xml</code>). Spring Boot автоматически обнаружит этот файл, если он находится в classpath.\n    </p>\n    <h3>Пример <code>logback-spring.xml</code>:</h3>\n    <pre>\n&lt;configuration&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;file&gt;app.log&lt;/file&gt;\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;\n            &lt;fileNamePattern&gt;app.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;30&lt;/maxHistory&gt;\n        &lt;/rollingPolicy&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n        &lt;appender-ref ref=\"FILE\" /&gt;\n    &lt;/root&gt;\n\n    &lt;logger name=\"com.example\" level=\"DEBUG\" /&gt;\n&lt;/configuration&gt;\n    </pre>\n\n    <h2>3. Использование профилей Spring Boot</h2>\n    <p>\n        Вы можете настроить логгирование для разных профилей Spring Boot, используя файлы конфигурации с именами, такими как <code>logback-spring-dev.xml</code> или <code>logback-spring-prod.xml</code>. Spring Boot автоматически выберет подходящий файл в зависимости от активного профиля.\n    </p>\n\n    <h2>4. Динамическое изменение уровня логгирования через Actuator</h2>\n    <p>\n        Spring Boot Actuator предоставляет эндпоинт <code>/loggers</code>, который позволяет динамически изменять уровень логгирования во время работы приложения. Для этого нужно добавить зависимость Actuator и включить эндпоинт:\n    </p>\n    <pre>\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n    </pre>\n    <p>\n        Затем в <code>application.properties</code> включите эндпоинт:\n    </p>\n    <pre>\nmanagement.endpoints.web.exposure.include=loggers\n    </pre>\n    <p>\n        Теперь вы можете отправлять POST-запросы на <code>/actuator/loggers/{logger-name}</code> для изменения уровня логгирования.\n    </p>\n\n    <h2>Заключение</h2>\n    <p>\n        Spring Boot предоставляет множество способов настройки логгирования, от простых конфигураций в <code>application.properties</code> до сложных конфигураций с использованием <code>logback-spring.xml</code>. Выбор подходящего метода зависит от требований вашего приложения.\n    </p>',3),(177,'PreparedStatement и Batching запросов',' <h1>PreparedStatement и Batching запросов</h1>\n    <p>\n        В Java при работе с базами данных часто используются <strong>PreparedStatement</strong> и <strong>Batching</strong> для выполнения SQL-запросов. Эти механизмы позволяют повысить производительность и безопасность приложений.\n    </p>\n\n    <h2>1. Что такое PreparedStatement?</h2>\n    <p>\n        <strong>PreparedStatement</strong> — это интерфейс в JDBC, который позволяет выполнять параметризованные SQL-запросы. Он предоставляет следующие преимущества:\n    </p>\n    <ul>\n        <li><strong>Безопасность:</strong> Защита от SQL-инъекций, так как параметры передаются отдельно от запроса.</li>\n        <li><strong>Производительность:</strong> Запрос компилируется один раз и может выполняться многократно с разными параметрами.</li>\n        <li><strong>Читаемость:</strong> Упрощает написание и поддержку SQL-запросов.</li>\n    </ul>\n\n    <h3>Пример использования PreparedStatement:</h3>\n    <pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class PreparedStatementExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password)) {\n            String sql = \"INSERT INTO users (name, email) VALUES (?, ?)\";\n            PreparedStatement statement = connection.prepareStatement(sql);\n\n            statement.setString(1, \"John Doe\");\n            statement.setString(2, \"john.doe@example.com\");\n            statement.executeUpdate();\n\n            System.out.println(\"Запись успешно добавлена.\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n    </pre>\n\n    <h2>2. Что такое Batching запросов?</h2>\n    <p>\n        <strong>Batching</strong> — это техника, которая позволяет объединять несколько SQL-запросов в один пакет и выполнять их за один вызов к базе данных. Это особенно полезно при вставке или обновлении большого количества данных, так как уменьшает количество сетевых запросов и повышает производительность.\n    </p>\n\n    <h3>Пример использования Batching с PreparedStatement:</h3>\n    <pre>\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class BatchingExample {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password)) {\n            String sql = \"INSERT INTO users (name, email) VALUES (?, ?)\";\n            PreparedStatement statement = connection.prepareStatement(sql);\n\n            // Добавление запросов в пакет\n            for (int i = 1; i <= 1000; i++) {\n                statement.setString(1, \"User \" + i);\n                statement.setString(2, \"user\" + i + \"@example.com\");\n                statement.addBatch(); // Добавляем запрос в пакет\n\n                if (i % 100 == 0) {\n                    statement.executeBatch(); // Выполняем пакет каждые 100 запросов\n                }\n            }\n\n            statement.executeBatch(); // Выполняем оставшиеся запросы\n            System.out.println(\"Пакетная вставка завершена.\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n    </pre>\n\n    <h2>3. Преимущества использования Batching</h2>\n    <ul>\n        <li><strong>Увеличение производительности:</strong> Снижение накладных расходов на выполнение множества отдельных запросов.</li>\n        <li><strong>Снижение нагрузки на сеть:</strong> Передача данных одним пакетом вместо множества мелких запросов.</li>\n        <li><strong>Атомарность:</strong> Возможность выполнения всех операций в одной транзакции.</li>\n    </ul>\n\n    <h2>4. Рекомендации по использованию Batching</h2>\n    <ul>\n        <li>Используйте <code>addBatch()</code> для добавления запросов в пакет.</li>\n        <li>Выполняйте пакет с помощью <code>executeBatch()</code>.</li>\n        <li>Очищайте пакет после выполнения с помощью <code>clearBatch()</code>, если планируете повторное использование.</li>\n        <li>Управляйте транзакциями вручную, чтобы обеспечить атомарность операций.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Использование <strong>PreparedStatement</strong> и <strong>Batching</strong> позволяет значительно улучшить производительность и безопасность приложений, работающих с базами данных. Эти техники особенно полезны при выполнении массовых операций, таких как вставка или обновление большого количества данных.\n    </p>',13),(178,'Spring MVC: что это и как работает',' <p>\n        <strong>Spring MVC</strong> (Model-View-Controller) — это модуль фреймворка Spring, предназначенный для создания веб-приложений. Он реализует архитектурный шаблон MVC, который разделяет приложение на три основные компонента: <strong>Model</strong> (модель), <strong>View</strong> (представление) и <strong>Controller</strong> (контроллер). Это позволяет упростить разработку, тестирование и поддержку веб-приложений.\n    </p>\n\n    <h2>Основные компоненты Spring MVC</h2>\n    <p>\n        Spring MVC состоит из следующих ключевых компонентов:\n    </p>\n    <ul>\n        <li><strong>Model:</strong> Представляет данные приложения. Модель содержит бизнес-логику и взаимодействует с базой данных или другими источниками данных.</li>\n        <li><strong>View:</strong> Отвечает за отображение данных пользователю. Обычно это HTML-страницы, JSP, Thymeleaf или другие шаблоны.</li>\n        <li><strong>Controller:</strong> Обрабатывает запросы пользователя, взаимодействует с моделью и возвращает представление.</li>\n    </ul>\n\n    <h2>Как работает Spring MVC?</h2>\n    <p>\n        Работа Spring MVC основана на обработке HTTP-запросов и возврате HTTP-ответов. Вот основные этапы обработки запроса:\n    </p>\n    <ol>\n        <li><strong>Запрос поступает в DispatcherServlet:</strong>\n            <ul>\n                <li><code>DispatcherServlet</code> — это центральный компонент Spring MVC, который действует как фронт-контроллер.</li>\n                <li>Он получает все входящие HTTP-запросы и перенаправляет их соответствующим контроллерам.</li>\n            </ul>\n        </li>\n        <li><strong>Определение контроллера:</strong>\n            <ul>\n                <li><code>DispatcherServlet</code> использует <code>HandlerMapping</code> для определения того, какой контроллер должен обработать запрос.</li>\n            </ul>\n        </li>\n        <li><strong>Обработка запроса контроллером:</strong>\n            <ul>\n                <li>Контроллер обрабатывает запрос, взаимодействует с моделью (например, извлекает данные из базы) и возвращает имя представления или данные.</li>\n            </ul>\n        </li>\n        <li><strong>Определение представления:</strong>\n            <ul>\n                <li><code>DispatcherServlet</code> использует <code>ViewResolver</code> для определения, какое представление (например, JSP или Thymeleaf) должно быть использовано для отображения данных.</li>\n            </ul>\n        </li>\n        <li><strong>Формирование ответа:</strong>\n            <ul>\n                <li>Представление (View) использует данные из модели для генерации HTML-страницы или другого ответа.</li>\n                <li>Ответ отправляется обратно клиенту через <code>DispatcherServlet</code>.</li>\n            </ul>\n        </li>\n    </ol>\n\n    <h2>Пример простого Spring MVC приложения</h2>\n    <p>\n        Рассмотрим пример простого Spring MVC приложения, которое отображает приветственное сообщение.\n    </p>\n\n    <h3>1. Контроллер:</h3>\n    <pre>\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping(\"/hello\")\npublic class HelloController {\n\n    @GetMapping\n    public String sayHello() {\n        return \"hello\"; // Имя представления (hello.jsp или hello.html)\n    }\n}\n    </pre>\n\n    <h3>2. Представление (hello.jsp):</h3>\n    <pre>\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"ru\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Приветствие&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Привет, Spring MVC!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n    </pre>\n\n    <h3>3. Конфигурация Spring MVC:</h3>\n    <p>\n        Для настройки Spring MVC можно использовать Java-конфигурацию или XML. Пример Java-конфигурации:\n    </p>\n    <pre>\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ViewResolverRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.jsp(\"/WEB-INF/views/\", \".jsp\"); // Указываем путь к представлениям\n    }\n}\n    </pre>\n\n    <h2>Преимущества Spring MVC</h2>\n    <ul>\n        <li><strong>Гибкость:</strong> Поддержка различных технологий представления (JSP, Thymeleaf, FreeMarker и др.).</li>\n        <li><strong>Модульность:</strong> Четкое разделение на Model, View и Controller.</li>\n        <li><strong>Интеграция с Spring:</strong> Легкая интеграция с другими модулями Spring, такими как Spring Security, Spring Data и др.</li>\n        <li><strong>Тестируемость:</strong> Упрощенное тестирование контроллеров и других компонентов.</li>\n    </ul>\n\n    <h2>Заключение</h2>\n    <p>\n        Spring MVC — это мощный и гибкий фреймворк для создания веб-приложений. Он реализует архитектурный шаблон MVC, что позволяет разработчикам создавать структурированные, легко поддерживаемые и тестируемые приложения. Благодаря своей модульности и интеграции с другими технологиями Spring, он остается одним из самых популярных инструментов для разработки веб-приложений на Java.\n    </p>',3);
/*!40000 ALTER TABLE `topic_library` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-02-07 10:37:21
