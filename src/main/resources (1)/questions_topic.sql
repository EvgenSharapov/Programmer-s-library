-- MySQL dump 10.13  Distrib 8.0.40, for Win64 (x86_64)
--
-- Host: localhost    Database: questions
-- ------------------------------------------------------
-- Server version	8.0.40

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `topic`
--

DROP TABLE IF EXISTS `topic`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `topic` (
  `id` int NOT NULL AUTO_INCREMENT,
  `table` varchar(255) DEFAULT NULL,
  `content` text,
  `topic_area` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=71 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `topic`
--

LOCK TABLES `topic` WRITE;
/*!40000 ALTER TABLE `topic` DISABLE KEYS */;
INSERT INTO `topic` VALUES (1,'Что такое ООП','<p class=\"card-text\"><p>Объектно-ориентированное программирование (ООП) &mdash; это парадигма, основанная на концепции &quot;объектов&quot;, которые могут содержать данные в виде полей (часто называемых атрибутами или свойствами) и код в виде процедур (часто называемых методами). ООП фокусируется на использовании объектов для моделирования реальных или абстрактных сущностей, интересующих в процессе разработки программного обеспечения, облегчая тем самым разработку и поддержку программ.</p>\n\n<p>Основные принципы:</p>\n\n<p>1. <strong>Инкапсуляция</strong> &mdash; это сокрытие внутренних деталей реализации объекта от внешнего мира. Только сам объект управляет своим состоянием, внешние объекты взаимодействуют с ним через методы. Это позволяет упростить интерфейсы взаимодействия между компонентами и улучшить модульность.</p>\n\n<p>2. <strong>Наследование</strong> &mdash; механизм, с помощью которого один класс (дочерний класс) может наследовать свойства и методы другого класса (родительского класса), потенциально переопределяя некоторые из них. Это способствует повторному использованию кода и иерархической организации классов.</p>\n\n<p>3. <strong>Полиморфизм</strong> &mdash; способность объектов с одинаковым интерфейсом предоставлять различную реализацию. Это позволяет одному и тому же коду работать с объектами разных типов.</p>\n\n<p>4. <strong>Абстракция</strong> &mdash; процесс выделения существенных характеристик объекта, исключая несущественные. Это помогает сосредоточиться на том, что объект делает, а не на том, как он это делает.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">class Животное {\n    void есть() {\n        System.out.println(\"Животное ест\");\n    }\n}\n\nclass Кот extends Животное {\n    void есть() {\n        System.out.println(\"Кот ест рыбу\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Животное моеЖивотное = new Кот();\n        моеЖивотное.есть(); // Выведет \"Кот ест рыбу\", демонстрируя полиморфизм\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`Кот` </strong>наследует поведение от <strong>`Животное`</strong> и переопределяет метод <strong>`есть`</strong>, демонстрируя наследование и полиморфизм. Инкапсуляция и абстракция также затрагиваются, поскольку мы взаимодействуем с объектами через их поведение, не заботясь о внутреннем устройстве.</p>\n\n<p>Объектно-ориентированное программирование &mdash; это подход к разработке программ, который использует &quot;объекты&quot; &mdash; сущности с данными и методами для моделирования реального или абстрактного мира. Это помогает сделать код более модульным, легко расширяемым и поддерживаемым.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Объектно-ориентированное программирование (ООП)</strong>&nbsp;&mdash; методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.</p>\n\n<ul>\n	<li>объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;</li>\n	<li>каждый объект является экземпляром определенного класса</li>\n	<li>классы образуют иерархии.</li>\n</ul>\n\n<p>Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.</p>\n\n<p>Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.</p></p>\n                        \n    \n                    </div>\n                </div>\n            </div>',0),(2,'В чем разница между checked и unchecked исключениями',' <p class=\"card-text\"><p>Исключения (exceptions) важная часть обработки ошибок. Есть две основные категории: проверяемые (checked) и непроверяемые (unchecked).</p>\n\n<p><strong>Проверяемые исключения (Checked Exceptions):</strong></p>\n\n<ul>\n	<li>Должны быть явно обработаны в коде с помощью блока <strong>`try-catch`</strong> или должны быть указаны в сигнатуре метода с помощью ключевого слова<strong> `throws`</strong>.&nbsp;</li>\n	<li>Они представляют ошибки, которые могут возникнуть во время выполнения программы и которые во многих случаях программист может предвидеть и обработать. Например, ошибка чтения файла, когда файл не существует.</li>\n	<li>Примеры классов проверяемых исключений включают <strong>`IOException`</strong>, <strong>`FileNotFoundException`</strong>, <strong>`ClassNotFoundException`</strong> и другие.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">try {\n    FileInputStream file = new FileInputStream(\"non_existent_file.txt\");\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n}</code></pre>\n\n<p>В этом примере <strong>`FileNotFoundException`</strong> является проверяемым исключением, и его необходимо обрабатывать в блоке <strong>`try-catch`</strong>.</p>\n\n<p><strong>Непроверяемые исключения (Unchecked Exceptions):</strong></p>\n\n<ul>\n	<li>Не требуют обязательной обработки в коде. Они обычно возникают из-за ошибок программирования, таких как деление на ноль или доступ к элементу за пределами массива.</li>\n	<li>К ним относятся ошибки времени выполнения (RuntimeException) и ошибки (Error).&nbsp;</li>\n	<li>Примеры включают <strong>`NullPointerException`</strong>, <strong>`IndexOutOfBoundsException`</strong>, <strong>`ArithmeticException`</strong> и другие.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">int result = 10 / 0; // Приводит к ArithmeticException</code></pre>\n\n<p>Здесь <strong>`ArithmeticException`</strong> является непроверяемым исключением, вызванным делением на ноль.</p>\n\n<p><strong>Почему разделение на checked и unchecked?</strong><br />\nРазделение позволяет управлять потенциальными ошибками, которые могут быть исправлены, и отличать их от ошибок времени выполнения, которые чаще всего являются результатом ошибок в коде. Это способствует написанию более надежного и устойчивого к ошибкам кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В Java все исключения делятся на два типа:</p>\n\n<ul>\n	<li><strong>checked (контролируемые/проверяемые исключения)</strong>&nbsp;должны обрабатываться блоком&nbsp;<code>catch</code>&nbsp;или описываться в заголовке метода (например,&nbsp;<code>throws IOException</code>). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;</li>\n	<li><strong>unchecked (неконтролируемые/непроверяемые исключения)</strong>, к которым относятся ошибки&nbsp;<code>Error</code>&nbsp;(например,&nbsp;<code>OutOfMemoryError</code>), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом&nbsp;<code>RuntimeException</code>&nbsp;и его наследниками (например,&nbsp;<code>NullPointerException</code>), которые могут не обрабатываться блоком&nbsp;<code>catch</code>&nbsp;и не быть описанными в заголовке метода.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(3,'Иерархия исключений','<p class=\"card-text\"><p>Иерархия исключений организована в виде дерева наследования, где все классы исключений являются потомками класса <strong>Throwable</strong>. Он делится на два основных подкласса: <strong>Error</strong> и<strong> Exception</strong>.</p>\n\n<p>1. <strong>Throwable</strong><br />\nОт него напрямую наследуются классы <strong>Error</strong> и <strong>Exception</strong>. Этот класс содержит методы для получения сообщения об ошибке, локализованного сообщения, причины исключения и стека вызовов, а также методы для подавления исключений и работы со стеком вызовов.</p>\n\n<p>2.<strong> Error</strong><br />\nError описывает серьёзные ошибки, возникающие на уровне виртуальной машины и библиотеки языка, из-за которых приложение обычно не может восстановиться. Примеры включают <strong>OutOfMemoryError</strong> и <strong>StackOverflowError</strong>. Ошибки этого типа обычно не предназначены для обработки приложением.</p>\n\n<p>3. <strong>Exception</strong><br />\nЭтот класс и подклассы описывают исключения, с которыми приложение может и должно справиться. Делится на две большие категории: проверяемые(<strong>checked exceptions</strong>) и непроверяемые исключения (<strong>unchecked exceptions</strong>).</p>\n\n<p>Проверяемые исключения<br />\nТребуют обязательной обработки в блоке<strong> try-catch</strong> или должны быть объявлены в сигнатуре метода с помощью<strong> throws</strong>. Они бозначают условия, с которыми приложение может предвидеть и справиться. Примеры включают <strong>IOException</strong>, <strong>FileNotFoundException</strong> и <strong>ClassNotFoundException</strong>.</p>\n\n<p>Непроверяемые исключения<br />\nЯвляются непроверяемыми исключениями. Они обозначают ошибки, такие как неверное приведение типов (<strong>ClassCastException</strong>), обращение по нулевой ссылке (<strong>NullPointerException</strong>) и выход за пределы массива (<strong>ArrayIndexOutOfBoundsException</strong>). Эти исключения не требуют обязательной обработки в блоке<strong> try-catch</strong>.</p>\n\n<p>Иерархия исключений обеспечивает структурированный и гибкий способ обработки ошибок и исключительных ситуаций в приложениях. Позволяет различать серьёзные проблемы системного уровня, с которыми приложение не может справиться.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Исключения делятся на несколько классов, но все они имеют общего предка &mdash; класс&nbsp;<code>Throwable</code>, потомками которого являются классы&nbsp;<code>Exception</code>&nbsp;и&nbsp;<code>Error</code>.</p>\n\n<p><strong>Ошибки (Errors)</strong>&nbsp;представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.</p>\n\n<p><strong>Исключения (Exceptions)</strong>&nbsp;являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(4,'Методы в классе Object','<p class=\"card-text\"><p><strong>Object</strong> - суперкласс для всех классов. Все объекты, включая массивы, наследуют методы этого класса. Они предоставляют функции, которые доступны для любого объекта. Вот основные методы:</p>\n\n<p>1. <strong>`clone()`</strong> - создает и возвращает копию объекта. Метод защищенный, поэтому его можно вызвать только внутри класса объекта или в классах потомках.</p>\n\n<p>2. <strong>`equals(Object obj)`</strong> - определяет равенство между двумя объектами. По умолчанию, этот метод сравнивает ссылки на объекты.</p>\n\n<p>3.<strong> `finalize()` </strong>- вызывается перед удалением объекта сборщиком мусора. Метод устарел.</p>\n\n<p>4.<strong> `getClass()`</strong> - возвращает Class, который представляет класс данного объекта. Можно использовать для получения имени во время выполнения.</p>\n\n<p>5. <strong>`hashCode()` </strong>- возвращает хеш-код, который используется для оптимизации хранения в структурах данных.</p>\n\n<p>6. <strong>`notify()`</strong> - пробуждает один поток, который ожидает на объекте (вызвавший wait()). Этот метод должен вызываться в синхронизированном контексте.</p>\n\n<p>7. <strong>`notifyAll()`</strong> - пробуждает все ожидающие потоки. Должен вызываться в синхронизированном контексте.</p>\n\n<p>8. <strong>`toString()`</strong> - возвращает строковое представление. По умолчанию, возвращает класс и хеш-код, но часто переопределяется для предоставления более информативного представления.</p>\n\n<p>9. <strong>`wait()`</strong> - заставляет текущий поток ожидать, пока другой поток не вызовет <strong>notify()</strong> или <strong>notifyAll()</strong>. Существуют перегруженные версии <strong>wait(long timeout)</strong> и <strong>wait(long timeout, int nanos)</strong>, позволяющие указать максимальное время ожидания.</p>\n\n<p>Эти методы предоставляют основу для механизмов, таких как сравнение объектов, их клонирование, уведомление и ожидание в многопоточных средах, а также для работы с хеш-таблицами. Играют важную роль в проектировании и реализации Java-программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>public boolean equals(Object obj)</code>&nbsp;&ndash; служит для сравнения объектов по значению;</p>\n\n<p><code>int hashCode()</code>&nbsp;&ndash; возвращает hash код для объекта;</p>\n\n<p><code>String toString()</code>&nbsp;&ndash; возвращает строковое представление объекта;</p>\n\n<p><code>Class getClass()</code>&nbsp;&ndash; возвращает класс объекта во время выполнения;</p>\n\n<p><code>protected Object clone()</code>&nbsp;&ndash; создает и возвращает копию объекта;</p>\n\n<p><code>void notify()</code>&nbsp;&ndash; возобновляет поток, ожидающий монитор;</p>\n\n<p><code>void notifyAll()</code>&nbsp;&ndash; возобновляет все потоки, ожидающие монитор;</p>\n\n<p><code>void wait()</code>&nbsp;&ndash; остановка вызвавшего метод потока до момента пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>void wait(long timeout)</code>&nbsp;&ndash; остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>void wait(long timeout, int nanos)</code>&nbsp;&ndash; остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод&nbsp;<code>notify()</code>&nbsp;или&nbsp;<code>notifyAll()</code>&nbsp;для этого объекта;</p>\n\n<p><code>protected void finalize()</code>&nbsp;&ndash; может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(5,'Иерархия коллекций','<p class=\"card-text\"><p>Иерархия коллекций &mdash; это набор интерфейсов и классов, которые предоставляют общие структуры данных, такие как списки, множества и карты. Находится в пакете `java.util` и разработана для работы с группами объектов.</p>\n\n<p><strong>Основные интерфейсы</strong></p>\n\n<p><strong>Collection Interface:</strong> Корневой интерфейс иерархии коллекций. Определяет методы, такие как <strong>`add()`</strong>, <strong>`remove()`</strong>,<strong> `size()`</strong>, <strong>`isEmpty()`</strong> и <strong>`iterator()`</strong>, которые должны быть реализованы всеми коллекциями.</p>\n\n<ul>\n	<li><strong>List Interface:</strong> Представляет упорядоченную коллекцию. Элементы в списке могут быть доступны по индексам. Допускает дублирование элементов. Реализации включают<strong> `ArrayList`</strong>, <strong>`LinkedList` </strong>и <strong>`Vector`</strong>.</li>\n</ul>\n\n<p>&nbsp;&nbsp;</p>\n\n<ul>\n	<li><strong>Set Interface:</strong> Набор уникальных элементов. Не допускает дублирования элементов. Реализации включают<strong> `HashSet`</strong>, <strong>`LinkedHashSet`</strong> и <strong>`TreeSet`</strong>.</li>\n	<li><strong>Queue Interface:</strong> Для работы с коллекциями, используемыми для хранения элементов перед обработкой. Поддерживает операции вставки, извлечения и инспекции.<strong> `LinkedList`</strong> реализует как <strong>`List`</strong>, так и <strong>`Queue`</strong>. Также есть <strong>`PriorityQueue` </strong>для элементов, которые должны обрабатываться в порядке приоритета.</li>\n</ul>\n\n<p><strong>Map Interface: </strong>Не наследуется от <strong>`Collection`</strong> интерфейса. Описывает структуру для хранения пар ключ/значение. Ключи уникальны, а значения могут дублироваться. Реализации включают <strong>`HashMap`</strong>, <strong>`LinkedHashMap`</strong>, <strong>`TreeMap`</strong> и <strong>`Hashtable`</strong>.</p>\n\n<p><strong>Особенности классов</strong></p>\n\n<ul>\n	<li><strong>ArrayList:</strong> Динамический массив для хранения элементов, который автоматически расширяется. Предлагает быстрый доступ к элементам по индексу.</li>\n	<li><strong>LinkedList: </strong>Двусвязный список, который обеспечивает эффективное добавление/удаление элементов. Может использоваться как список и очередь.</li>\n	<li><strong>HashSet:</strong> Использует хеш-таблицу для хранения уникальных элементов. Не гарантирует порядок элементов.</li>\n	<li><strong>LinkedHashSet:</strong> Расширяет <strong>`HashSet`</strong>, сохраняя порядок вставки элементов.</li>\n	<li><strong>TreeSet:</strong> Хранит элементы в отсортированном и восходящем порядке. Использует красно-черное дерево.</li>\n	<li><strong>HashMap:</strong> Хеш-таблица для хранения пар ключ/значение. Не поддерживает упорядоченность ключей или значений.</li>\n</ul></p>',7),(6,'Что такое SOLID',' <p class=\"card-text\"><p>SOLID &mdash; это акроним, представляющий пять основных принципов ООП и дизайна, направленных на повышение гибкости, масштабируемости и поддерживаемости ПО. Они помогает избежать проблемы с проектированием, такие как жесткая зависимость между компонентами программы и сложности в внесении изменений или добавлении новых функций.</p>\n\n<p>1. <strong>Принцип единственной ответственности (SRP): </strong>Подчеркивает важность разделения функциональности, чтобы каждый класс выполнял только одну задачу.</p>\n\n<pre>\n<code class=\"language-java\">   class UserSettings {\n       void changeEmail(User user) {\n           if(checkAccess(user)) {\n               // Изменение email пользователя\n           }\n       }\n\n       boolean checkAccess(User user) {\n           // Проверка прав доступа\n           return true;\n       }\n   }</code></pre>\n\n<p>&nbsp; &nbsp;Здесь класс <strong>`UserSettings` </strong>нарушает SRP, если бы в нем также были методы для управления пользователями. Лучше вынести метод <strong>`checkAccess`</strong> в отдельный класс.</p>\n\n<p>2. <strong>Принцип открытости/закрытости (OCP):</strong>&nbsp;Можно добавлять новую функциональность, не изменяя существующий код.<br />\n&nbsp; &nbsp;<br />\n3. <strong>Принцип подстановки Лисков (LSP):</strong> Классы-наследники должны дополнять, а не изменять поведение базовых классов.</p>\n\n<p>4. <strong>Принцип разделения интерфейса (ISP):</strong> Этот принцип ведет к созданию узкоспециализированных интерфейсов, вместо одного &quot;толстого&quot; интерфейса.</p>\n\n<p>5. <strong>Принцип инверсии зависимостей (DIP):</strong> Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций. Этот принцип направлен на уменьшение зависимостей между модулями программы.</p>\n\n<p>SOLID принципы направлены на создание гибкой, масштабируемой архитектуры, которая легко поддается изменениям и развитию. Используя эти принципы, можно создавать системы, которые легче понимать, поддерживать и расширять.</p></p>',6),(7,'Как организована HashMap','<p class=\"card-text\"><p><strong>`HashMap`</strong> &mdash; это структура данных, которая использует хеш-таблицу для хранения пар &quot;ключ-значение&quot;. Gозволяет выполнять операции вставки, удаления и поиска элементов с почти постоянным временем выполнения, что делает её очень эффективной для определённых задач. Вот как она организована:</p>\n\n<p><strong>Внутреннее устройство</strong></p>\n\n<p>1. <strong>Хеш-функция: </strong>Ключи хранятся с использованием хеш-функции, которая преобразует ключ в индекс массива. Этот индекс используется для хранения значения в массиве. Она должна равномерно распределять ключи по индексам массива, чтобы минимизировать коллизии.</p>\n\n<p>2. <strong>Массив бакетов (корзин):</strong> Внутри, она состоит из массива бакетов, где каждый бакет представляет собой &quot;корзину&quot;, которая может хранить одну или более пар &quot;ключ-значение&quot;. При добавлении новой пары &quot;ключ-значение&quot;, хеш-функция вычисляет индекс бакета для хранения значения на основе хеш-кода ключа.</p>\n\n<p>3. <strong>Связный список или дерево:</strong> В случае коллизии, когда два разных ключа имеют одинаковый хеш-код и попадают в один и тот же бакет, <strong>`HashMap`</strong> использует структуру данных в виде связного списка или дерева для хранения и разрешения коллизий. После определённого порога коллизий, список преобразуется в дерево для улучшения производительности поиска в этом бакете.</p>\n\n<p><strong>Работа</strong></p>\n\n<ul>\n	<li><strong>Вставка:</strong> Для вставки новой пары &quot;ключ-значение&quot;, сначала вычисляется хеш-код ключа, затем используется хеш-функция для определения индекса бакета. Если в бакете уже есть элементы, происходит проверка на наличие ключа с таким же хеш-кодом. Если такой ключ найден, его значение обновляется. Если ключ уникален, пара добавляется в бакет.</li>\n	<li><strong>Поиск:</strong> Поиск значения по ключу также начинается с вычисления хеш-кода ключа, определения индекса бакета и последующего поиска в связном списке или дереве этого бакета.</li>\n	<li><strong>Удаление:</strong> Удаление пары &quot;ключ-значение&quot; происходит аналогично поиску: сначала находится бакет, затем в нём ищется и удаляется элемент.</li>\n</ul>\n\n<p><strong>Расширение</strong></p>\n\n<p>Когда фактор заполнения <strong>`HashMap` </strong>превышает определённый порог, происходит автоматическое расширение массива бакетов и перехеширование всех элементов для равномерного распределения по новому массиву бакетов. Это обеспечивает высокую производительность `<strong>HashMap`</strong> даже при большом количестве элементов.</p>\n\n<p><strong>`HashMap`</strong> &mdash; это мощная и эффективная структура данных для хранения и быстрого доступа к данным через ключи. Благодаря использованию хеш-таблиц, <strong>`HashMap`</strong> обеспечивает быстрые операции вставки, поиска и удаления. Разрешение коллизий с помощью связных списков или деревьев и автоматическое расширение помогают поддерживать производительность на высоком уровне.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>HashMap</code>&nbsp;состоит из &laquo;корзин&raquo; (bucket). С технической точки зрения &laquo;корзины&raquo; &mdash; это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары &laquo;ключ-значение&raquo;, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.</p></p>\n                        ',7),(8,'Чем отличаются LinkedList и ArrayList','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`LinkedList`</strong> и<strong> `ArrayList`</strong> являются двумя разными реализациями интерфейса <strong>`List`</strong>, предназначенные для работы со списками объектов. Они имеют различные внутренние структуры данных, что влияет на их производительность в разных операциях.</p>\n\n<p><strong>ArrayList </strong>основан на динамическом массиве. Его элементы хранятся в массиве, размер которого автоматически увеличивается, когда количество элементов в списке превышает его емкость.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li><strong>Быстрый доступ к элементам:</strong> Доступ к любому элементу по индексу выполняется за константное время \\(O(1)\\), так как внутренне используется массив.</li>\n	<li><strong>Меньше занимаемого места</strong>&nbsp;(по сравнению с <strong>`LinkedList`</strong>), если список не изменяется часто, так как <strong>`ArrayList`</strong> не хранит ссылки на предыдущий и следующий элементы.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><strong>Добавление и удаление элементов: </strong>Операции добавления и удаления элементов могут быть медленнее, особенно если операции выполняются в начале списка, так как это требует сдвига всех последующих элементов.</li>\n	<li><strong>Потребление памяти при росте списка: </strong>При увеличении размера списка<strong> `ArrayList`</strong> должен создать новый, больший массив и скопировать в него элементы из старого, что может быть ресурсоемкой операцией.</li>\n</ul>\n\n<p><strong>LinkedList </strong>реализует двусвязный список, где каждый элемент списка содержит ссылки на предыдущий и следующий элементы в списке.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li><strong>Эффективное добавление и удаление: </strong>Добавление и удаление элементов выполняется за константное время \\(O(1)\\), так как не требуется сдвиг элементов. Достаточно изменить ссылки соседних элементов.</li>\n	<li><strong>Гибкость:</strong> <strong>`LinkedList`</strong> может использоваться как список, двусвязный список, стек или очередь.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><strong>Медленный доступ к элементам:</strong> Доступ к элементам по индексу требует времени \\(O(n)\\) в худшем случае, так как приходится проходить список от начала или конца до нужного элемента.</li>\n	<li><strong>Большее потребление памяти: </strong>Каждый элемент списка хранит не только данные, но и две ссылки на предыдущий и следующий элементы, что увеличивает общее потребление памяти.</li>\n</ul>\n\n<p>Выбор между LinkedList и ArrayList зависит от конкретных требований к производительности приложения:</p>\n\n<p><strong>Используйте `ArrayList`:</strong></p>\n\n<ul>\n	<li>&nbsp;Если в приоритете быстрый доступ к элементам по индексу.</li>\n	<li>&nbsp;Если операции добавления и удаления элементов выполняются преимущественно в конце списка или не являются основной операцией.</li>\n</ul>\n\n<p><strong>Используйте `LinkedList`:</strong></p>\n\n<ul>\n	<li>&nbsp;Если приложение интенсивно добавляет и удаляет элементы, особенно в начале или середине списка.</li>\n	<li>&nbsp;Если нужны функциональные возможности двусвязного списка или необходимо реализовать структуры данных, такие как стеки и очереди.</li>\n</ul>\n\n<p>Выбор между этими двумя структурами данных должен базироваться на их производительностных характеристиках в контексте конкретного использования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><code>ArrayList</code>&nbsp;это список, реализованный на основе массива, а&nbsp;<code>LinkedList</code>&nbsp;&mdash; это классический двусвязный список, основанный на объектах с ссылками между ними.</p>\n\n<p><code>ArrayList</code>:</p>\n\n<ul>\n	<li>доступ к произвольному элементу по индексу за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>;</li>\n	<li>доступ к элементам по значению за&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>вставка в конец в среднем производится за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>;</li>\n	<li>удаление произвольного элемента из списка занимает значительное время т. к. при этом все элементы, находящиеся &laquo;правее&raquo; смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);</li>\n	<li>вставка элемента в произвольное место списка занимает значительное время т. к. при этом все элементы, находящиеся &laquo;правее&raquo; смещаются на одну ячейку вправо;</li>\n	<li>минимум накладных расходов при хранении.</li>\n</ul>\n\n<p><code>LinkedList</code>:</p>\n\n<ul>\n	<li>на получение элемента по индексу или значению потребуется&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>но доступ к первому и последнему элементу списка всегда осуществляется за&nbsp;<em>константное</em>&nbsp;время&nbsp;<em>O(1)</em>&nbsp;&mdash; ссылки постоянно хранятся на первый и последний элемент;</li>\n	<li>на добавление и удаление в начало или конец списка потребуется&nbsp;<em>константное</em>&nbsp;<em>O(1)</em>;</li>\n	<li>вставка или удаление в/из произвольного место&nbsp;<em>константное</em>&nbsp;<em>O(1)</em>;</li>\n	<li>но поиск позиции вставки и удаления за&nbsp;<em>линейное</em>&nbsp;время&nbsp;<em>O(N)</em>;</li>\n	<li>требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</li>\n</ul>\n\n<p>В целом,&nbsp;<code>LinkedList</code>&nbsp;в абсолютных величинах проигрывает&nbsp;<code>ArrayList</code>&nbsp;и по потребляемой памяти, и по скорости выполнения операций.&nbsp; &nbsp;<code>LinkedList</code>&nbsp;предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(9,'Различие между интерфейсом и абстрактным классом',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс и абстрактный класс используются для достижения абстракции, но между ними существуют ключевые различия, связанные с их использованием и целями.</p>\n\n<p><strong>Интерфейс</strong></p>\n\n<p>Это контракт или соглашение, которое класс может реализовать. Определяют методы без их реализаций, оставляя классам, которые их реализуют, определять конкретные действия. В Java 8 и более поздних версиях интерфейсы могут содержать статические методы с реализацией и методы по умолчанию, которые имеют реализацию. Класс может реализовывать несколько интерфейсов, что поддерживает множественное наследование поведения.</p>\n\n<p><strong>Абстрактный класс</strong></p>\n\n<p>Это класс, не предназначенный для создания экземпляров, который может содержать как абстрактные методы (без реализации), так и методы с реализацией. Предназначен для того, чтобы быть базовым классом, от которого будут наследовать другие классы и реализовывать абстрактные методы. Класс может наследовать только один абстрактный класс, что ограничивает множественное наследование.</p>\n\n<p><strong>Основные различия</strong></p>\n\n<p>1. <strong>Наследование: </strong>Класс может реализовать множество интерфейсов, но наследовать только один абстрактный класс.<br />\n2. <strong>Методы: </strong>Интерфейсы могут содержать только объявления методов (до Java 8) и статические методы, а также методы по умолчанию (начиная с Java 8), тогда как абстрактные классы могут содержать как абстрактные методы, так и методы с реализацией.<br />\n3. <strong>Конструкторы:</strong> Абстрактные классы могут иметь конструкторы, интерфейсы &mdash; нет.<br />\n4. <strong>Поля:</strong> В интерфейсах все поля являются публичными, статическими и финальными по умолчанию, а абстрактные классы могут содержать поля с любым уровнем доступа и без ограничений на статичность или финализацию.<br />\n5. <strong>Использование:</strong> Абстрактные классы используются, когда несколько классов имеют общую реализацию, но также и свою уникальную реализацию некоторых методов. Интерфейсы идеально подходят для определения общего контракта для разнородных классов, которые не обязательно связаны друг с другом через иерархию наследования.</p>\n\n<p>Выбор между интерфейсом и абстрактным классом зависит от конкретной ситуации в проектировании программы. Если нужно определить общий контракт для классов, которые могут принадлежать к разным иерархиям наследования, следует использовать интерфейс. Если же требуется общая реализация для схожих классов, то лучше подойдет абстрактный класс.</p></p>\n                                               \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><ul>\n	<li>В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</li>\n	<li>Абстрактные классы используются только тогда, когда присутствует тип отношений &laquo;is a&raquo; (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</li>\n	<li>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как&nbsp;<code>public abstract</code>&nbsp;или (начиная с Java 8)&nbsp;<code>default</code>&nbsp;- методами с реализацией по-умолчанию, а поля -&nbsp;<code>public static final</code>.</li>\n	<li>Интерфейсы позволяют создавать структуры типов без иерархии.</li>\n	<li>Наследуясь от абстрактного, класс &laquo;растворяет&raquo; собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.</li>\n</ul>\n\n<p>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</p></p>\n                        ',1),(10,'Hash Code & Equals контракт','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`hashCode()`</strong> и <strong>`equals()`</strong> играют важную роль в работе с объектами, особенно когда речь идет о коллекциях, таких как <strong>`HashSet`</strong>, <strong>`HashMap`</strong>, и <strong>`Hashtable`</strong>. Они определены в классе <strong>`Object`</strong>, и поэтому доступны для переопределения всеми классами. Правильное переопределение этих методов важно для эффективной работы коллекций, которые используют хеширование.</p>\n\n<p>Контракт<strong> `hashCode()`</strong> и <strong>`equals()`</strong> - определяет, как эти методы должны взаимодействовать друг с другом:</p>\n\n<p>1. <strong>Согласованность:</strong> Если два объекта равны согласно методу <strong>`equals(Object obj)`</strong>, тогда вызов <strong>`hashCode()`</strong> на каждом из объектов должен возвращать одинаковое целое значение. Это не значит, что объекты, не равные друг другу, должны возвращать различные хеш-коды. Однако, разные хеш-коды могут помочь улучшить производительность хеш-таблиц.</p>\n\n<p>2. <strong>Обратное не требуется: </strong>Если <strong>`hashCode()`</strong> двух объектов возвращает одинаковое значение, это не обязательно означает, что объекты равны согласно <strong>`equals()`</strong>. Ситуация, когда разные объекты имеют одинаковые хеш-коды, называется коллизией.</p>\n\n<p>Переопределение <strong>`equals(Object obj)`</strong> используется для проверки равенства двух объектов. По умолчанию, этот метод проверяет равенство ссылок, что означает, что два объекта считаются равными, только если они указывают на одно и то же место в памяти. Переопределение метода<strong> `equals()` </strong>позволяет сравнивать объекты по содержанию.</p>\n\n<p>При переопределении <strong>`equals()`</strong>, убедитесь, что он:</p>\n\n<ul>\n	<li>Рефлексивен: для любого ненулевого ссылочного значения<strong> `x`</strong>, <strong>`x.equals(x)` </strong>должно возвращать <strong>`true`</strong>.</li>\n	<li>Симметричен: для любых ненулевых ссылочных значений <strong>`x`</strong> и <strong>`y`</strong>, <strong>`x.equals(y)`</strong> должно возвращать <strong>`true` </strong>тогда и только тогда, когда <strong>`y.equals(x)`</strong> возвращает<strong> `true`</strong>.</li>\n	<li>Транзитивен: для любых ненулевых ссылочных значений <strong>`x`</strong>, <strong>`y`</strong>, и <strong>`z`</strong>, если <strong>`x.equals(y)`</strong> возвращает<strong> `true` </strong>и <strong>`y.equals(z)`</strong> возвращает <strong>`true`</strong>, то и <strong>`x.equals(z)`</strong> должно возвращать <strong>`true`</strong>.</li>\n	<li>Консистентен: для любых ненулевых ссылочных значений <strong>`x`</strong> и <strong>`y`</strong>, многократные вызовы<strong> `x.equals(y)` </strong>должны последовательно возвращать <strong>`true`</strong> или последовательно возвращать <strong>`false`</strong>.</li>\n	<li>Для любого ненулевого ссылочного значения<strong> `x`</strong>, <strong>`x.equals(null)`</strong> должно возвращать <strong>`false`</strong>.</li>\n</ul>\n\n<p>Переопределение<strong> `hashCode()`</strong> возвращает хеш-код объекта, который используется хеш-таблицами для определения места хранения объекта. При переопределении <strong>`equals()`</strong>, необходимо также переопределить <strong>`hashCode()`</strong>, чтобы поддерживать общий контракт для методов<strong> `hashCode()`</strong> и <strong>`equals()`</strong>.</p>\n\n<p><strong>Пример:</strong></p>\n\n<pre>\n<code class=\"language-java\">public class Person {\n    private String name;\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n               Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}</code></pre>\n\n<p>В этом примере, <strong>`equals()`</strong> сравнивает объекты по <strong>`name`</strong> и <strong>`age`</strong>, а <strong>`hashCode()`</strong> использует эти же поля для генерации хеш-кода. Это обеспечивает соблюдение контракта между<strong> `equals()` </strong>и <strong>`hashCode()`</strong>.</p>\n\n<p>Правильное переопределение <strong>`equals()` </strong>и <strong>`hashCode()` </strong>критически важно для корректной работы коллекций, основанных на хеш-таблицах. Это обеспечивает эффективное распределение объектов в коллекции и корректное сравнение объектов по содержанию.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(11,'Разница между примитивом и ссылочным типом данных','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Данные классифицируются на примитивные типы и ссылочные типы, и между этими двумя категориями существует несколько ключевых различий.</p>\n\n<p><strong>Примитивные типы</strong></p>\n\n<p>Основные типы данных, которые включают <strong>`byte`</strong>, <strong>`short`</strong>, <strong>`int`</strong>, <strong>`long`</strong>,<strong> `float`</strong>, <strong>`double`</strong>, <strong>`boolean`</strong>, и <strong>`char`</strong>. Представляют собой простые значения и не содержат дополнительных методов для работы с ними.</p>\n\n<p>1. <strong>Хранение:</strong> Примитивные типы хранятся в стеке, и доступ к ним осуществляется напрямую, что делает их обработку быстрой.<br />\n2. <strong>Значение по умолчанию:</strong> У каждого примитивного типа есть значение по умолчанию, например, <strong>`0`</strong> для числовых типов, <strong>`false`</strong> для <strong>`boolean`</strong> и <strong>`\\u0000`</strong> для <strong>`char`</strong>.<br />\n3. <strong>Размер:</strong> Размер примитивных типов фиксирован. Например, <strong>`int` </strong>всегда занимает 4 байта в памяти.</p>\n\n<p><strong>Ссылочные типы</strong></p>\n\n<p>Включают в себя классы, интерфейсы, массивы и перечисления. Представляют собой ссылку на объект, а не сам объект. Ссылочные типы могут быть использованы для вызова методов и могут быть равны <strong>`null`</strong>.</p>\n\n<p>1. <strong>Хранение:</strong> Ссылочные типы хранятся в куче, а в стеке хранится только ссылка на объект в куче. Доступ к объектам осуществляется через ссылку, что может быть медленнее, чем прямой доступ к примитивам.<br />\n2. <strong>Значение по умолчанию:</strong> Значение по умолчанию для всех ссылочных типов &mdash; <strong>`null`</strong>.<br />\n3. <strong>Размер:</strong> Размер объекта ссылочного типа может быть разным и зависит от его структуры и данных, которые он содержит.</p>\n\n<p><strong>Основные различия</strong></p>\n\n<ul>\n	<li><strong>Хранение в памяти:</strong> Примитивы хранятся в стеке, а объекты ссылочных типов &mdash; в куче с ссылкой на них, хранящейся в стеке.</li>\n	<li><strong>Производительность:</strong> Обращение к примитивам обычно быстрее, чем к объектам, поскольку для примитивов не требуется разыменование ссылок.</li>\n	<li><strong>Использование:</strong> Примитивные типы идеально подходят для хранения простых значений, в то время как ссылочные типы используются для создания сложных структур данных и объектов.</li>\n	<li><strong>Методы:</strong> Ссылочные типы могут использовать методы для выполнения операций над объектами, тогда как примитивные типы не имеют методов.</li>\n	<li><strong>Nullability:</strong> Ссылочные типы могут быть <strong>`null`</strong>, указывая на отсутствие объекта, в то время как примитивные типы всегда имеют конкретное значение.</li>\n</ul>\n\n<p>Выбор между примитивным и ссылочным типом данных зависит от конкретной задачи и требований к производительности. В некоторых случаях, например, когда требуется максимальная эффективность и минимальное потребление памяти, предпочтительнее использовать примитивные типы. В других случаях, когда нужны сложные структуры данных или возможность указать на отсутствие значения (<strong>`null`</strong>), лучше использовать ссылочные типы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(12,'Что такое ACID','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.</p>\n\n<ul>\n	<li>A - Atomicity. Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие &laquo;отката&raquo; (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во &laquo;внешне исходное&raquo; состояние &mdash; со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)</li>\n	<li>C - Consistency &mdash; Согласованность. Транзакция, достигающая своего нормального завершения (EOT &mdash; end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.</li>\n</ul>\n\n<p>Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.</p>\n\n<p>Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.</p>\n\n<ul>\n	<li>I - Isolation &mdash; Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность &mdash; требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию.&nbsp;Уровни изоляции транзакций</li>\n	<li>D - Durability &mdash; Стойкость. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(13,'Stream в Java','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`Stream` </strong>&mdash; это абстракция, которая позволяет обрабатывать последовательности элементов (например, коллекции) в функциональном стиле. API был добавлен в Java 8 и представляет собой набор классов и интерфейсов в пакете<strong> `java.util.stream`</strong>. Основная цель &mdash; упростить работу с коллекциями данных, позволяя выполнять различные операции с элементами последовательности, такие как фильтрация, сортировка, преобразование, агрегирование и другие, без необходимости явно писать циклы и управлять итерациями.</p>\n\n<p><strong>Особенности:</strong></p>\n\n<p>1. <strong>Не изменяет исходные данные: </strong>Операции с потоками данных не модифицируют исходную коллекцию, что способствует функциональному подходу и неизменяемости данных.<br />\n2. <strong>Ленивая обработка:</strong> Большинство операций с потоками выполняются лениво, то есть вычисления начинаются только тогда, когда это необходимо для получения результата (например, при вызове терминальной операции).<br />\n3. <strong>Поддержка параллельной обработки:</strong> Позволяет легко выполнять операции над элементами коллекции параллельно, что может значительно ускорить обработку больших наборов данных на многопроцессорных системах.</p>\n\n<p>Основные операции:</p>\n\n<p>Операции с потоками данных делятся на промежуточные (intermediate) и терминальные (terminal).</p>\n\n<ul>\n	<li><strong>Промежуточные операции&nbsp;</strong>возвращают новый поток и включают фильтрацию (<strong>`filter`</strong>), преобразование (<strong>`map`</strong>), сортировку (<strong>`sorted`</strong>) и другие. Они используются для преобразования потока и могут быть объединены в цепочки.</li>\n	<li><strong>Терминальные операции</strong>&nbsp;возвращают результат определенного типа (например, коллекцию, значение, boolean) или выполняют действие (<strong>`forEach`</strong>). К терминальным операциям относятся <strong>`collect`</strong>, <strong>`reduce`</strong>, <strong>`count`</strong>,<strong> `findFirst`</strong>.</li>\n</ul>\n\n<p><strong>Пример использования:</strong></p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamExample {\n    public static void main(String[] args) {\n        List&lt;String&gt; strings = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n\n        // Фильтрация и преобразование списка строк в список их длин\n        List&lt;Integer&gt; lengths = strings.stream() // Создание потока\n                .filter(s -&gt; s.length() &gt; 5) // Фильтрация строк по длине\n                .map(String::length) // Преобразование строки в её длину\n                .collect(Collectors.toList()); // Сбор результатов в список\n\n        System.out.println(lengths); // Вывод: [6, 6]\n    }\n}</code></pre>\n\n<p><strong>`Stream`</strong> API обеспечивает мощный и гибкий инструментарий для работы с данными в декларативном стиле, позволяя сосредоточиться на операциях обработки данных, а не на управлении итерациями и хранением промежуточных результатов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс&nbsp;<code>java.util.Stream</code>&nbsp;представляет собой последовательность элементов, над которой можно производить различные операции.</p>\n\n<p>Операции над стримами бывают или&nbsp;<em>промежуточными (intermediate)</em>&nbsp;или&nbsp;<em>конечными (terminal)</em>. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.</p>\n\n<p>У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция, никаких действий на самом деле не происходит (похоже на создание объекта&nbsp;<code>Thread</code>&nbsp;или&nbsp;<code>Runnable</code>, без вызова&nbsp;<code>start()</code>).</p>\n\n<p>Стримы создаются на основе каких-либо источников, например классов из&nbsp;<code>java.util.Collection</code>.</p>\n\n<p>Ассоциативные массивы (maps), например,&nbsp;<code>HashMap</code>, не поддерживаются.</p>\n\n<p>Операции над стримами могут выполняться как последовательно, так и параллельно.</p>\n\n<p>Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.</p>\n\n<p>Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных&nbsp;<code>int</code>,&nbsp;<code>long</code>&nbsp;и&nbsp;<code>double</code>:&nbsp;<code>IntStream</code>,&nbsp;<code>LongStream</code>&nbsp;и&nbsp;<code>DoubleStream</code>. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:</p>\n\n<ul>\n	<li>используют специализированные лямбда-выражения, например,&nbsp;<code>IntFunction</code>&nbsp;или&nbsp;<code>IntPredicate</code>&nbsp;вместо&nbsp;<code>Function</code>&nbsp;и&nbsp;<code>Predicate</code>;</li>\n	<li>поддерживают дополнительные конечные операции&nbsp;<code>sum()</code>,&nbsp;<code>average()</code>,&nbsp;<code>mapToObj()</code>.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(14,'Spring Scope',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В Spring Framework существует несколько областей видимости (scopes) для бинов, каждая из которых определяет жизненный цикл и видимость бина в контексте приложения. Вот основные из них:</p>\n\n<p>1. <strong>Singleton:</strong> Это область видимости по умолчанию. Бин с данной областью видимости создается один раз на каждый контейнер Spring IoC и кэшируется для последующих запросов. Все запросы на получение бина возвращают один и тот же экземпляр бина.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(\"singleton\")\n   public class MySingletonBean {\n   }</code></pre>\n\n<p>2. <strong>Prototype:</strong> Бин с данной областью видимости создается заново каждый раз, когда он запрашивается из контейнера. Это полезно, когда необходимы разные экземпляры бина для разных задач.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(\"prototype\")\n   public class MyPrototypeBean {\n   }</code></pre>\n\n<p>3. <strong>Request:</strong> Эта область видимости используется в веб-приложениях. Бин создается для каждого HTTP-запроса и уничтожается после обработки запроса. Бины с данной областью видимости доступны только в контексте одного HTTP-запроса.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyRequestBean {\n   }</code></pre>\n\n<p>4. <strong>Session:</strong> Бин с данной областью видимости создается для каждой пользовательской сессии. Бин живет в течение всей сессии и уничтожается, когда сессия завершается. Это полезно для хранения информации, специфичной для пользователя, в течение всего времени его сессии.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MySessionBean {\n   }</code></pre>\n\n<p>5. <strong>Application: </strong>Бин с данной областью видимости создается один раз для всего сервлет-контекста. Это полезно для данных, которые должны быть общими для всех пользователей и сессий в приложении.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"application\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyApplicationBean {\n   }</code></pre>\n\n<p>6. <strong>WebSocket: </strong>Бин с данной областью видимости создается для каждой сессии WebSocket. Это полезно для работы с данными, специфичными для каждой WebSocket-сессии.</p>\n\n<pre>\n<code class=\"language-java\">   @Component\n   @Scope(value = \"websocket\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n   public class MyWebSocketBean {\n   }</code></pre>\n\n<p>Каждая из этих областей видимости предоставляет разные способы управления жизненным циклом бинов в приложении, позволяя выбирать наиболее подходящий вариант для конкретного случая.</p>\n\n<p>Spring предлагает разные области видимости для бинов, такие как Singleton, Prototype, Request, Session, Application и WebSocket, которые определяют, как и когда бины будут создаваться, жить и уничтожаться. Это позволяет управлять жизненным циклом бинов в соответствии с потребностями приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',3),(15,'Функциональный интерфейс',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Функциональный интерфейс &mdash; это интерфейс, который содержит только один абстрактный метод. Это позволяет использовать лямбда-выражения для создания его анонимных реализаций, делая код более лаконичным и читаемым. Функциональные интерфейсы являются основой для лямбда-выражений и методов ссылок, начиная с версии 8.</p>\n\n<p>Примером этого может служить интерфейс <strong>`java.util.function.Predicate&lt;T&gt;`</strong>, который принимает объект типа <strong>`T`</strong> и возвращает значение типа <strong>`boolean`</strong>. Вот пример использования:</p>\n\n<pre>\n<code class=\"language-java\">Predicate&lt;String&gt; isNotEmpty = s -&gt; !s.isEmpty();\nSystem.out.println(isNotEmpty.test(\"Hello\")); // Выведет true\nSystem.out.println(isNotEmpty.test(\"\")); // Выведет false</code></pre>\n\n<p>Чтобы явно указать, что интерфейс предназначен для использования как функциональный, используется аннотация <strong>`@FunctionalInterface`</strong>. Эта аннотация не обязательна (компилятор может определить функциональный интерфейс и без неё), но она помогает в документировании кода и обеспечивает проверку времени компиляции, гарантируя, что интерфейс содержит только один абстрактный метод.</p>\n\n<p><strong>Пример собственного интерфейса:</strong></p>\n\n<pre>\n<code class=\"language-java\">@FunctionalInterface\npublic interface SimpleFunction {\n    int apply(int value);\n}\n\n// Использование\nSimpleFunction triple = value -&gt; value * 3;\nSystem.out.println(triple.apply(5)); // Выведет 15</code></pre>\n\n<p>Важно отметить, что функциональный интерфейс может содержать также статические и default методы, не нарушая своей &quot;функциональности&quot;, поскольку они не считаются абстрактными методами.</p>\n\n<p>Функциональный интерфейс &mdash; это интерфейс с одним абстрактным методом, который позволяет использовать лямбда-выражения для более краткого и выразительного кода. Аннотация<strong> `@FunctionalInterface` </strong>помогает обеспечить, что интерфейс соответствует требованиям функционального интерфейса.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',1),(16,'ExecutorService','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`ExecutorService`</strong> &ndash; это интерфейс из пакета <strong>`java.util.concurrent`</strong>, который предоставляет фреймворк для асинхронного выполнения задач. Он позволяет управлять потоками и задачами без необходимости явно создавать и управлять потоками руками. Это делает код более читаемым, упрощает работу с многопоточностью и повышает производительность приложения.</p>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p>В многопоточных приложениях часто возникает необходимость выполнения задач параллельно или асинхронно. Вместо того чтобы каждый раз создавать новые потоки вручную, что может быть неэффективно и увеличивать сложность кода, <strong>`ExecutorService`</strong> предоставляет удобные методы для выполнения задач в уже существующем пуле потоков. Это позволяет повторно использовать потоки и управлять ими эффективно.</p>\n\n<p><strong>Как он используется?</strong></p>\n\n<p>Может быть создан через статические методы класса <strong>`Executors`</strong>, например, <strong>`newFixedThreadPool(int)`</strong>, <strong>`newCachedThreadPool()`</strong>, <strong>`newSingleThreadExecutor()`</strong>, которые позволяют создавать пулы потоков с фиксированным числом потоков, кэширующие пулы потоков (создают новые потоки по необходимости и переиспользуют старые, когда они освобождаются) и пулы для выполнения задач последовательно в одном потоке соответственно.</p>\n\n<p>После его создания, можно отправлять задачи на выполнение, используя методы <strong>`execute(Runnable)`</strong> для задач без результата или <strong>`submit(Callable&lt;T&gt;)`</strong> для задач, возвращающих результат. Он также предоставляет методы для управления состоянием выполнения, например, <strong>`shutdown()`</strong> для остановки приема новых задач и завершения уже запущенных.</p>\n\n<p>Пример использования</p>\n\n<pre>\n<code class=\"language-java\">ExecutorService executor = Executors.newFixedThreadPool(10); // Создаем пул из 10 потоков\n\nexecutor.submit(() -&gt; {\n    // Задача, выполняемая в одном из потоков пула\n    System.out.println(\"Асинхронная задача \" + Thread.currentThread().getName());\n});\n\nexecutor.shutdown(); // Завершаем работу ExecutorService после выполнения всех задач</code></pre>\n\n<p><strong>`ExecutorService`</strong> &ndash; это мощный инструмент для управления асинхронными задачами и потоками в Java. Он упрощает работу с многопоточностью, позволяя эффективно использовать системные ресурсы и упрощает код, делая его более читаемым и поддерживаемым.</p>\n\n<p><strong>`ExecutorService`</strong> помогает организовать выполнение задач в пуле потоков, управлять этими потоками и обрабатывать результаты выполнения задач.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(17,'SQL и NoSQL','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>SQL (Structured Query Language) и NoSQL относятся к разным типам систем управления базами данных, каждый из которых предлагает уникальные характеристики и преимущества для определенных случаев использования и требований к данным.</p>\n\n<p><strong>SQL (Реляционные БД):</strong></p>\n\n<ul>\n	<li><strong>Структура: </strong>Организованы в таблицы, состоящие из строк и столбцов. Все данные должны следовать заранее определенной схеме, что означает строгую структуру с четко определенными типами данных для каждого столбца.</li>\n	<li><strong>Связи:</strong> Поддерживают сложные запросы и операции с данными, включая присоединения таблиц (joins), транзакции, которые обеспечивают ACID-совместимость (атомарность, согласованность, изолированность, долговечность).</li>\n	<li><strong>Масштабируемость: </strong>Традиционно лучше подходят для вертикального масштабирования, что означает улучшение характеристик одного сервера (например, увеличение CPU, RAM).</li>\n	<li><strong>Примеры:</strong> MySQL, PostgreSQL, Oracle, Microsoft SQL Server.</li>\n</ul>\n\n<p><strong>NoSQL (Нереляционные БД):</strong></p>\n\n<ul>\n	<li><strong>Структура:</strong> Могут быть не только документо-ориентированными, но и ключ-значение, широкие столбцы, графовые базы данных. Они гибкие по отношению к структуре данных; схема данных может быть динамически изменена и не требует предварительного определения.</li>\n	<li><strong>Связи:</strong> Запросы обычно проще, и меньше поддержки для сложных операций с данными. ACID-транзакции поддерживаются не всеми данными системами.</li>\n	<li><strong>Масштабируемость: </strong>Разработаны с учетом горизонтального масштабирования, что означает добавление большего количества серверов или узлов в кластер для обработки большего объема данных и трафика.</li>\n	<li><strong>Примеры: </strong>MongoDB (документо-ориентированная), Redis (ключ-значение), Cassandra (широкие столбцы), Neo4j (графовые).</li>\n</ul>\n\n<p><strong>Основные различия:</strong><br />\n1. <strong>Схема данных:</strong> SQL требует строгой предварительной схемы, в то время как NoSQL более гибкий и позволяет хранить неструктурированные или полуструктурированные данные.<br />\n2. <strong>Типы запросов и операции с данными:</strong> SQL поддерживает сложные запросы и операции, NoSQL обеспечивает более быструю запись и чтение за счет более простых запросов.<br />\n3. <strong>Масштабируемость:</strong> SQL базы данных традиционно масштабируются вертикально, в то время как NoSQL базы данных разработаны для горизонтального масштабирования.<br />\n4. <strong>Транзакции: </strong>SQL базы данных обеспечивают строгую поддержку ACID-транзакций, в то время как в NoSQL подходы к транзакциям могут варьироваться, и не все из них поддерживают полную ACID-совместимость.</p>\n\n<p>Выбор между SQL и NoSQL зависит от конкретных требований к данным, предполагаемого объема и структуры данных, необходимости масштабирования и других факторов специфического проекта.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(18,'Лямбда',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Лямбда</strong>&nbsp;представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>\n\n<p>Основу лямбда-выражения составляет&nbsp;<em>лямбда-оператор</em>, который представляет стрелку&nbsp;<code>-&gt;</code>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.</p>\n\n<p>Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.</p>\n\n<pre>\n<code>interface Operationable {\n    int calculate(int x, int y);\n}\n\npublic static void main(String[] args) {\n    Operationable operation = (x, y) -&gt; x + y;     \n    int result = operation.calculate(10, 20);\n    System.out.println(result); //30\n}</code></pre>\n\n<p>По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.</p>\n\n<ul>\n	<li>\n	<p><em>Отложенное выполнение (deferred execution) лямбда-выражения</em>- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.</p>\n	</li>\n	<li>\n	<p><em>Параметры лямбда-выражения</em>&nbsp;должны соответствовать по типу параметрам метода функционального интерфейса:</p>\n\n	<pre>\n<code>operation = (int x, int y) -&gt; x + y;\n//При написании самого лямбда-выражения тип параметров разрешается не указывать:\n(x, y) -&gt; x + y;\n//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,\n() -&gt; 30 + 20;\n//Если метод принимает только один параметр, то скобки можно опустить:\nn -&gt; n * n;</code></pre>\n	</li>\n</ul>\n\n<ul>\n	<li><em>Конечные лямбда-выражения</em>&nbsp;не обязаны возвращать какое-либо значение.\n\n	<pre>\n<code>interface Printable {\n    void print(String s);\n}\n \npublic static void main(String[] args) {\n    Printable printer = s -&gt; System.out.println(s);\n    printer.print(\"Hello, world\");\n}</code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n	<li><em>Блочные лямбда-выражения</em>&nbsp;обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции&nbsp;<code>if</code>,&nbsp;<code>switch</code>, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор&nbsp;<code>return</code>:\n	<pre>\n<code>Operationable operation = (int x, int y) -&gt; {       \n    if (y == 0) {\n        return 0;\n    }\n    else {\n        return x / y;\n    }\n};</code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n	<li><em>Передача лямбда-выражения в качестве параметра метода</em>:\n	<pre>\n<code>interface Condition {\n    boolean isAppropriate(int n);\n}\n\nprivate static int sum(int[] numbers, Condition condition) {\n    int result = 0;\n    for (int i : numbers) {\n        if (condition.isAppropriate(i)) {\n            result += i;\n        }\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -&gt; n != 0));\n} </code></pre>\n\n	<p>&nbsp;</p>\n	</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Lambda-выражения &mdash; это способ предоставления четкой и компактной формы для представления экземпляра функционального интерфейса. Функциональный интерфейс, напомню, это интерфейс с одним абстрактным методом. Эти выражения позволяют вам выполнять функциональное программирование, упрощая создание анонимных классов и делая код более читаемым и лаконичным.</p>\n\n<p>Данное выражение состоит из списка параметров, символа стрелки <strong>`-&gt;` </strong>и тела выражения. Тело может быть выражением или блоком кода. Если тело выражения состоит из одного выражения, фигурные скобки необязательны, и значение выражения автоматически возвращается. Если тело содержит блок кода, он должен быть заключен в фигурные скобки, и вам может потребоваться использовать <strong>`return`</strong> для возврата значения (если метод не <strong>`void`</strong>).</p>\n\n<p><strong>Пример его использования:</strong></p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; names = Arrays.asList(\"John\", \"Jane\", \"Doe\", \"Sarah\");\n\n// Сортировка списка строк по длине с использованием lambda-выражения\nCollections.sort(names, (String a, String b) -&gt; a.length() - b.length());\n\nnames.forEach(name -&gt; System.out.println(name));</code></pre>\n\n<p>В этом примере мы сначала сортируем список имен по длине с помощью такого выражения, переданного в метод <strong>`Collections.sort()`</strong>. Затем мы используем еще одно lambda-выражение с методом<strong> `forEach` </strong>для вывода всех имен в списке. Это показывает, как они могут сделать код более выразительным и избавить от необходимости явного создания анонимных классов для реализации интерфейсов с одним методом.</p>\n\n<p>Lambda-выражения особенно полезны при работе с коллекциями и API потоков (Streams API), позволяя выполнять операции фильтрации, сортировки, преобразования и агрегирования коллекций данных с минимальным синтаксисом и усилиями.</p>\n\n<p>Lambda-выражения &mdash; это компактный способ представления функционального интерфейса, который упрощает код и делает его более читаемым, особенно при работе с коллекциями и потоками данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(19,'Индексы в бд',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Индекс (index)</strong>&nbsp;&mdash; объект базы данных, создаваемый с целью повышения производительности выборки данных.</p>\n\n<p>Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.</p>\n\n<p>Преимущества</p>\n\n<ul>\n	<li>ускорение поиска и сортировки по определенному полю или набору полей.</li>\n	<li>обеспечение уникальности данных.</li>\n</ul>\n\n<p>Недостатки</p>\n\n<ul>\n	<li>требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.</li>\n	<li>замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.</li>\n</ul>\n\n<p>Индексы предпочтительней для:</p>\n\n<ul>\n	<li>Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;</li>\n	<li>Поля, по которому проводится сортировка данных;</li>\n	<li>Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;</li>\n	<li>Поля, которое объявлено первичным ключом (primary key);</li>\n	<li>Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.</li>\n</ul>\n\n<p>Использование индексов нецелесообразно для:</p>\n\n<ul>\n	<li>Полей, которые редко используются в запросах;</li>\n	<li>Полей, которые содержат всего два или три значения, например:&nbsp;<em>мужской</em>,&nbsp;<em>женский пол</em>&nbsp;или значения&nbsp;<em>&laquo;да&raquo;</em>,&nbsp;<em>&laquo;нет&raquo;</em>.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Индексы &mdash; это структуры данных, которые улучшают скорость операций выборки данных (SELECT), обновления (UPDATE) и удаления (DELETE), предоставляя быстрый доступ к данным. Они создаются на одном или нескольких полях таблиц базы данных и могут значительно сократить количество данных, которые нужно просканировать при выполнении запроса. Основная цель индекса &mdash; ускорить поиск и доступ к данным в таблице.</p>\n\n<p><strong>Как работают индексы:</strong><br />\n1. <strong>Без индекса: </strong>База данных должна просканировать всю таблицу, чтобы найти строки, соответствующие критериям запроса. Это называется полным сканированием таблицы и может быть очень медленным для больших таблиц.</p>\n\n<p>2. <strong>С индексом: </strong>База данных может использовать индекс для быстрого нахождения строк, соответствующих критериям запроса, без необходимости сканировать всю таблицу. Это значительно ускоряет операцию поиска.</p>\n\n<p><strong>Индексы могут быть различных типов, включая:</strong></p>\n\n<ul>\n	<li><strong>B-tree (B-дерево):</strong> Наиболее часто используемый тип, который поддерживает данные упорядоченными, что упрощает поиск, вставку, удаление и доступ к диапазонам данных.</li>\n	<li><strong>Hash (Хеш):</strong> Используется для поиска точных совпадений и не поддерживает упорядоченность или поиск по диапазону. Хеш-индексы обычно используются для таблиц с высокой частотой запросов по конкретным значениям.</li>\n	<li><strong>Full-text (Полнотекстовый):</strong> Особый тип, предназначенный для улучшения поиска по текстовым полям, позволяя выполнять поиск по словам внутри текстовых данных.</li>\n</ul>\n\n<p><strong>Создание индексов также имеет свои недостатки:</strong></p>\n\n<ul>\n	<li><strong>Производительность записи:</strong> При добавлении или обновлении данных в таблице все индексы, связанные с этой таблицей, также должны быть обновлены. Это может замедлить операции записи.</li>\n	<li><strong>Занимаемое пространство:</strong> Занимают дополнительное пространство в памяти или на диске.</li>\n</ul>\n\n<p>Их использованиетребует тщательного планирования и анализа. Необходимо учитывать, какие запросы чаще всего выполняются, и создавать индексы для тех столбцов, которые часто используются в условиях поиска.</p>\n\n<p>Индексы &mdash; это структуры данных, используемые базами данных для ускорения поиска и доступа к данным. Они могут значительно повысить производительность чтения, но влияют на производительность записи и занимают дополнительное пространство.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(20,'Нормализация баз данных','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><em>Нормализация</em>&nbsp;- это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>\n\n<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p></p>\n                        \n                        <p class=\"card-text\"><small class=\"text-muted\">Oct. 21, 2023, <a class=\"link-secondary link-offset-2 link-offset-3-hover link-underline link-underline-opacity-0 link-underline-opacity-75-hover\" target=\"_blank\"  href=\"https://github.com/enhorse/java-interview/blob/master/db.md#Что-такое-нормализация\">Источник</a></small></p>\n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><em>Нормализация</em>&nbsp;- это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>\n\n<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Нормализация баз данных &mdash; это процесс организации данных в БД для уменьшения избыточности и улучшения целостности данных. Этот процесс включает разделение больших таблиц на меньшие и связанные таблицы и определение отношений между ними для минимизации дублирования информации и зависимости данных. Нормализация помогает оптимизировать структуру БД, облегчая её расширение, обновление и поддержку.</p>\n\n<p><strong>Цели:</strong><br />\n1. <strong>Избежание избыточности данных:</strong> Уменьшение повторяющихся данных в таблицах.<br />\n2. <strong>Улучшение целостности данных:</strong> Обеспечение точности и надежности данных путем установления правил и ограничений.<br />\n3. <strong>Оптимизация запросов: </strong>Улучшение производительности базы данных за счет сокращения объема данных, обрабатываемых в запросах.</p>\n\n<p>Она обычно достигается путем применения серии &quot;нормальных форм&quot; &mdash; правил, которые должны быть применены к структуре базы данных. Существует несколько нормальных форм, каждая из которых решает определенные проблемы избыточности и зависимости данных. Наиболее часто используются первая (1NF), вторая (2NF), третья (3NF) и иногда четвертая (4NF) и пятая (5NF) нормальные формы.</p>\n\n<p>1. <strong>Первая нормальная форма (1NF):</strong> Требует, чтобы значения в каждой колонке таблицы были атомарными (неделимыми), и каждая колонка содержала значения только одного типа. Также требуется уникальность всех строк в таблице.</p>\n\n<p>2. <strong>Вторая нормальная форма (2NF):</strong> Достигается путем удаления данных, которые зависят только от части первичного ключа в таблицах с составным ключом.</p>\n\n<p>3. <strong>Третья нормальная форма (3NF):</strong> Требует, чтобы все данные в таблице были зависимы только от первичного ключа и устраняет транзитивные зависимости (когда одно поле зависит от другого поля, которое не является первичным ключом).</p>\n\n<p>4. <strong>Четвертая нормальная форма (4NF):</strong> Дополнительно устраняет многозначные зависимости, когда наличие двух или более независимых отношений в одной таблице вызывает избыточность.</p>\n\n<p>Применение ее улучшает структуру базы данных, но также важно найти баланс, поскольку излишняя нормализация может привести к сложности запросов и снижению производительности из-за необходимости множественных присоединений таблиц. В некоторых случаях для улучшения производительности чтения данных может потребоваться денормализация &mdash; процесс добавления избыточности обратно в базу данных.</p>\n\n<p>Нормализация баз данных &mdash; это процесс проектирования структуры базы данных для минимизации избыточности и улучшения целостности данных, что достигается путем разделения таблиц на более мелкие, связанные таблицы и определения отношений между ними.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(21,'Что такое bean','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Термин &quot;bean&quot; обозначает объект, который управляется Spring IoC (Inversion of Control) контейнером. Этот контейнер отвечает за создание, инициализацию, сборку и управление такими объектами. Beans являются основой приложения, построенного на Spring, и представляют собой компоненты, из которых состоит приложение. Они могут быть контроллерами, сервисами, репозиториями данных, компонентами для доступа к данным, конфигурационными классами и т. д.</p>\n\n<p>Создание и управление bean-компонентами обычно происходит через аннотации или XML-конфигурацию. Примеры аннотаций включают <strong>`@Component`</strong>, <strong>`@Service`</strong>, <strong>`@Repository`</strong>, <strong>`@Controller`</strong>, каждая из которых указывает на определенный тип или роль компонента в приложении. Контейнер автоматически обнаруживает такие аннотированные классы при запуске и регистрирует их в качестве бинов.</p>\n\n<p>Пример простого Spring bean, аннотированного как <strong>`@Service`</strong>:</p>\n\n<pre>\n<code class=\"language-java\">@Service\npublic class MyService {\n    public String sayHello() {\n        return \"Hello, Spring!\";\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`MyService`</strong> будет автоматически обнаружен Spring при сканировании пакетов и зарегистрирован в контексте приложения как bean. После регистрации он может быть внедрен и использован в других компонентах приложения через механизмы внедрения зависимостей (DI).</p>\n\n<p><strong>Ключевые аспекты работы с бинами:</strong></p>\n\n<ul>\n	<li><strong>Внедрение зависимостей (Dependency Injection):</strong> Этот контейнер внедряет объекты в бины автоматически, уменьшая связность между компонентами и упрощая их тестирование.</li>\n	<li><strong>Объявление бинов:</strong> Может осуществляться через аннотации на классах или явно в XML-конфигурации или Java-конфигурации.</li>\n	<li><strong>Управление жизненным циклом:</strong> Позволяет настраивать поведение бинов на различных этапах их жизненного цикла, например, при создании, после инициализации и перед уничтожением.</li>\n</ul>\n\n<p>bean &mdash; это объект, управляемый Spring IoC контейнером, который представляет собой компонент приложения. Beans могут быть автоматически обнаружены и созданы Spring, а также внедрены в другие компоненты, обеспечивая слабую связанность и высокую гибкость приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',3),(22,'Что такое deadlock','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Deadlock (взаимная блокировка) &mdash; это ситуация в многопоточном программировании, при которой два или более потока вечно ожидают друг друга, освободят ли они ресурсы, занятые в данный момент. Каждый из потоков держит замок (lock) на некотором ресурсе и ожидает получения замка на другом ресурсе, который в это время занят другим потоком. В результате ни один из потоков не может продолжить выполнение, поскольку каждый из них ждет освобождения ресурса, занятого другим потоком.</p>\n\n<p><strong>Пример:</strong></p>\n\n<p>Представьте ситуацию, где есть два потока и два ресурса (например, два файла или два объекта в памяти).</p>\n\n<ul>\n	<li>Поток 1 захватывает ресурс A и ждет освобождения ресурса B.</li>\n	<li>Поток 2 захватывает ресурс B и ждет освобождения ресурса A.</li>\n</ul>\n\n<p>В такой ситуации оба потока не могут продолжить выполнение, так как каждый из них ожидает освобождения ресурса, уже захваченного другим потоком. Это и есть deadlock.</p>\n\n<p>Чтобы избежать такой ситуации, нужно использовать стратегии, такие как:</p>\n\n<p>1. <strong>Предотвращение зацикливания:</strong> Все потоки должны запрашивать ресурсы в одном и том же порядке, даже если это означает, что некоторым потокам придется ждать дольше.<br />\n2. <strong>Использование тайм-аутов:</strong> Потоки могут пытаться захватить ресурс с тайм-аутом. Если ресурс не получен за отведенное время, поток откатывает все свои текущие захваты ресурсов и пытается заново захватить их.<br />\n3. <strong>Обнаружение взаимных блокировок:</strong> Система может активно обнаруживать циклы ожидания и прерывать один из потоков для разрешения блокировки.<br />\n4. <strong>Использование однопоточных моделей:</strong> В некоторых случаях можно избежать проблем с многопоточностью, используя асинхронное программирование или реактивные модели, где логика выполнения не блокируется ожиданием ресурсов.</p>\n\n<p>Deadlock &mdash; это состояние, когда два или более потока вечно ждут друг друга, освободят ли они занятые ресурсы, что приводит к остановке выполнения программы. Избежать этого можно с помощью правильного проектирования и стратегий управления доступом к ресурсам.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Взаимная блокировка (deadlock)</strong>&nbsp;- явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:</p>\n\n<ol>\n	<li>взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.</li>\n	<li>удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.</li>\n	<li>отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.</li>\n	<li>цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.</li>\n</ol>\n\n<p>Простейший способ избежать взаимной блокировки &ndash; не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(23,'Каким образом HashMap связан с Set\'ом',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`HashMap`</strong> и<strong> `Set` </strong>связаны друг с другом через использование коллекции <strong>`HashSet`</strong>. Он внутренне использует <strong>`HashMap` </strong>для хранения своих элементов. Основная идея этой связи заключается в том, что<strong> `HashSet` </strong>обеспечивает уникальность своих элементов с помощью хеш-таблицы, а <strong>`HashMap`</strong> предоставляет эту хеш-таблицу как основу для хранения данных.</p>\n\n<p><strong>Как HashSet использует HashMap</strong></p>\n\n<p>Когда вы добавляете элемент в него, этот элемент используется как ключ во внутреннем<strong> `HashMap`</strong>. Значением для этого ключа является предопределённый статический объект, общий для всех элементов (обычно <strong>`PRESENT`</strong>, просто маркер, который не используется). Это делается для оптимизации памяти и производительности, так как интерес представляет только наличие ключа (элемента в <strong>`HashSet`</strong>), а не значение, ассоциированное с этим ключом.</p>\n\n<pre>\n<code class=\"language-java\">public class HashSet&lt;E&gt;\n    extends AbstractSet&lt;E&gt;\n    implements Set&lt;E&gt;, Cloneable, java.io.Serializable\n{\n    private transient HashMap&lt;E,Object&gt; map;\n\n    // Предопределенный объект, используемый в качестве значения для всех ключей\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap&lt;&gt;();\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    // Другие методы...\n}</code></pre>\n\n<p>Преимущества этой связи</p>\n\n<ul>\n	<li><em><strong>Уникальность элементов:</strong></em> <strong>`HashSet` </strong>гарантирует, что каждый элемент будет уникальным, так как<strong> `HashMap` </strong>не допускает дублирования ключей.</li>\n	<li><em><strong>Высокая производительность: </strong></em>операции добавления, удаления и поиска в<strong> `HashSet`</strong> выполняются за константное время O(1) в среднем, благодаря хеш-таблице <strong>`HashMap`</strong>.</li>\n	<li><em><strong>Эффективное использование памяти:</strong></em> хранение значения <strong>`PRESENT` </strong>для всех элементов минимизирует потребление памяти, так как не требуется отдельно выделять память под значения элементов.</li>\n</ul>\n\n<p>Эта связь между<strong> `HashSet`</strong> и <strong>`HashMap`</strong> позволяет <strong>`HashSet` </strong>эффективно управлять уникальными элементами, используя хеш-таблицу, и предоставляет разработчикам мощный инструмент для создания коллекций, которые требуют уникальности элементов с высокой производительностью поиска, добавления и удаления.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(24,'Что такое процесс и поток',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Процесс</strong>&nbsp;&mdash; экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>\n\n<p>Для каждого процесса ОС создает так называемое &laquo;виртуальное адресное пространство&raquo;, к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.</p>\n\n<p><strong>Поток&nbsp;</strong>(thread) &mdash; определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Процесс и поток являются фундаментальными концепциями в операционных системах, связанными с выполнением программ.</p>\n\n<p><em><strong>Процесс</strong></em> - это экземпляр выполняющейся программы. Процесс имеет свое изолированное адресное пространство памяти, что означает, что они не могут напрямую взаимодействовать с адресным пространством друг друга. Каждый процесс предоставляет ресурсы, необходимые для выполнения программы, включая память, файловые дескрипторы, и другие ресурсы. Операционная система управляет ими, распределяя процессорное время и ресурсы между ними.</p>\n\n<p><em><strong>Поток</strong></em> - это единица выполнения в рамках процесса. Процесс может содержать несколько потоков, которые могут выполняться параллельно. Все они внутри процесса делят одно и то же адресное пространство памяти и ресурсы, что облегчает обмен данными и коммуникацию между ними, но также требует синхронизации для предотвращения конфликтов при доступе к общим ресурсам. Используются для реализации многозадачности в рамках одного процесса.</p>\n\n<p>Основные отличия между процессом и потоком:</p>\n\n<p>1. <em><strong>Изоляция:</strong></em> Процессы изолированы друг от друга, в то время как потоки внутри одного процесса делят общие ресурсы и адресное пространство.<br />\n2. <em><strong>Ресурсы: </strong></em>Процессы имеют отдельные наборы ресурсов, в то время как потоки делят ресурсы внутри процесса.<br />\n3. <em><strong>Создание и управление: </strong></em>Создание нового процесса обычно более затратно по ресурсам и времени, чем создание нового потока внутри существующего процесса.<br />\n4. <em><strong>Коммуникация: </strong></em>Коммуникация между процессами требует использования механизмов межпроцессного взаимодействия (IPC), таких как каналы, сокеты или общая память. Потоки внутри одного процесса могут обмениваться данными более просто, поскольку у них есть доступ к общей памяти.<br />\n5. <em><strong>Влияние на производительность: </strong></em>Потоки могут эффективно использовать процессорное время, выполняясь параллельно, что может улучшить производительность программы. Создание и управление большим количеством процессов может быть более затратным для системы.</p>\n\n<p>Процесс &ndash; это более тяжеловесная структура, представляющая собой запущенную программу с собственным адресным пространством, в то время как поток &ndash; это более легковесная единица выполнения, работающая в рамках процесса и делающая возможной многозадачность внутри одной программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',5),(25,'HashMap',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`HashMap`</strong> &mdash; это структура данных, которая хранит элементы в виде пар ключ-значение. Она использует хеш-таблицу для эффективного поиска, вставки и удаления элементов. Ключи в ней уникальны, а значения могут дублироваться. Один из ключевых аспектов ее использования заключается в возможности доступа к значениям очень быстро по их ключам.</p>\n\n<p><strong>Как работает HashMap</strong></p>\n\n<p>Когда пара ключ-значение добавляется в нее, ключ проходит через хеш-функцию, которая вычисляет индекс в массиве, где должно быть хранится значение. Этот процесс позволяет ей эффективно находить значение по ключу, обеспечивая доступ за константное время O(1) в идеальном случае. Однако, в случае коллизий хеш-функций (когда разные ключи имеют одинаковый хеш-код и, следовательно, могут быть отнесены к одному и тому же индексу массива), она использует структуру данных &quot;связный список&quot; или &quot;красно-черное дерево&quot; (начиная с Java 8) для хранения всех пар ключ-значение, относящихся к одному индексу. Это немного замедляет процесс поиска до O(log n) для красно-черного дерева в худшем случае.</p>\n\n<p><strong>Особенности HashMap:</strong></p>\n\n<ul>\n	<li><em><strong>Не гарантирует порядка элементов:</strong></em> Порядок хранения элементов не гарантирован, и при добавлении новых элементов порядок может измениться.</li>\n	<li><em><strong>null значения:</strong></em> Позволяет использовать<strong> `null`</strong> как ключ и как значение, но только один <strong>`null`</strong> ключ, в то время как значений<strong> `null`</strong> может быть много.</li>\n	<li><em><strong>Несинхронизированность:</strong></em> По умолчанию не является потокобезопасной. Если несколько потоков одновременно доступают к ней и хотя бы один из потоков изменяет карту, это должно быть синхронизировано внешним образом.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">import java.util.HashMap;\n\npublic class Example {\n    public static void main(String[] args) {\n        // Создание HashMap\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n\n        // Добавление элементов в HashMap\n        map.put(\"Ключ1\", 100);\n        map.put(\"Ключ2\", 200);\n        map.put(\"Ключ3\", 300);\n\n        // Получение значения по ключу\n        int value = map.get(\"Ключ2\"); // 200\n\n        // Проверка наличия ключа или значения\n        boolean keyExists = map.containsKey(\"Ключ1\"); // true\n        boolean valueExists = map.containsValue(300); // true\n\n        // Удаление элемента\n        map.remove(\"Ключ3\");\n    }\n}</code></pre>\n\n<p><br />\n<strong>`HashMap`</strong> является одной из наиболее часто используемых структур данных из-за её гибкости и высокой производительности для операций поиска, вставки и удаления.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(26,'Паттерны проектирования','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Паттерны проектирования &mdash; это проверенные решения для часто встречающихся проблем, с которыми разработчики сталкиваются при проектировании и разработке ПО. Они представляют собой шаблоны для решения задач проектирования в рамках данного контекста. Паттерны помогают сделать систему более гибкой, модульной и адаптируемой к изменениям.</p>\n\n<p>Их обычно делят на три основные категории:</p>\n\n<p>1. <strong>Порождающие (Creational Patterns)</strong></p>\n\n<ul>\n	<li>Эти паттерны обеспечивают механизмы создания объектов, повышая гибкость и повторное использование существующего кода.</li>\n	<li><em><strong>Одиночка (Singleton): </strong></em>Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.</li>\n	<li><em><strong>Фабричный метод (Factory Method):</strong></em> Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемых объектов.</li>\n	<li><em><strong>Абстрактная фабрика (Abstract Factory):</strong></em> Позволяет создавать семейства связанных объектов, не специфицируя их конкретные классы.</li>\n	<li><em><strong>Строитель (Builder): </strong></em>Позволяет создавать сложные объекты пошагово.</li>\n	<li><em><strong>Прототип (Prototype):</strong></em> Позволяет копировать объекты, не вдаваясь в подробности их реализации.</li>\n</ul>\n\n<p>2. <strong>Структурные (Structural Patterns)</strong></p>\n\n<ul>\n	<li><em><strong>Структурные паттерны</strong></em> описывают способы сборки объектов и классов в более крупные структуры, при этом сохраняя гибкость и эффективность структур.</li>\n	<li><em><strong>Адаптер (Adapter):</strong></em> Позволяет объектам с несовместимыми интерфейсами работать вместе.</li>\n	<li><strong><em>Мост (Bridge):</em> </strong>Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.</li>\n	<li><em><strong>Компоновщик (Composite):</strong></em> Позволяет считать единичные объекты и составные объекты единообразно.</li>\n	<li><em><strong>Декоратор (Decorator): </strong></em>Позволяет динамически добавлять новые функции объектам, помещая их в оболочку из других объектов.</li>\n	<li><em><strong>Фасад (Facade):</strong></em> Предоставляет упрощенный интерфейс к сложной системе классов, библиотеке или фреймворку.</li>\n	<li><em><strong>Приспособленец (Flyweight): </strong></em>Эффективно поддерживает большое количество мелких объектов.</li>\n	<li><em><strong>Заместитель (Proxy):</strong></em> Предоставляет заменитель или местозаполнитель для другого объекта, чтобы контролировать доступ к нему.</li>\n</ul>\n\n<p>3. <strong>Поведенческие (Behavioral Patterns)</strong></p>\n\n<ul>\n	<li><em><strong>Поведенческие паттерны</strong></em> регулируют алгоритмы и ответственности между объектами, делают взаимодействие между объектами более гибким.</li>\n	<li><em><strong>Цепочка обязанностей (Chain of Responsibility):</strong></em> Позволяет передавать запросы последовательно по цепочке обработчиков.</li>\n	<li><em><strong>Команда (Command):</strong></em> Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать и т.д.</li>\n	<li><strong><em>Итератор (Iterator):</em> </strong>Предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления.</li>\n	<li><strong><em>Посредник (Mediator):</em> </strong>Уменьшает сложность взаимодействия между объектами, предоставляя централизованное место для управления ими.</li>\n	<li><strong><em>Хранитель (Memento):</em> </strong>Позволяет сохранять и восстанавливать предыдущее состояние объекта без раскрытия подробностей его реализации.</li>\n	<li><em><strong>Наблюдатель (Observer):</strong> </em>Позволяет объектам получать уведомления об изменении состояния других объектов.</li>\n	<li><em><strong>Состояние (State):</strong></em> Позволяет объекту изменять свое поведение при изменении его внутреннего состояния.</li>\n	<li><em><strong>Стратегия (Strategy):</strong></em> Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.</li>\n	<li><em><strong>Шаблонный метод (Template Method):</strong> </em>Определяет скелет алгоритма, позволяя подклассам переопределять некоторые шаги алгоритма, не изменяя его структуру.</li>\n	<li><em><strong>Посетитель (Visitor): </strong></em>Позволяет добавлять новые операции к объектам без изменения классов этих объектов.</li>\n</ul>\n\n<p>Каждый паттерн решает свою уникальную задачу в контексте проектирования ПО, облегчая разработку и поддержку сложных систем.&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',6),(27,'Участки памяти в JVM',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Java Virtual Machine (JVM) управляет системной памятью через различные участки (регионы), каждый из которых выполняет свою роль в процессе выполнения программы. Основные участки памяти следующие:</p>\n\n<p>1. <em><strong>Куча (Heap):</strong></em> Это центральный репозиторий для хранения объектов и экземпляров классов во время выполнения программы. Куча делится на несколько подучастков, таких как Young Generation (молодое поколение), Old Generation (старое поколение) и, иногда, Permanent Generation (PermGen) или Metaspace (начиная с Java 8), в зависимости от ее версии. Сборка мусора (Garbage Collection) активно управляет этой областью памяти, автоматически освобождая пространство, занимаемое объектами, на которые больше нет ссылок.</p>\n\n<p>2. <em><strong>Стек методов (Method Area/Stack):</strong></em> В стеке хранятся локальные переменные, частичные результаты вычислений и информация о вызовах методов для каждого потока выполнения. Каждый поток имеет свой собственный стек, и он создается в момент, когда поток начинает выполнение. Стек методов работает по принципу LIFO (последним пришел &mdash; первым ушел).</p>\n\n<p>3. <em><strong>Куча постоянных (Permanent Generation/Metaspace): </strong></em>Эта область используется для хранения метаданных классов и методов, строковых литералов и других констант класса. Был заменен на Metaspace, который использует нативную память для хранения метаданных классов, что позволяет улучшить производительность и уменьшить вероятность возникновения ошибки <strong>`OutOfMemoryError`</strong> из-за переполнения PermGen.</p>\n\n<p>4. <em><strong>Программный счетчик (Program Counter Register):</strong></em> Этот участок памяти содержит адрес текущей инструкции, которая выполняется в данный момент. Как и стек методов, для каждого потока выполнения существует свой собственный программный счетчик.</p>\n\n<p>5. <em><strong>Нативный стек (Native Stack):</strong></em> Эта область памяти используется для выполнения нативного кода, написанного на других языках программирования, а не на Java. Нативный стек работает аналогично стеку методов, но предназначен для обработки вызовов нативных методов.</p>\n\n<p>Эти участки памяти играют ключевую роль в выполнении программ и управлении ресурсами. JVM оптимизирует использование этих областей для повышения производительности и эффективности работы программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',1),(28,'Полиморфизм','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Полиморфизм</strong>&nbsp;&ndash; это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</p>\n\n<p>Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).</p>\n\n<p><em>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля &ndash; джойстик.</em></p>\n\n<p><em>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.</em></p>\n\n<p><em>Полиморфная переменная</em>, это переменная, которая может принимать значения разных типов, а&nbsp;<em>полиморфная функция</em>, это функция, у которой хотя бы один аргумент является полиморфной переменной. Выделяют два вида полиморфных функций:</p>\n\n<ul>\n	<li><em>ad hoc</em>, функция ведет себя по разному для разных типов аргументов (например, функция&nbsp;<code>draw()</code>&nbsp;&mdash; рисует по разному фигуры разных типов);</li>\n	<li><em>параметрический</em>, функция ведет себя одинаково для аргументов разных типов (например, функция&nbsp;<code>add()</code>&nbsp;&mdash; одинаково кладет в контейнер элементы разных типов).</li>\n</ul>\n\n<p>Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.</p>\n\n<p>Пример:</p>\n\n<p>Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:</p>\n\n<pre>\n<code>public class User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public void callAnotherUser(int number, AbstractPhone phone) {\n// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!\n        phone.call(number);\n    }\n}</code></pre>\n\n<p>Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:</p>\n\n<pre>\n<code>public class ThomasEdisonPhone extends AbstractPhone {\n\n    public ThomasEdisonPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вращайте ручку\");\n        System.out.println(\"Сообщите номер абонента, сэр\");\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}</code></pre>\n\n<p>Обычный стационарный телефон:</p>\n\n<pre>\n<code>public class Phone extends AbstractPhone {\n\n    public Phone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вызываю номер\" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}</code></pre>\n\n<p>И, наконец, крутой видеотелефон:</p>\n\n<pre>\n<code>public class VideoPhone extends AbstractPhone {\n\n    public VideoPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Подключаю видеоканал для абонента \" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"У вас входящий видеовызов...\" + inputNumber);\n    }\n}</code></pre>\n\n<p>Создадим объекты в методе main() и протестируем метод callAnotherUser:</p>\n\n<pre>\n<code>AbstractPhone firstPhone = new ThomasEdisonPhone(1879);\nAbstractPhone phone = new Phone(1984);\nAbstractPhone videoPhone=new VideoPhone(2018);\nUser user = new User(\"Андрей\");\nuser.callAnotherUser(224466,firstPhone);\n// Вращайте ручку\n//Сообщите номер абонента, сэр\nuser.callAnotherUser(224466,phone);\n//Вызываю номер 224466\nuser.callAnotherUser(224466,videoPhone);\n//Подключаю видеоканал для абонента 224466</code></pre>\n\n<p>Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма &ndash; выбор реализации в процессе выполнения программы.</p>\n\n<p>В примерах классов телефонов, приведенных выше, мы использовали переопределение методов &ndash; прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути, это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы.</p>\n\n<p>Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Полиморфизм &mdash; это принцип, позволяющий объектам с одинаковым интерфейсом иметь различную реализацию. Этот термин происходит от греческих слов, означающих &quot;много форм&quot;. В контексте ООП, полиморфизм позволяет одному и тому же методу работать по-разному в зависимости от контекста, в котором он вызывается, или от объекта, к которому он применяется.</p>\n\n<p>1. <em><strong>Статический (компиляционный) полиморфизм: </strong></em>Реализуется с помощью перегрузки методов и операторов. При перегрузке методов методы в одном классе имеют одинаковое имя, но различаются количеством и типом параметров. Компилятор определяет, какой метод вызывать, исходя из аргументов вызова метода.</p>\n\n<p>&nbsp; &nbsp;Пример:</p>\n\n<pre>\n<code class=\"language-java\">   public class Example {\n       public void display(int a) {\n           System.out.println(\"Число: \" + a);\n       }\n       public void display(String a) {\n           System.out.println(\"Строка: \" + a);\n       }\n   }</code></pre>\n\n<p>2. <em><strong>Динамический (выполнения) полиморфизм:</strong></em> Реализуется с помощью переопределения методов. В этом случае подклассы имеют методы, которые имеют такое же имя и сигнатуру, как и в суперклассе, но реализация методов может отличаться. Какой метод будет вызван, определяется во время выполнения программы, основываясь на типе объекта.</p>\n\n<p>&nbsp; &nbsp;Пример:</p>\n\n<pre>\n<code class=\"language-java\">   class Animal {\n       void sound() {\n           System.out.println(\"Животное издает звук\");\n       }\n   }\n   class Dog extends Animal {\n       @Override\n       void sound() {\n           System.out.println(\"Собака лает\");\n       }\n   }\n\n   Использование:\n   Animal myAnimal = new Dog();\n   myAnimal.sound(); // Выведет: Собака лает</code></pre>\n\n<p><strong>Зачем нужен полиморфизм?</strong></p>\n\n<ul>\n	<li><em><strong>Гибкость и расширяемость кода: </strong></em>Позволяет писать более обобщенный код, который может работать с объектами разных классов. Это упрощает добавление новых классов, которые могут использоваться существующим кодом без его изменения.</li>\n	<li><em><strong>Уменьшение связности:</strong></em> Помогает снизить зависимость между компонентами системы, поскольку компоненты могут взаимодействовать друг с другом через общие интерфейсы, не заботясь о конкретной реализации.</li>\n	<li><em><strong>Сокрытие реализации: </strong></em>Клиентский код может использовать интерфейс без знания о внутренней реализации объекта, что повышает безопасность и модульность программы.</li>\n</ul>\n\n<p>Полиморфизм является ключевым элементом объектно-ориентированного программирования, обеспечивая гибкость и возможности для масштабирования и модификации программ без значительного переписывания кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(29,'final vs. finally vs. finalize','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Модификатор&nbsp;<code>final</code>:</p>\n\n<ul>\n	<li>Класс не может иметь наследников;</li>\n	<li>Метод не может быть переопределен в классах наследниках;</li>\n	<li>Поле не может изменить свое значение после инициализации;</li>\n	<li>Локальные переменные не могут быть изменены после присвоения им значения;</li>\n	<li>Параметры методов не могут изменять своё значение внутри метода.</li>\n</ul>\n\n<p>Оператор&nbsp;<code>finally</code>&nbsp;гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке&nbsp;<code>try-catch</code>.</p>\n\n<p>Метод&nbsp;<code>finalize()</code>&nbsp;вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>\npublic class MainClass {\n\n	public static void main(String args[]) {\n		TestClass a = new TestClass();\n		System.out.println(\"result of a.a() is \" + a.a());\n		a = null;\n		System.gc(); // Принудительно зовём сборщик мусора\n		a = new TestClass();\n		System.out.println(\"result of a.a() is \" + a.a());\n		System.out.println(\"!!! done\");\n	}\n\n}</code></pre>\n\n<pre>\n<code>public class TestClass {\n\n	public int a() {\n		try {\n			System.out.println(\"!!! a() called\");\n			throw new Exception(\"\");\n		} catch (Exception e) {\n			System.out.println(\"!!! Exception in a()\");\n			return 2;\n		} finally {\n			System.out.println(\"!!! finally in a() \");\n		}\n	}\n\n	@Override\n	protected void finalize() throws Throwable {\n		System.out.println(\"!!! finalize() called\");\n		super.finalize();\n	}\n}</code></pre>\n\n<p>Результат выполнения:</p>\n\n<pre>\n<code>!!! a() called\n!!! Exception in a()\n!!! finally in a() \nresult of a.a() is 2\n!!! a() called\n!!! Exception in a()\n!!! finally in a() \n!!! finalize() called\nresult of a.a() is 2\n!!! done</code></pre>\n\n<p>&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевые слова <strong>`final`</strong>,<strong> `finally`</strong>, и <strong>`finalize` </strong>имеют совершенно разные цели и контексты использования, хотя на первый взгляд могут показаться похожими из-за схожести их названий.</p>\n\n<p><strong>final</strong></p>\n\n<p>Это модификатор, который может быть использован с переменными, методами и классами.</p>\n\n<ul>\n	<li>Когда он применяется к переменной, это означает, что переменная может быть присвоена только один раз и её значение не может быть изменено после присваивания.</li>\n	<li>Когда он используется с методом, это предотвращает переопределение метода в подклассах.</li>\n	<li>Когда он применяется к классу, это означает, что класс не может быть наследован.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">final int x = 100; // переменная, которую нельзя изменить\npublic final void myMethod() {} // метод, который нельзя переопределить\npublic final class MyFinalClass {} // класс, от которого нельзя наследоваться</code></pre>\n\n<p><strong>finally</strong></p>\n\n<p>Это блок кода, который используется вместе с блоками <strong>`try`</strong> и <strong>`catch` </strong>для обработки исключений. Блок<strong> `finally` </strong>выполняется всегда после выполнения блока <strong>`try`/`catch`</strong>, независимо от того, было ли выброшено исключение или нет. Это идеальное место для кода очистки, например, для закрытия файловых потоков или освобождения других ресурсов.</p>\n\n<pre>\n<code class=\"language-java\">try {\n    // код, который может вызвать исключение\n} catch (Exception e) {\n    // обработка исключения\n} finally {\n    // код, который выполняется всегда\n}</code></pre>\n\n<p><strong>finalize</strong></p>\n\n<p>Это метод класса <strong>`Object`</strong>, который вызывается сборщиком мусора перед тем, как объект будет уничтожен. Этот метод можно переопределить в классе для реализации очистки ресурсов или других операций перед уничтожением объекта. Однако его использование не рекомендуется из-за его непредсказуемости и малой эффективности, а также потому, что он может вызвать задержку в сборке мусора.</p>\n\n<pre>\n<code class=\"language-java\">@Override\nprotected void finalize() throws Throwable {\n    try {\n        // очистка ресурсов\n    } finally {\n        super.finalize();\n    }\n}</code></pre>\n\n<ul>\n	<li><em><strong>`final`</strong> </em>используется для создания констант, предотвращения наследования классов и переопределения методов.</li>\n	<li><em><strong>`finally`</strong></em> гарантирует выполнение кода после блока<strong> `try`/`catch`</strong>, обычно для очистки ресурсов.</li>\n	<li><strong><em>`finalize`</em> </strong>предназначен для очистки перед уничтожением объекта, но его использование не рекомендуется.</li>\n</ul>\n\n<p>Каждое из этих ключевых слов имеет уникальное применение и важно в контексте разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(30,'Чем singleton отличается от prototype',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Singleton и Prototype относятся к категории порождающих шаблонов проектирования. Они решают разные проблемы и имеют разные применения в разработке программного обеспечения.</p>\n\n<p><strong>Singleton</strong> предназначен для обеспечения того, чтобы класс имел только один экземпляр во всем приложении и предоставлял глобальную точку доступа к этому экземпляру. Это достигается за счет того, что конструктор класса делается приватным, а создание экземпляра класса осуществляется через статический метод, который проверяет, существует ли уже экземпляр этого класса, и если нет, то создает его. Часто используется для управления ресурсами, такими как соединение с базой данных, где необходимо использовать только одно соединение на всё приложение.</p>\n\n<pre>\n<code class=\"language-java\">public class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}</code></pre>\n\n<p><strong>Prototype</strong>, напротив, используется для создания новых объектов, копированием существующего объекта-прототипа. Это полезно, когда создание экземпляра класса является ресурсоемким процессом или когда требуется создать копию объекта, сохраняя его состояние. Это часто достигается с помощью реализации интерфейса<strong> `Cloneable`</strong> и переопределения метода <strong>`clone()`</strong>.</p>\n\n<pre>\n<code class=\"language-java\">public class Prototype implements Cloneable {\n    private String field;\n\n    public Prototype(String field) {\n        this.field = field;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}</code></pre>\n\n<p><strong>Основные отличия:</strong></p>\n\n<ul>\n	<li><em><strong>Цель использования: </strong></em>Singleton гарантирует, что класс имеет только один экземпляр, в то время как Prototype предназначен для создания новых объектов путем копирования существующего объекта.</li>\n	<li><em><strong>Метод создания объекта:</strong></em> В Singleton объект создается через статический метод, контролирующий его экземпляр, в Prototype новый объект создается копированием (клонированием) существующего.</li>\n	<li><em><strong>Применение:</strong></em> Singleton часто используется для управления доступом к ресурсам, которые должны быть единственными в приложении, например, соединение с базой данных. Prototype используется, когда нужно избежать затрат на создание объекта с нуля, вместо этого копируя существующий объект.</li>\n</ul>\n\n<p>Основное отличие между Singleton и Prototype заключается в их цели и способе создания объектов: Singleton обеспечивает единственность экземпляра класса, в то время как Prototype фокусируется на создании новых объектов путем копирования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',6),(31,'Race condition','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Race condition (условие гонки) &mdash; это ситуация в многопоточной или распределенной системе, когда порядок выполнения операций влияет на результат работы программы, и этот порядок не может быть гарантирован. То есть, результат выполнения программы становится непредсказуемым из-за соревнования между потоками за доступ к общим ресурсам.</p>\n\n<p><strong>Часто возникают в следующих случаях:</strong></p>\n\n<ul>\n	<li><em><strong>Доступ к общим данным: </strong></em>Если два или более потока читают и пишут в одну и ту же переменную без должной синхронизации, конечное значение переменной может зависеть от того, в каком порядке потоки выполняют свои операции.</li>\n	<li><em><strong>Зависимость от порядка выполнения:</strong></em> Когда корректность выполнения программы зависит от порядка выполнения операций между потоками, без явного контроля этого порядка.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Counter {\n    private int count = 0;\n\n    public void increment() {\n        count++; // Несмотря на кажущуюся атомарность, операция не атомарна и состоит из трех шагов: чтение, инкремент, запись\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class RaceConditionDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(counter.getCount()); // Ожидаемый результат 2000, но может быть меньше из-за условия гонки\n    }\n}</code></pre>\n\n<p>В этом примере, хотя каждый поток пытается увеличить счетчик на 1000, итоговый результат может быть меньше 2000 из-за них. Это происходит потому, что операция инкремента (<strong>`count++`</strong>) не атомарна и может быть прервана между чтением значения <strong>`count` </strong>и записью обновленного значения обратно в память. В результате, несколько потоков могут прочитать одно и то же значение <strong>`count`</strong> перед тем, как другие потоки успеют его обновить.</p>\n\n<p><strong>Решение проблемы</strong></p>\n\n<p>Для предотвращения этого используются механизмы синхронизации, такие как блокировки (<strong>`synchronized`</strong> блоки), мьютексы, семафоры и другие средства для контроля доступа к общим ресурсам. Эти механизмы гарантируют, что только один поток может выполнять критический участок кода, который взаимодействует с общим ресурсом, в любой момент времени.</p>\n\n<pre>\n<code class=\"language-java\">public synchronized void increment() {\n    count++;\n}</code></pre>\n\n<p>Добавление <strong>`synchronized`</strong> к методу<strong> `increment()`</strong> гарантирует, что в каждый момент времени только один поток может выполнить этот метод, что предотвращает условия гонки в данном случае.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(32,'Жизненный цикл Spring Beans',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Каждый бин (компонент) проходит через жизненный цикл, который начинается с его создания и заканчивается уничтожением. Этот цикл включает в себя ряд этапов, на которых он предоставляет различные точки для настройки поведения бина. Вот основные этапы жизненного цикла:</p>\n\n<p>1. <em><strong>Инстанцирование бина: </strong></em>Создает экземпляр бина из класса определения бина.</p>\n\n<p>2. <em><strong>Заполнение свойств бина:</strong></em> Внедряет значения и ссылки на другие бины в свойства текущего бина, используя конфигурацию, заданную в XML, аннотациях или конфигурации.</p>\n\n<p>3. Вызов методов жизненного цикла `BeanNameAware`, `BeanClassLoaderAware`, `BeanFactoryAware` и т.д.: Если бин реализует один из Aware интерфейсов, он вызывает соответствующие методы, передавая экземпляру бина ссылку на контекст, фабрику бинов и т.д.</p>\n\n<p>4. <em><strong>Post-Processing Bean: </strong></em>Перед инициализацией бина, он дает возможность BeanPostProcessor&#39;ам обработать объект. Это может быть использовано для проксирования бинов или для иной предварительной обработки.</p>\n\n<p>5. <em><strong>Вызов метода инициализации:</strong></em> Если для бина определен метод инициализации (через аннотацию <strong>`@PostConstruct`</strong>, интерфейс <strong>`InitializingBean` </strong>или атрибут<strong> `init-method`</strong> в XML-конфигурации), он вызывает его после того, как все свойства бина были установлены.</p>\n\n<p>6. <em><strong>Готовность к использованию: </strong></em>После вызова метода инициализации бин полностью инициализирован и готов к использованию в приложении.</p>\n\n<p>7. <em><strong>Вызов метода уничтожения: </strong></em>Когда контекст приложения закрывается, и бины должны быть уничтожены, он вызывает метод уничтожения для бинов, которые определяют его (через аннотацию <strong>`@PreDestroy`</strong>, интерфейс <strong>`DisposableBean`</strong> или атрибут <strong>`destroy-method`</strong> в XML-конфигурации).</p>\n\n<p>Эти этапы обеспечивают гибкое управление жизненным циклом бинов, позволяя разработчикам выполнять необходимые действия на каждом этапе, такие как инициализация ресурсов перед использованием бина или очистка ресурсов перед уничтожением бина. Управление жизненным циклом бинов &mdash; ключевая особенность Spring, которая способствует созданию чистого, хорошо структурированного и легко поддерживаемого приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(33,'Идея многопоточности',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Идея многопоточности заключается в параллельном выполнении нескольких задач в рамках одного приложения для более эффективного использования ресурсов компьютера, особенно процессорного времени, и для улучшения отзывчивости программы.</p>\n\n<p>В однопоточном приложении в любой момент времени выполняется только одна задача. Если эта задача включает в себя ожидание (например, ввод пользователя или чтение данных с диска), процессорное время не используется эффективно. Она же позволяет одновременно выполнять другие задачи во время ожидания, тем самым повышая производительность и отзывчивость приложения.</p>\n\n<p>Основные преимущества:</p>\n\n<ul>\n	<li><em><strong>Повышение производительности:</strong></em> Приложения могут выполнять несколько задач одновременно, что особенно эффективно на многоядерных или многопроцессорных системах, где потоки могут физически выполняться параллельно.</li>\n	<li><em><strong>Отзывчивость приложения: </strong></em>В интерактивных приложениях, таких как графические пользовательские интерфейсы, многопоточность позволяет приложению оставаться отзывчивым к действиям пользователя, даже когда выполняются тяжелые задачи в фоновом режиме.</li>\n	<li><em><strong>Эффективное использование ресурсов: </strong></em>Приложения могут более эффективно использовать доступные системные ресурсы, распределяя задачи между потоками, которые затем могут выполняться параллельно.</li>\n</ul>\n\n<p>Однако она также вводит сложность в разработку программного обеспечения, поскольку разработчикам необходимо учитывать вопросы синхронизации доступа к общим ресурсам, управления состоянием потоков и потенциальных проблем с безопасностью потоков, таких как гонки за данные (race conditions), взаимные блокировки (deadlocks) и проблемы с последовательностью операций.</p>\n\n<p>Примером многопоточности может служить создание потоков через наследование от класса<strong> `Thread`</strong> или реализацию интерфейса <strong>`Runnable`</strong>:</p>\n\n<pre>\n<code class=\"language-java\">class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Поток запущен.\");\n    }\n}\n\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Поток запущен через Runnable.\");\n    }\n}\n\npublic class ThreadExample {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        t1.start();\n\n        Thread t2 = new Thread(new MyRunnable());\n        t2.start();\n    }\n}</code></pre>\n\n<p>В этом примере создаются и запускаются два потока, каждый из которых выполняет свою задачу параллельно основному потоку программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(34,'TreeSet и HashSet',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`TreeSet`</strong> и <strong>`HashSet`</strong> являются двумя разными типами коллекций, которые используются для хранения уникальных элементов. Основное различие между ними заключается в их внутренней реализации и порядке хранения элементов, что влияет на скорость выполнения операций добавления, удаления и поиска элементов.</p>\n\n<p><strong>HashSet</strong></p>\n\n<p>Основан на хеш-таблице. Это означает, что он использует функцию хеширования для определения места хранения элемента в коллекции. Основные характеристики:</p>\n\n<ul>\n	<li><strong>Не гарантирует порядок элементов: </strong>Порядок элементов в нем может меняться со временем и не соответствует порядку добавления.</li>\n	<li><strong>Быстрое выполнение операций: </strong>Добавление, удаление и поиск элемента в нем происходит за постоянное время O(1), предполагая, что хеш-функция равномерно распределяет элементы. Однако, плохое хеширование может привести к ухудшению производительности до O(n) в худшем случае.</li>\n	<li><strong>Использование:</strong> Предпочтительнее использовать, когда важна производительность и не требуется упорядоченность элементов.</li>\n</ul>\n\n<p><strong>TreeSet</strong></p>\n\n<p>Реализует интерфейс<strong> `SortedSet`</strong> и хранит элементы в отсортированном порядке по возрастанию. Внутренне он основан на красно-чёрном дереве. Основные характеристики:</p>\n\n<ul>\n	<li><strong>Гарантирует порядок элементов: </strong>Элементы в нем автоматически сортируются, что позволяет легко получить доступ к самым маленьким или самым большим элементам.</li>\n	<li><strong>Время выполнения операций: </strong>Операции добавления, удаления и поиска в нем выполняются за логарифмическое время O(log n), что медленнее, чем в <strong>`HashSet`</strong>.</li>\n	<li><strong>Использование: </strong>Подходит для случаев, когда необходимо поддерживать упорядоченность элементов, например, для вывода элементов в отсортированном порядке или для выполнения диапазонных поисков.</li>\n</ul>\n\n<p>Основное различие между <strong>`HashSet`</strong> и <strong>`TreeSet`</strong> заключается в способе хранения и упорядочивания элементов. <strong>`HashSet` </strong>предлагает более высокую производительность для базовых операций за счёт использования хеш-таблицы, но не гарантирует порядок элементов. <strong>`TreeSet` </strong>обеспечивает упорядоченное хранение элементов и поддерживает дополнительные операции с отсортированными наборами, но операции с элементами выполняются медленнее.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(35,'Что такое исключение','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Исключение</u> &mdash; это событие (обычно ошибочная ситуация), которое прерывает нормальное выполнение инструкций программы. Они используются для обработки ошибок и других исключительных ситуаций в коде, позволяя программе реагировать на них и, если возможно, восстанавливаться после ошибок, вместо того чтобы просто завершаться с ошибкой.</p>\n\n<p><strong>Зачем они нужны?</strong></p>\n\n<p>Предоставляют способ отделить код обработки ошибок от основного потока выполнения программы. Это улучшает читаемость и поддерживаемость кода, позволяя разработчикам организовать обработку ошибок более эффективно. Использование исключений помогает в следующем:</p>\n\n<p><strong>1. Улучшение читаемости кода:</strong> Поскольку обработка ошибок вынесена в отдельные блоки, основной код становится чище и проще для понимания.<br />\n<strong>2. Простота в обработке ошибок: </strong>Позволяют собирать информацию об ошибке и передавать её выше по стеку вызовов, до тех пор, пока не будет найден подходящий обработчик.<br />\n<strong>3. Разделение логики программы и обработки ошибок: </strong>Это помогает избежать смешивания кода программы с проверками на ошибки, делая программу более модульной.</p>\n\n<p><strong>Как они работают?</strong></p>\n\n<p>Делятся на две основные категории: проверяемые (checked) и непроверяемые (unchecked) исключения.&nbsp;</p>\n\n<ul>\n	<li><strong>Проверяемые исключения</strong>&nbsp;являются теми, которые должны явно обрабатываться в программе. Они являются подклассами <strong>`Exception`</strong>, за исключением класса <strong>`RuntimeException`</strong> и его подклассов.&nbsp;</li>\n	<li><strong>Непроверяемые исключения</strong>&nbsp;включают в себя ошибки (<strong>`Error`</strong>) и исключения времени выполнения (<strong>`RuntimeException`</strong>). Они обычно указывают на ошибки программирования, такие как неправильное использование API или попытки обращения к объекту через ссылку<strong> `null`</strong>.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Example {\n    public static void main(String[] args) {\n        try {\n            int result = 10 / 0; // Это вызовет ArithmeticException\n        } catch (ArithmeticException e) {\n            System.out.println(\"Произошла арифметическая ошибка: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Этот блок выполняется всегда после try/catch\");\n        }\n    }\n}</code></pre>\n\n<p>В этом примере деление на ноль вызывает исключение<strong> `ArithmeticException`</strong>, которое затем перехватывается и обрабатывается в блоке<strong> `catch`</strong>. Блок <strong>`finally`</strong> выполняется независимо от того, возникло исключение или нет, предоставляя возможность для выполнения любых необходимых операций по очистке.</p>\n\n<p><u>Исключение</u> &mdash; это механизм для обработки ошибок и других исключительных ситуаций, который позволяет программе реагировать на проблемы и продолжать выполнение, вместо того чтобы полностью останавливаться. Использование исключений делает код более читаемым, упрощает обработку ошибок и помогает отделять основную логику программы от обработки исключительных ситуаций.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(36,'Инкапсуляция',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Инкапсуляция &mdash; это один из четырех основных принципов ООП, наряду с наследованием, полиморфизмом и абстракцией. Она заключается в сокрытии внутренних данных класса от внешнего мира и предоставлении доступа к этим данным только через методы этого класса. Это делается для того, чтобы обеспечить контроль над тем, как внешний мир взаимодействует с внутренним состоянием объекта, а также для того, чтобы изменения в одной части программы не влияли на другие части.</p>\n\n<p><strong>Зачем нужна инкапсуляция?</strong></p>\n\n<p>1. <em><strong>Защита данных:</strong></em> предотвращает непосредственный доступ к внутреннему состоянию объекта, что может помочь избежать некорректного использования или изменения данных.<br />\n2. <em><strong>Гибкость и модифицируемость:</strong></em> изменения в реализации класса (например, изменение типа данных поля) не влияют на код, который использует этот класс, если доступ к полям осуществляется через методы.<br />\n3. <em><strong>Упрощение интерфейса:</strong></em> пользователю класса предоставляются только необходимые для взаимодействия методы, что упрощает использование класса и снижает риск ошибок.</p>\n\n<p><strong>Как реализуется инкапсуляция?</strong></p>\n\n<p>Обычно достигается с помощью модификаторов доступа: <strong>`private`</strong>,<strong> `public`</strong>, <strong>`protected` </strong>и без модификатора (по умолчанию). Самым строгим является <strong>`private`</strong>, который ограничивает доступ к полю или методу так, что обращаться к нему можно только изнутри класса.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Account {\n    private double balance; // Скрытие поля balance\n\n    public Account(double initialBalance) {\n        if (initialBalance &gt; 0) {\n            balance = initialBalance;\n        }\n    }\n\n    // Метод для добавления средств на счет\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        }\n    }\n\n    // Метод для получения текущего баланса\n    public double getBalance() {\n        return balance;\n    }\n}</code></pre>\n\n<p>В этом примере поле <strong>`balance`</strong> сокрыто от прямого доступа извне класса <strong>`Account`</strong>, а взаимодействие с ним происходит через методы<strong> `deposit`</strong> и <strong>`getBalance`</strong>. Это позволяет контролировать корректность данных (например, добавление на счет отрицательной суммы).</p>\n\n<p>Инкапсуляция &mdash; это сокрытие внутренних данных класса и предоставление контролируемого доступа к этим данным через методы класса. Это обеспечивает безопасность данных, упрощает интерфейс и повышает гибкость кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(37,'Что такое ORM',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>ORM (Object-Relational Mapping, объектно-реляционное отображение) &mdash; это техника, используемая для преобразования данных между несовместимыми типами систем, в частности между объектно-ориентированными языками программирования и реляционными базами данных. ORM предоставляет абстрактный API, который позволяет вам работать с базой данных с использованием объектно-ориентированных подходов, вместо того чтобы писать SQL-запросы.</p>\n\n<p><strong>Ключевые принципы ORM:</strong></p>\n\n<p>1. <em><strong>Отображение таблиц данных на классы:</strong> </em>В нем каждая таблица в базе данных обычно отображается на класс в программе. Это позволяет работать с записями таблицы как с объектами указанного класса.</p>\n\n<p>2. <em><strong>Отображение столбцов таблиц на атрибуты класса: </strong></em>Столбцы таблицы в базе данных отображаются на атрибуты класса, что позволяет обращаться к данным записи прямо через свойства объекта.</p>\n\n<p>3. <strong><em>Управление связями между данными:</em> </strong>Автоматически управляет отношениями между данными, такими как один-ко-многим, многие-ко-многим, позволяя разработчикам легко настраивать и использовать связанные данные.</p>\n\n<p>4. <strong><em>Автоматизация запросов к базе данных:</em> </strong>Позволяет выполнять запросы к базе данных, используя методы и функции высокого уровня, автоматически преобразуя их в SQL-запросы и обратно, что сокращает необходимость в ручной работе с SQL.</p>\n\n<p><strong>Преимущества использования:</strong></p>\n\n<ul>\n	<li><em><strong>Продуктивность разработки: </strong></em>Можно сосредоточиться на логике приложения, а не на деталях реализации базы данных.</li>\n	<li><em><strong>Уменьшение количества кода:</strong></em> Генерирует многие стандартные SQL-запросы автоматически, что уменьшает количество необходимого для написания кода.</li>\n	<li><em><strong>Безопасность: </strong></em>Большинство таких фреймворков автоматически обрабатывают проблемы безопасности, такие как SQL-инъекции.</li>\n	<li><em><strong>Переносимость:</strong></em> Запросы, сгенерированные им, могут быть независимы от конкретной СУБД, что упрощает миграцию между разными базами данных.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li><em><strong>Сложность:</strong></em> Может добавить сложность в проект, особенно в случаях, когда требуется настройка производительности или обработка сложных запросов.</li>\n	<li><em><strong>Производительность:</strong></em> В некоторых случаях автоматически генерируемые запросы могут быть менее оптимизированы, чем ручно написанные SQL-запросы.</li>\n</ul>\n\n<p>Примеры популярных ORM фреймворков включают Hibernate, JPA (Java Persistence API), MyBatis и другие. Они обеспечивают разработчикам инструменты для эффективной работы с базой данных в объектно-ориентированном стиле.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(38,'Чем отличается операция map от flatMap','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Операции <strong>`map`</strong> и<strong> `flatMap` </strong>являются важными концепциями в функциональном программировании и широко используются во многих языках программирования, в контексте работы с коллекциями и потоками данных (streams). Хотя обе операции применяют функцию к элементам потока или коллекции, между ними есть ключевые отличия в поведении и результате выполнения.</p>\n\n<p><strong>Операция map</strong></p>\n\n<p>Применяет заданную функцию к каждому элементу коллекции или потока и возвращает новую коллекцию или поток, состоящий из результатов применения этой функции. Важно отметить, что при ее использовании количество элементов во входной и выходной коллекции (или потоке) остается неизменным.</p>\n\n<pre>\n<code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);\nList&lt;Integer&gt; squaredNumbers = numbers.stream()\n                                       .map(n -&gt; n * n)\n                                       .collect(Collectors.toList());\n// squaredNumbers будет содержать [1, 4, 9, 16]</code></pre>\n\n<p><br />\n<strong>Операция flatMap</strong></p>\n\n<p>Также применяет заданную функцию к каждому элементу коллекции или потока, но с одним существенным отличием: ожидается, что функция для каждого элемента вернет поток (или коллекцию) элементов, а<strong> `flatMap`</strong> &quot;сплющивает&quot; все эти потоки (или коллекции) в один поток. Таким образом, его удобно использовать, когда результатом применения функции является коллекция или поток, и вы хотите получить плоский список всех элементов, а не коллекцию коллекций.</p>\n\n<pre>\n<code class=\"language-java\">List&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(\n    Arrays.asList(1, 2),\n    Arrays.asList(3, 4, 5)\n);\nList&lt;Integer&gt; flatList = listOfLists.stream()\n                                    .flatMap(Collection::stream)\n                                    .collect(Collectors.toList());\n// flatList будет содержать [1, 2, 3, 4, 5]</code></pre>\n\n<p><strong>Основные отличия:</strong></p>\n\n<ul>\n	<li><em><strong>Результат:</strong></em> <strong>`map`</strong> преобразует каждый элемент коллекции отдельно и возвращает коллекцию того же размера. <strong>`flatMap` </strong>может преобразовывать каждый элемент в несколько элементов и &quot;сплющивает&quot; результат в одну коллекцию, что может изменить количество элементов в итоговой коллекции.</li>\n	<li><em><strong>Использование:</strong></em><strong> `map`</strong> используется для простых преобразований элементов, а <strong>`flatMap`</strong> &mdash; для преобразований, при которых каждый элемент может быть представлен несколькими элементами в результате.</li>\n</ul>\n\n<p>Выбор между <strong>`map`</strong> и <strong>`flatMap`</strong> зависит от конкретной задачи и желаемой структуры выходных данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(39,'В чем разница между DI и IoC','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Dependency Injection (DI) и Inversion of Control (IoC) &mdash; это два тесно связанных принципа в программировании, особенно в контексте разработки. Хотя эти термины часто используются как взаимозаменяемые, они описывают разные, хотя и взаимосвязанные концепции.</p>\n\n<p><strong>Inversion of Control (IoC)</strong></p>\n\n<p>Это широкий принцип проектирования, при котором управление программой переходит от традиционного выполнения программы к фреймворку или контейнеру. В контексте объектно-ориентированного программирования IoC означает, что объекты не создают или не ищут зависимости (другие объекты) самостоятельно. Вместо этого, какие-то внешние средства (например, фреймворк или контейнер) отвечают за создание этих зависимостей и их предоставление объектам.</p>\n\n<p>Цель &mdash; уменьшить связанность между компонентами программы, делая её более модульной, гибкой и поддерживаемой. IoC достигается различными способами, одним из которых является Dependency Injection.</p>\n\n<p><strong>Dependency Injection (DI)</strong></p>\n\n<p>Это конкретный шаблон реализации IoC, при котором зависимости объекта (например, ссылки на другие объекты) предоставляются ему извне. Он может быть реализован разными способами, включая конструкторы, сеттеры или интерфейсы.</p>\n\n<p>Он упрощает управление зависимостями между объектами, позволяя легко изменять их во время выполнения или для целей тестирования. Благодаря ему, объекты становятся менее зависимыми от конкретных реализаций своих зависимостей и больше ориентированными на интерфейсы.</p>\n\n<p><strong>Основные различия:</strong></p>\n\n<ul>\n	<li><em><strong>IoC</strong></em> &mdash; это более общий принцип, который описывает подход к дизайну, при котором управление программой инвертировано по сравнению с традиционным подходом. IoC можно реализовать разными способами, включая, но не ограничиваясь, Dependency Injection.</li>\n	<li><em><strong>DI</strong></em> &mdash; это метод реализации IoC, который конкретизирует, как зависимости предоставляются объектам. DI является одним из способов достижения принципа IoC.</li>\n</ul>\n\n<p>IoC реализуется через IoC контейнер, который управляет объектами (бинами) и их зависимостями с использованием DI. Это обеспечивает легкость в управлении жизненным циклом объектов и их взаимосвязями, делая приложения легче для разработки, тестирования и поддержки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(40,'Почему синглтон называют антипаттерном','  <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Синглтон (Singleton) часто упоминается как антипаттерн по нескольким причинам, связанным с его использованием и влиянием на дизайн ПО. Хотя он предназначен для обеспечения глобального доступа к единственному экземпляру класса, его применение может привести к различным проблемам:</p>\n\n<p>1. <em><strong>Тестирование:</strong></em> Может затруднять модульное тестирование, поскольку использование глобального состояния означает, что тесты могут влиять друг на друга через изменения его состояния. Это делает тесты менее независимыми и предсказуемыми.</p>\n\n<p>2. <em><strong>Управление зависимостями: </strong></em>Скрывает зависимости классов, использующих его, что затрудняет понимание, тестирование и изменение кода, так как связи между компонентами не являются явными.</p>\n\n<p>3. <em><strong>Гибкость использования: </strong></em>Ограничивает гибкость, так как он фиксирует решение использовать один и только один экземпляр класса. В будущем может возникнуть необходимость в использовании нескольких экземпляров, и изменение синглтона на поддержку этой возможности может быть затруднительным.</p>\n\n<p>4. <em><strong>Многопоточность: </strong></em>В многопоточных приложениях необходимо тщательно управлять созданием единственного его экземпляра, чтобы избежать одновременного создания нескольких экземпляров. Это требует дополнительной синхронизации, которая может снизить производительность.</p>\n\n<p>5. <em><strong>Расширяемость и наследование: </strong></em>Как правило, сложно расширять через наследование, и любые изменения в его реализации могут повлиять на всё приложение.</p>\n\n<p>Из-за этих проблем рекомендуется обдумывать применение синглтона и рассматривать альтернативы, такие как использование паттернов проектирования &quot;Фабрика&quot; (Factory), &quot;Внедрение зависимостей&quot; (Dependency Injection, DI) и &quot;Сервис-локатор&quot; (Service Locator), которые могут предложить большую гибкость, лучшее управление зависимостями и более простое тестирование.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',6),(41,'Hashcode','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Хеш-код</u> &mdash; это целое число, которое возвращается методом<strong> `hashCode()`</strong>, определённым в классе <strong>`Object`</strong>, являющемся родительским для всех классов. Этот метод предназначен для возвращения целочисленного значения, представляющего хеш-код объекта. Он используется для оптимизации хранения и поиска объектов, например, в хеш-таблицах, таких как<strong> `HashMap`</strong>, <strong>`HashSet`</strong>, <strong>`HashTable`</strong>.</p>\n\n<p><strong>Как он работает</strong></p>\n\n<p>Помогает в быстром поиске объектов в коллекциях. Когда объект добавляется в хеш-таблицу, его хеш-код используется для определения того, в каком &quot;сегменте&quot; (или &quot;ячейке&quot;) таблицы он должен быть размещён. При поиске объекта его хеш-код снова вычисляется, чтобы найти, в каком сегменте таблицы он может находиться, что значительно ускоряет процесс поиска по сравнению с последовательным перебором всех элементов.</p>\n\n<p><strong>Важность</strong></p>\n\n<p>Корректная реализация методов <strong>`hashCode()`</strong> и <strong>`equals()` </strong>важна для правильной работы хеш-основанных коллекций. Контракт между<strong> `hashCode()`</strong> и <strong>`equals()` </strong>устанавливает следующие правила:</p>\n\n<p>1. Если два объекта равны согласно методу<strong> `equals(Object)`</strong>, то вызов метода <strong>`hashCode()` </strong>должен возвращать одинаковое целое значение для этих объектов.<br />\n2. Если метод <strong>`hashCode()`</strong> возвращает разные целые значения для двух объектов, это не обязательно означает, что объекты не равны.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Person {\n    private String name;\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n               Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}</code></pre>\n\n<p>В этом примере <strong>`hashCode()`</strong> и<strong> `equals()`</strong> переопределены таким образом, что <strong>`Person` </strong>с одинаковыми <strong>`name`</strong> и <strong>`age` </strong>будет иметь одинаковый хеш-код и считаться равным. Это позволяет использовать объекты <strong>`Person`</strong> в качестве ключей в <strong>`HashMap`</strong> или элементов в<strong> `HashSet` </strong>с ожидаемым поведением.</p>\n\n<p>Метод <strong>`hashCode()`</strong> играет ключевую роль в управлении доступом к объектам в хеш-таблицах. Правильная реализация<strong> `hashCode()` </strong>и <strong>`equals()` </strong>обеспечивает эффективное и корректное использование объектов в качестве ключей в хеш-картах и элементов в множествах.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(42,'Ключевое слово final',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевое слово <strong>`final` </strong>используется для обозначения окончательности: оно может применяться к переменным, методам и классам, придавая им соответствующие свойства неизменяемости, непереопределяемости и ненаследуемости.</p>\n\n<p><strong>Применение к переменным</strong></p>\n\n<p>Это означает, что её значение не может быть изменено после инициализации. В случае примитивных типов данных значение этой переменной будет оставаться неизменным, а в случае ссылочных типов данных нельзя будет изменить ссылку на объект, хотя состояние самого объекта изменить можно (если он не immutable).</p>\n\n<pre>\n<code class=\"language-java\">final int MAX_VALUE = 10;\n// MAX_VALUE = 15; // Это вызовет ошибку компиляции</code></pre>\n\n<p><strong>Применение к методам</strong></p>\n\n<p>ЭЭто означает, что метод не может быть переопределен в подклассах. Это используется для сохранения алгоритма метода от изменений, гарантируя, что поведение метода останется неизменным во всех производных классах.</p>\n\n<pre>\n<code class=\"language-java\">public final void showNumber() {\n    System.out.println(\"Номер\");\n}</code></pre>\n\n<p><strong>Применение к классам</strong></p>\n\n<p>Это означает, что класс не может иметь подклассов. Таким образом, класс будет всегда использоваться в его первоначальном виде, без возможности расширения его функционала через наследование. Это полезно, когда нужно обеспечить безопасность или предотвратить изменения в определенной части кода.</p>\n\n<pre>\n<code class=\"language-java\">public final class MyFinalClass {\n    // Класс не может быть наследован\n}</code></pre>\n\n<p><strong>Почему и когда использовать ?</strong></p>\n\n<p>1. <em><strong>Безопасность:</strong></em> Использование его с переменными может предотвратить непреднамеренное изменение данных.<br />\n2. <em><strong>Проектирование классов и методов:</strong></em> Классы и методы гарантируют, что поведение не будет изменено в производных классах, что может быть важно для сохранения неизменяемости логики программы.<br />\n3. <em><strong>Оптимизация: </strong></em>Компилятор и виртуальная машина Java могут использовать его для оптимизации выполнения программы, поскольку заранее известно, что некоторые вещи не изменятся.</p>\n\n<p>Ключевое слово `final` используется для обозначения неизменяемости переменных, непереопределяемости методов и ненаследуемости классов. Оно помогает улучшить безопасность, проектирование и производительность программ.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(43,'Нормальные формы в SQL','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В теории реляционных БД существует несколько нормальных форм, каждая из которых представляет собой определенный уровень нормализации данных. Она помогает уменьшить избыточность данных и улучшить их структуру, что облегчает их обслуживание и повышает эффективность базы данных. Вот основные нормальные формы:</p>\n\n<p>1. <em><strong>Первая нормальная форма (1NF): </strong></em>Требует, чтобы значения в каждом столбце таблицы были атомарными (неделимыми), и чтобы в таблице был уникальный идентификатор (ключ).</p>\n\n<p>2. <em><strong>Вторая нормальная форма (2NF): </strong></em>Достигается, когда таблица находится в 1NF, и все атрибуты (не ключевые поля) полностью зависят от первичного ключа.</p>\n\n<p>3. <em><strong>Третья нормальная форма (3NF): </strong></em>Таблица должна быть во 2NF, и все её атрибуты должны быть зависимы только от первичного ключа, а не от других не ключевых атрибутов.</p>\n\n<p>4. <em><strong>Нормальная форма Бойса-Кодда (BCNF): </strong></em>Усиление 3NF, требующее, чтобы каждый детерминант был кандидатом в ключи. Это помогает разрешить некоторые проблемы, которые могут оставаться после применения 3NF.</p>\n\n<p>5. <em><strong>Четвертая нормальная форма (4NF):</strong></em> Требует, чтобы таблица была в BCNF и не содержала многозначных зависимостей, кроме зависимостей, обусловленных первичным ключом.</p>\n\n<p>6. <em><strong>Пятая нормальная форма (5NF):</strong></em> Таблица должна быть в 4NF, и все её объединения должны быть без потерь, то есть любые две таблицы, полученные в результате декомпозиции, должны успешно соединяться обратно в исходную таблицу без потери данных.</p>\n\n<p>7. <em><strong>Доменно-ключевая нормальная форма (DKNF):</strong></em> Достигается, когда таблица имеет только ограничения домена и ключей, исключая любые другие виды логических зависимостей.</p>\n\n<p>Существуют и другие, менее известные и редко используемые нормальные формы, такие как шестая нормальная форма (6NF), предназначенная для определенных типов временных баз данных. Однако на практике большинство баз данных нормализуются до третьей или, реже, до четвертой нормальной формы, поскольку дальнейшая нормализация может привести к ухудшению производительности и усложнению структуры базы данных без значительного прироста в эффективности управления данными.<br />\n&nbsp;</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(44,'JOIN SQL',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Существует несколько видов операций соединения (JOIN), которые позволяют объединять строки из двух или более таблиц на основе связанных между ними столбцов. Вот его основные виды:</p>\n\n<p><strong>INNER JOIN</strong></p>\n\n<ul>\n	<li>Возвращает строки, когда существует хотя бы одно совпадение в обеих таблицах. Если в одной из таблиц нет совпадений, строки из этой таблицы не включаются в результат.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nINNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>LEFT JOIN (или LEFT OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает все строки из левой таблицы и совпавшие строки из правой таблицы. Если совпадений в правой таблице нет, результат будет содержать NULL в столбцах правой таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nLEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>RIGHT JOIN (или RIGHT OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает все строки из правой таблицы и совпавшие строки из левой таблицы. Если совпадений в левой таблице нет, результат будет содержать NULL в столбцах левой таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nRIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>FULL JOIN (или FULL OUTER JOIN)</strong></p>\n\n<ul>\n	<li>Возвращает строки, когда существует хотя бы одно совпадение в любой из таблиц. Если нет совпадений, результат будет содержать NULL как в столбцах левой, так и в столбцах правой таблицы для этих строк.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nFULL JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>\n\n<p><strong>CROSS JOIN</strong></p>\n\n<ul>\n	<li>Возвращает декартово произведение всех строк из левой таблицы на все строки из правой таблицы. Этот тип соединения не требует указания условия соединения и может привести к очень большому объему результата, если таблицы содержат много строк.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT Orders.OrderID, Customers.CustomerName\nFROM Orders\nCROSS JOIN Customers;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n\n<ul>\n	<li>Не является отдельным типом, а скорее методикой, при которой таблица соединяется сама с собой, как бы будучи двумя разными таблицами. Это полезно для выполнения операций сравнения внутри одной и той же таблицы.</li>\n</ul>\n\n<pre>\n<code class=\"language-sql\">SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2\nFROM Customers A, Customers B\nWHERE A.CustomerID &lt; B.CustomerID;</code></pre>\n\n<p>Каждый тип JOIN используется в зависимости от требуемых в запросе данных и логики их соединения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(45,'Модификаторы доступа','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Модификаторы доступа</u> &mdash; это ключевые слова, которые устанавливают уровень доступа к классам, методам, конструкторам и переменным. Они определяют, откуда именно можно обращаться к элементам программы, обеспечивая тем самым инкапсуляцию и безопасность данных.</p>\n\n<p>Существует четыре основных модификаторов:</p>\n\n<p>1.<strong> `private`:</strong> Самый строгий уровень доступа. Элементы, объявленные как `private`, доступны только внутри того класса, где они были объявлены.<br />\n&nbsp; &nbsp;<br />\n2. <strong>`default` (без модификатора): </strong>Если модификатор доступа не указан, то элемент доступен всем классам в том же пакете. Вне пакета эти элементы недоступны.<br />\n&nbsp; &nbsp;<br />\n3. <strong>`protected`: </strong>Элементы с модификатором <strong>`protected` </strong>доступны внутри того же пакета, а также в подклассах, даже если они находятся в других пакетах.<br />\n&nbsp; &nbsp;<br />\n4. <strong>`public`:</strong> Элементы, объявленные как <strong>`public`</strong>, доступны из любого места программы.</p>\n\n<p>Применение:</p>\n\n<p>Используются для управления доступом к компонентам класса (полям, методам, конструкторам) и к самим классам. Они помогают скрыть внутреннее состояние объекта и реализацию методов, тем самым обеспечивая инкапсуляцию и сокрытие деталей реализации.&nbsp;</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Example {\n    private int privateVar = 10; // Доступен только внутри класса Example\n    int defaultVar = 20;         // Доступен классам в том же пакете\n    protected int protectedVar = 30; // Доступен в том же пакете и в подклассах\n    public int publicVar = 40;       // Доступен из любого места программы\n}</code></pre>\n\n<p><strong>Зачем они нужны?</strong></p>\n\n<p>Использование их важно по нескольким причинам:</p>\n\n<ul>\n	<li><strong>Инкапсуляция: </strong>Ограничивает доступ к данным и методам класса, позволяя скрыть детали реализации и изменять их без влияния на другие части программы.</li>\n	<li><strong>Безопасность:</strong> Предотвращает непреднамеренный доступ или изменение важных данных программы.</li>\n	<li><strong>Организация кода: </strong>Помогает организовать код, делая его более читаемым и удобным для поддержки.</li>\n</ul>\n\n<p>Модификаторы доступа позволяют контролировать уровень доступа к различным элементам программы, обеспечивая тем самым безопасность, инкапсуляцию и упорядоченность кода. Они играют важную роль в ООП, позволяя создавать более безопасные и легко поддерживаемые приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(46,'Оптимистичная и пессимистичная блокировки','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Оптимистичная и пессимистичная блокировки</u> &mdash; это два подхода к управлению доступом к данным в многопоточных приложениях или в системах управления базами данных (СУБД), где требуется координация доступа к ресурсам для предотвращения конфликтов и обеспечения целостности данных.</p>\n\n<p><strong>Пессимистичная блокировка</strong></p>\n\n<p>Предполагает, что конфликты при доступе к данным вероятны, и применяет стратегии блокировки для предотвращения одновременного изменения данных несколькими потоками или транзакциями. При использовании пессимистичного подхода транзакция блокирует данные в момент их чтения или записи и удерживает блокировку до завершения транзакции, не позволяя другим транзакциям изменять данные до момента освобождения блокировки.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Простота реализации и понимания.</li>\n	<li>Гарантия отсутствия конфликтов при изменении данных.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Высокий риск взаимоблокировок.</li>\n	<li>Ограниченная масштабируемость и производительность из-за длительного удержания блокировок.</li>\n</ul>\n\n<p><strong>Оптимистичная блокировка</strong></p>\n\n<p>Исходит из предположения, что конфликты при доступе к данным случаются редко, и не блокирует данные на время чтения. Вместо этого она позволяет нескольким транзакциям одновременно читать и подготавливать изменения данных, но перед фиксацией изменений проверяет, не были ли изменены данные другими транзакциями с момента последнего чтения. Если данные были изменены, транзакция откатывается и может быть повторена.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Уменьшает вероятность взаимоблокировок.</li>\n	<li>Улучшает масштабируемость и производительность за счет уменьшения времени удержания блокировок.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Сложнее в реализации и может потребовать дополнительных проверок и механизмов отката.</li>\n	<li>Возможность необходимости повторения транзакций, что может увеличить количество работы в системах с высокой конкуренцией.</li>\n</ul>\n\n<p>Выбор между оптимистичной и пессимистичной блокировками зависит от характера приложения, частоты конфликтов при доступе к данным и требований к производительности и масштабируемости. Пессимистичная блокировка подходит для сценариев с высокой конкуренцией за ресурсы, где важно гарантировать целостность данных в каждый момент времени. Оптимистичная блокировка эффективна в системах, где конфликты редки, и предпочтение отдается максимальной производительности и масштабируемости.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',5),(47,'Что такое монитор','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>Монитор</strong>, мьютекс (mutex) &ndash; это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.</p>\n\n<p>Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 &ndash; ресурс свободен. Если не 0 &ndash; ресурс занят. Можно встать в очередь и ждать его освобождения.</p>\n\n<p>В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он так: любой нестатический&nbsp;<code>synchronized</code>-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на&nbsp;<code>this</code>). Если это удалось &ndash; метод исполняется. Если нет &ndash; поток останавливается и ждет, пока монитор будет отпущен.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В контексте многопоточного программирования, монитор &mdash; это механизм синхронизации, который используется для управления доступом к объекту из разных потоков. Каждый объект имеет связанный с ним монитор, который помогает в реализации блоков синхронизации, позволяя контролировать, когда поток может войти в блок кода, изменяющий состояние объекта.</p>\n\n<p><strong>Как он работает?</strong></p>\n\n<p>Когда поток входит в синхронизированный блок кода (обозначенный ключевым словом <strong>`synchronized`</strong>), он захватывает монитор объекта. В это время любой другой поток, который пытается войти в синхронизированный блок кода, использующий тот же монитор, будет заблокирован и вынужден ждать, пока монитор не будет освобождён.</p>\n\n<p>После завершения работы в синхронизированном блоке, поток освобождает монитор, позволяя другим потокам захватить его и войти в синхронизированный блок кода.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>public class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}</code></pre>\n\n<p>В этом примере, методы <strong>`increment`</strong> и<strong> `getCount`</strong> синхронизированы по объекту <strong>`Counter`</strong>. Это означает, что одновременно только один поток может выполнять один из этих методов. Если один поток уже выполняет <strong>`increment`</strong>, другой поток, пытающийся выполнить<strong> `increment`</strong> или <strong>`getCount`</strong>, будет заблокирован до тех пор, пока первый поток не завершит выполнение метода и не освободит монитор объекта.</p>\n\n<p><strong>Почему это важно?</strong></p>\n\n<p>Мониторы важны для обеспечения потокобезопасности, когда несколько потоков работают с общими данными. Без должной синхронизации возможны конфликты и непредсказуемое поведение программы из-за одновременных изменений данных разными потоками. Мониторы помогают предотвратить такие проблемы, гарантируя, что только один поток может изменять данные в один момент времени.</p>\n\n<p><u>Монитор</u> &mdash; это механизм синхронизации, который позволяет управлять доступом к объектам в многопоточной среде, обеспечивая безопасность и целостность данных при их изменении разными потоками. Использование мониторов позволяет разработчикам писать более надежные и потокобезопасные программы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            ',5),(48,'Чем отличается where от having','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`WHERE`</strong> и <strong>`HAVING` </strong>используются для фильтрации записей, но они применяются на разных этапах выполнения запроса и имеют разные цели.</p>\n\n<p><strong>WHERE</strong></p>\n\n<p>Применяется до агрегации данных. Это значит, что фильтрация происходит непосредственно на строках исходной таблицы или результата объединения таблиц, до того как произойдет любая операция группировки (<strong>`GROUP BY`</strong>) или агрегирования (<strong>`SUM`</strong>,<strong> `COUNT`</strong>, <strong>`AVG`</strong> и т.д.).<br />\nИспользуется для фильтрации строк, которые будут включены в результаты группировки или в финальный набор данных, если группировка не используется.<br />\nНе может использоваться для фильтрации агрегированных значений.</p>\n\n<p>Пример использования:</p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nWHERE salary &gt; 1000\nGROUP BY employee_id;</code></pre>\n\n<p>В этом примере он фильтрует строки, где зарплата больше 1000, до того, как произойдет агрегация данных по<strong> `employee_id`</strong>.</p>\n\n<p><strong>HAVING</strong></p>\n\n<p>Применяется после агрегации данных. Это означает, что фильтрация происходит уже на агрегированных результатах, полученных после применения <strong>`GROUP BY` </strong>и агрегатных функций.<br />\nИспользуется для фильтрации групп в результате запроса с группировкой.<br />\nМожет использоваться только с<strong> `GROUP</strong></p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nGROUP BY employee_id\nHAVING SUM(salary) &gt; 10000;</code></pre>\n\n<p><strong>BY`</strong> или для фильтрации результатов, полученных с помощью агрегатных функций.</p>\n\n<p>Пример использования:</p>\n\n<pre>\n<code class=\"language-sql\">SELECT employee_id, SUM(salary)\nFROM salaries\nGROUP BY employee_id\nHAVING SUM(salary) &gt; 10000;</code></pre>\n\n<p>В этом примере он фильтрует группы, где суммарная зарплата по<strong> `employee_id`</strong> больше 10000, после того как данные были сгруппированы и агрегированы.</p>\n\n<p>Основные отличия</p>\n\n<ul>\n	<li><em><strong>Момент применения:</strong></em> <strong>`WHERE`</strong> применяется до агрегации, <strong>`HAVING`</strong> &mdash; после.</li>\n	<li><em><strong>Цель использования:</strong></em> <strong>`WHERE` </strong>фильтрует строки, <strong>`HAVING`</strong> фильтрует группы или агрегированные значения.</li>\n	<li><em><strong>Условия использования:</strong></em> <strong>`WHERE` </strong>может использоваться в любом запросе,<strong> `HAVING` </strong>обычно используется с<strong> `GROUP BY` </strong>или для фильтрации агрегированных значений.</li>\n</ul>\n\n<p>Эти различия делают <strong>`WHERE`</strong> и<strong> `HAVING` </strong>специализированными инструментами для разных этапов и целей фильтрации данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(49,'Что такое hibernate',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Hibernate &mdash; это популярный фреймворк для объектно-реляционного отображения (ORM). Он предоставляет прозрачный слой для маппинга (отображения) объектно-ориентированных моделей данных на традиционные реляционные базы данных. Он облегчает разработку приложений, автоматизируя и скрывая многие сложности, связанные с взаимодействием с базой данных, такие как установление соединения, выполнение SQL-запросов и обработка результатов.</p>\n\n<p><strong>Основные особенности Hibernate:</strong></p>\n\n<p>1. <em><strong>Упрощение разработки:</strong></em> Автоматизирует большую часть кода, который традиционно необходимо писать вручную для работы с базой данных, такого как SQL-запросы и обработка JDBC-результата. Это позволяет разработчикам сосредоточиться на бизнес-логике приложения.</p>\n\n<p>2. <em><strong>Поддержка объектно-реляционного отображения:</strong></em> Предоставляет богатые возможности для маппинга сложных иерархий объектов Java в реляционные таблицы базы данных, включая наследование, композицию, ассоциации (один-к-одному, один-ко-многим, многие-ко-многим).</p>\n\n<p>3. <em><strong>Независимость от базы данных: </strong></em>Обеспечивает независимость от конкретной СУБД, благодаря чему те же самые объектные модели и бизнес-логика могут использоваться с различными базами данных без изменения кода.</p>\n\n<p>4. <em><strong>Кэширование:</strong></em> Предлагает мощные механизмы кэширования первого и второго уровней, что может значительно улучшить производительность приложения за счет уменьшения количества запросов к базе данных.</p>\n\n<p>5. <em><strong>Управление транзакциями и сессиями:</strong></em> Управляет сессиями и транзакциями, обеспечивая гибкость и надежность в обработке данных.</p>\n\n<p>6. <em><strong>HQL и Criteria API:</strong></em> Hibernate Query Language (HQL) &mdash; это объектно-ориентированный язык запросов, аналогичный SQL, но работающий с объектами, а не с таблицами. Criteria API предоставляет программный способ составления запросов через вызовы методов, что делает код более читаемым и безопасным от SQL-инъекций.</p>\n\n<p>7. <em><strong>Аннотации и XML:</strong></em> Позволяет настраивать маппинг как с использованием XML-файлов, так и через аннотации в коде, что упрощает конфигурацию и делает её более наглядной.</p>\n\n<p>Hibernate значительно упрощает разработку Java EE-приложений, автоматизируя рутинную работу по взаимодействию с базой данных и позволяя сосредоточиться на создании сложной логики приложения.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',4),(50,'String pool',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Пул строк (String Pool) &mdash; это специальная область в куче (Heap), предназначенная для хранения уникальных экземпляров строковых литералов. JVM создает пул строк для экономии памяти и увеличения скорости выполнения программы за счет повторного использования объектов типа<strong> `String`</strong>.</p>\n\n<p><strong>Как работает пул строк?</strong></p>\n\n<p>Когда в коде создается строка через строковый литерал (например,<strong> `String s = &quot;Hello&quot;;`</strong>), JVM сначала проверяет пул строк. Если строка с таким же значением уже присутствует в пуле, то новый объект не создается. Вместо этого переменной <strong>`s` </strong>присваивается ссылка на уже существующий объект в пуле. Если же такой строки в пуле нет, JVM создает новый объект строки в пуле и возвращает ссылку на него.</p>\n\n<p>Это поведение отличается от создания строк через оператор<strong> `new`</strong> (например, <strong>`String s = new String(&quot;Hello&quot;);`</strong>). В этом случае в куче всегда создается новый объект <strong>`String`</strong>, независимо от того, содержится ли такая же строка в пуле строк или нет.</p>\n\n<p>Примеры</p>\n\n<pre>\n<code class=\"language-java\">String s1 = \"Hello\"; // Создается в пуле строк, если такой строки еще нет\nString s2 = \"Hello\"; // Не создается новый объект, s2 ссылается на тот же объект, что и s1\nString s3 = new String(\"Hello\"); // Создается новый объект вне пула строк\n\nSystem.out.println(s1 == s2); // true, т.к. s1 и s2 указывают на один и тот же объект в пуле строк\nSystem.out.println(s1 == s3); // false, т.к. s3 указывает на другой объект вне пула строк</code></pre>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p>Помогает оптимизировать использование памяти и повысить производительность приложений:</p>\n\n<ul>\n	<li><em><strong>Экономия памяти:</strong></em> Поскольку строки, созданные как литералы, разделяются и хранятся в пуле, это сокращает общее количество создаваемых объектов <strong>`String`</strong>, экономя память.</li>\n	<li><em><strong>Повышение скорости: </strong></em>Проверка наличия строки в пуле и повторное использование существующих строковых объектов может быть быстрее, чем создание новых объектов.</li>\n</ul>\n\n<p><strong>Как поместить строку в пул строк?</strong></p>\n\n<p>Можно использовать метод<strong> `intern()`</strong> класса<strong> `String`</strong>. Если строка, вызывающая метод <strong>`intern()`</strong>, еще не находится в пуле, то она добавляется туда, а затем возвращается ссылка на эту строку из пула. Если строка уже присутствует в пуле, то просто возвращается ссылка на уже существующую строку.</p>\n\n<p>Пул строк &mdash; это механизм для оптимизации использования памяти и повышения производительности за счет повторного использования уникальных строковых литералов. Он позволяет избежать создания множественных копий одинаковых строковых объектов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(51,'Почему Map стоит особняком в иерархии коллекций','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Интерфейс <strong>`Map` </strong>занимает особое место в иерархии коллекций и, строго говоря, не является частью Collection Framework. Основная причина этого заключается в том, что он работает с парами &quot;ключ-значение&quot;, а не с индивидуальными элементами, как это делают коллекции, такие как <strong>`List`</strong>,<strong> `Set`</strong>, и т.д., которые хранят только объекты.</p>\n\n<p>Основные отличия от других коллекций:</p>\n\n<p>1. <em><strong>Пары ключ-значение:</strong></em> Хранит данные в виде пар &quot;ключ-значение&quot;, где каждый ключ уникален, и каждому ключу соответствует ровно одно значение. В коллекциях, таких как<strong> `List` </strong>или<strong> `Set`</strong>, хранятся только отдельные объекты.</p>\n\n<p>2. <em><strong>Уникальные ключи:</strong></em> В отличие от списков, где элементы могут дублироваться, в нем каждый ключ уникален, и попытка вставить в него новую пару &quot;ключ-значение&quot; с уже существующим ключом приведет к замене старого значения новым.</p>\n\n<p>3. <em><strong>Доступ к элементам: </strong></em>Доступ к его элементам осуществляется по ключу, а не по индексу. В коллекциях, таких как <strong>`List`</strong>, доступ к элементам осуществляется по индексу.</p>\n\n<p>4. <em><strong>Не реализует интерфейс `Collection`: </strong></em>Поскольку он работает с парами &quot;ключ-значение&quot; и имеет уникальные операции и поведение, не совместимые с интерфейсом<strong> `Collection`</strong>, он не включается в иерархию коллекций как его часть.</p>\n\n<p>5. <em><strong>Итерация:</strong> </em>Итерация по нему отличается от итерации по другим коллекциям. Для перебора его элементов можно использовать набор ключей (keySet()), коллекцию значений (values()) или набор пар &quot;ключ-значение&quot; (entrySet()).</p>\n\n<p>6. <em><strong>Функциональность:</strong></em> Предоставляет уникальные методы, такие как<strong> `put()`</strong>, <strong>`get()`</strong>, <strong>`remove()`</strong> по ключу, которые не имеют прямых аналогов в других типах коллекций.</p>\n\n<p>Из-за этих особенностей <strong>`Map`</strong> считается отдельной частью структуры данных, предназначенной для работы с ассоциативными массивами, где каждому ключу соответствует значение. Это делает<strong> `Map`</strong> идеальным инструментом для таких задач, как представление словарей, кэширование объектов и других ситуаций, где необходимо эффективно находить объект по уникальному идентификатору.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',7),(52,'Зачем нужен Spring Framework','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Spring Framework &mdash; это мощный и гибкий фреймворк для разработки приложений. Он предоставляет широкий спектр функциональности, который делает разработку более простой и удобной. Вот основные причины, по которым Spring Framework стал настолько популярен среди разработчиков:</p>\n\n<p>1. <strong>Упрощение разработки</strong></p>\n\n<p>Он упрощает создание сложных приложений, предоставляя шаблоны проектирования и кода для решения общих задач, таких как управление транзакциями, работа с базой данных, обработка веб-запросов и многое другое.</p>\n\n<p>2. <strong>Dependency Injection (DI) и Inversion of Control (IoC)</strong></p>\n\n<p>Он реализует эти принципы через свой IoC контейнер, что упрощает управление зависимостями между объектами. Это позволяет разработчикам создавать более модульные и легко тестируемые приложения.</p>\n\n<p>3. <strong>Обширная поддержка данных</strong></p>\n\n<p>Фреймворк предлагает мощную поддержку для работы с базами данных, включая интеграцию с JPA (Java Persistence API), Hibernate и другими ORM (Object-Relational Mapping) технологиями. Он упрощает доступ к данным и уменьшает количество необходимого бойлерплейта.</p>\n\n<p>4. <strong>Транзакционное управление</strong></p>\n\n<p>Предоставляет декларативное управление транзакциями, позволяя разработчикам легко управлять транзакциями на уровне методов с помощью аннотаций.</p>\n\n<p>5.<strong> Модульность</strong></p>\n\n<p>Состоит из множества модулей, которые можно независимо использовать в зависимости от потребностей проекта. Это делает его легко адаптируемым к любым типам проектов.</p>\n\n<p>6. <strong>Интеграция</strong></p>\n\n<p>Обеспечивает интеграцию с другими фреймворками и библиотеками, такими как JMS (Java Message Service), JMX (Java Management Extensions), электронной почтой, тасками, планированием и многим другим.</p>\n\n<p>7. <strong>Поддержка веб-разработки</strong></p>\n\n<p>MVC (Model-View-Controller) предоставляет платформу для создания веб-приложений на стороне сервера, включая RESTful приложения, обеспечивая гибкость и мощные возможности.</p>\n\n<p>8. <strong>Безопасность</strong></p>\n\n<p>Spring Security предлагает комплексные решения для аутентификации, авторизации, защиты от распространенных атак, таких как сессионный хайджекинг, кросс-сайтовый скриптинг и т.д.</p>\n\n<p>9. <strong>Облачные и микросервисные архитектуры</strong></p>\n\n<p>Spring Boot и Spring Cloud предлагают решения для упрощения разработки микросервисных архитектур и облегчения развертывания приложений в облаке.</p>\n\n<p>Spring Framework снимает множество распространенных проблем, с которыми можно столкнуться, и позволяет сосредоточиться на бизнес-логике приложения, что делает его одним из самых популярных и широко используемых фреймворков для разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(53,'Что такое Spring контекст',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Spring контекст, известный как Spring ApplicationContext, является центральным интерфейсом, обеспечивающим конфигурацию приложения и доступ к его компонентам (бинам). Этот контекст представляет собой расширенную форму IoC (Inversion of Control) контейнера, который управляет инстанцированием, конфигурацией и сборкой бинов в приложении.</p>\n\n<p>Основные функции Spring контекста:</p>\n\n<p>1. <em><strong>Управление бинами: </strong></em>Автоматически создает и управляет жизненным циклом всех бинов, определенных в конфигурации приложения. Эти бины могут быть сконфигурированы через XML, аннотации или Java-конфигурацию.</p>\n\n<p>2. <em><strong>Внедрение зависимостей:</strong></em> Управляет внедрением зависимостей между бинами, позволяя разработчикам создавать более модульные и тестируемые приложения.</p>\n\n<p>3. <em><strong>Предоставление ресурсов:</strong></em> Предоставляет доступ к файловым ресурсам, таким как текстовые и свойства файлы, облегчая их использование в приложении.</p>\n\n<p>4. <em><strong>Поддержка интернационализации:</strong></em> Позволяет использовать ресурсы для локализации, поддерживая мультиязычность в приложении.</p>\n\n<p>5. <em><strong>Публикация событий:</strong></em> Предоставляет возможность публиковать и слушать события в приложении, что позволяет компонентам взаимодействовать между собой асинхронно.</p>\n\n<p>6. <em><strong>Прозрачная работа с технологиями предприятия:</strong></em> Облегчает работу с JNDI, EJB, валидацией, задачами и планированием, а также предоставляет интеграцию с веб-технологиями.</p>\n\n<p>Примеры:</p>\n\n<ul>\n	<li><strong>Через XML конфигурацию:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    &lt;beans&gt;\n        &lt;bean id=\"myBean\" class=\"com.example.MyClass\"/&gt;\n    &lt;/beans&gt;</code></pre>\n\n<ul>\n	<li><strong>Через аннотации:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    @Component\n    public class MyComponent {\n        // Класс, который будет автоматически зарегистрирован как бин\n    }</code></pre>\n\n<ul>\n	<li><strong>Через Java-конфигурацию:</strong></li>\n</ul>\n\n<pre>\n<code class=\"language-java\">    @Configuration\n    public class AppConfig {\n        @Bean\n        public MyBean myBean() {\n            return new MyBean();\n        }\n    }</code></pre>\n\n<p>Запуск:</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nMyClass myClass = ctx.getBean(\"myBean\", MyClass.class);</code></pre>\n\n<p>Или для Java-конфигурации:</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\nMyBean myBean = ctx.getBean(MyBean.class);</code></pre>\n\n<p>Spring контекст играет ключевую роль в разработке приложений, обеспечивая инфраструктурную поддержку и управление зависимостями, что делает разработку проще и более эффективной.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',3),(54,'Что такое итератор и зачем он нужен',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>Итератор</u> &mdash; это объект, который позволяет поочерёдно обходить элементы коллекции без раскрытия её внутреннего представления (структуры). Они используются для работы с различными структурами данных, такими как списки, множества и очереди. Основное предназначение &mdash; предоставить универсальный способ доступа к элементам коллекции, а также возможность их удаления в процессе итерации.</p>\n\n<p><strong>Зачем он нужен?</strong></p>\n\n<p><strong>1. Абстракция: </strong>Скрывает детали реализации коллекции, предоставляя простой интерфейс для её перебора. Это позволяет использовать один и тот же способ обхода для коллекций с различными внутренними структурами.</p>\n\n<p><strong>2. Безопасность:</strong> Использование его для изменения коллекции во время итерации (например, удаление элементов) является безопасным. При попытке модифицировать коллекцию напрямую во время итерации может возникнуть <strong>`ConcurrentModificationException`</strong>, но многие реализации итераторов предоставляют метод <strong>`remove()`</strong>, который позволяет безопасно удалять элементы.</p>\n\n<p><strong>3. Универсальность: </strong>Итераторы предоставляют единый способ работы с различными типами коллекций, что упрощает написание гибкого и переиспользуемого кода.</p>\n\n<p><strong>Как он работает?</strong></p>\n\n<p>Предоставляет как минимум три метода:</p>\n\n<ul>\n	<li><strong>`hasNext()`: </strong>возвращает <strong>`true`</strong>, если итератор имеет ещё элементы.</li>\n	<li><strong>`next()`:</strong> возвращает следующий элемент коллекции и переводит курсор итератора на одну позицию вперёд.</li>\n	<li><strong>`remove()`:</strong> удаляет последний элемент, который был возвращён итератором с помощью метода <strong>`next()`</strong>, из коллекции.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Java\");\nlist.add(\"Python\");\nlist.add(\"C++\");\n\nIterator&lt;String&gt; iterator = list.iterator();\nwhile(iterator.hasNext()) {\n    String element = iterator.next();\n    System.out.println(element);\n    // Можно безопасно удалять элементы с помощью итератора\n    if(\"Python\".equals(element)) {\n        iterator.remove();\n    }\n}</code></pre>\n\n<p><u>Итератор</u> &mdash; это механизм для безопасного и универсального обхода элементов коллекций, позволяющий избежать проблем с изменением коллекции во время итерации и скрывающий внутреннее устройство коллекции. Он необходим для реализации стандартного способа перебора элементов без необходимости знать, как устроена коллекция, и предоставляет безопасный способ её модификации в процессе обхода.</p></p>\n                        \n                        \n                    </div>\n                </div>',7),(55,'Чем rebase отличается от merge?','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`rebase`</strong> и <strong>`merge` </strong>являются двумя различными способами интеграции изменений из одной ветки git в другую. Оба метода используются для синхронизации изменений, но они делают это по-разному и служат разным целям.</p>\n\n<p><strong>Merge (слияние)</strong></p>\n\n<p>Используется для объединения изменений из одной ветки в другую. При выполнении слияния git создает новый коммит, который является &quot;коммитом слияния&quot; и имеет двух родителей &mdash; каждый из родительских коммитов представляет собой последние изменения в каждой из сливаемых веток.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>История коммитов сохраняет время и порядок всех изменений.</li>\n	<li>Коммиты слияния явно указывают на то, что произошло слияние двух веток.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>История коммитов может стать сложной и запутанной из-за большого количества коммитов слияния, особенно в проектах с активной разработкой и многими ветками.</li>\n</ul>\n\n<p><strong>Rebase (перебазирование)</strong></p>\n\n<p>Переносит коммиты из одной ветки на вершину другой ветки, изменяя базовый коммит. Это создает линейную историю, как если бы все изменения были выполнены последовательно, даже если они разрабатывались параллельно.</p>\n\n<p><strong>Преимущества:</strong></p>\n\n<ul>\n	<li>Создает чистую, линейную историю коммитов, что облегчает понимание последовательности изменений.</li>\n	<li>Упрощает процесс обзора истории изменений перед вливанием в основную ветку.</li>\n</ul>\n\n<p><strong>Недостатки:</strong></p>\n\n<ul>\n	<li>Может создать проблемы с сохранностью истории, если он выполняется на коммитах, уже опубликованных в общедоступном репозитории, так как это изменяет историю коммитов.</li>\n	<li>Требует большей осторожности и понимания процесса, поскольку может привести к потере изменений при неправильном использовании.</li>\n</ul>\n\n<p><strong>В чем разница?</strong></p>\n\n<p>Основное отличие между<strong> `merge`</strong> и<strong> `rebase`</strong> заключается в том, как они интегрируют изменения. <strong>`Merge`</strong> сохраняет историю ветвления и слияния, в то время как <strong>`rebase` </strong>создает линейную историю, как если бы все изменения были сделаны последовательно в одной ветке. Выбор между<strong> `merge` </strong>и<strong> `rebase`</strong> зависит от предпочтений команды и требований к управлению историей изменений в проекте.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',2),(56,'Что делает ключевое слово transient',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Ключевое слово<strong> `transient` </strong>используется для указания, что переменная класса не должна быть сериализована. Сериализация &mdash; это процесс преобразования состояния объекта в последовательность байтов для сохранения или передачи данных. Этот процесс используется, например, при сохранении объекта на диск или при передаче объекта по сети. Когда переменная объявлена как<strong> `transient`</strong>, она пропускается механизмом сериализации, и её значение не сохраняется вместе с объектом.</p>\n\n<p><strong>Зачем его использовать:</strong></p>\n\n<p>1. <em><strong>Конфиденциальность данных:</strong></em> Если какие-то данные в объекте являются конфиденциальными или не должны быть сохранены (например, пароли или личная информация), их можно пометить как<strong> `transient`</strong>, чтобы предотвратить их сохранение.</p>\n\n<p>2. <em><strong>Не сериализуемые объекты:</strong></em> Если объект содержит поля, которые не поддерживают сериализацию (например, потоки), эти поля могут быть объявлены как <strong>`transient`</strong>, чтобы обеспечить возможность сериализации остальной части объекта.</p>\n\n<p>3. <em><strong>Экономия места: </strong></em>Исключение ненужных данных из процесса сериализации может сократить объём занимаемого места и ускорить процесс сохранения/загрузки.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">import java.io.*;\n\npublic class User implements Serializable {\n    private String name;\n    private transient String password; // Пароль не будет сериализован\n\n    public User(String name, String password) {\n        this.name = name;\n        this.password = password;\n    }\n\n    // Геттеры и сеттеры\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"username\", \"secretPassword\");\n        \n        // Здесь может быть код для сериализации объекта user\n    }\n}</code></pre>\n\n<p>В этом примере, если объект<strong> `User` </strong>будет сериализован, значение поля <strong>`password` </strong>сохранено не будет из-за модификатора<strong> `transient`</strong>, тогда как<strong> `name`</strong> будет сохранён.</p>\n\n<p>Использование ключевого слова<strong> `transient`</strong> важно для контроля над процессом сериализации, позволяя разработчикам точно определять, какие данные объекта должны быть сериализованы, а какие должны оставаться конфиденциальными или просто не участвовать в сериализации.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(57,'Методе clone','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Метод <strong>`clone()`</strong> используется для создания копии существующего объекта. Он определён в классе<strong> `Object` </strong>и может быть переопределён в пользовательских классах для реализации более глубокого или специфического клонирования, в отличие от поверхностного копирования, предоставляемого реализацией по умолчанию.</p>\n\n<p><strong>Особенности метода:</strong></p>\n\n<ul>\n	<li><em><strong>Поверхностное копирование: </strong></em>Он выполняет поверхностное копирование объекта. Это означает, что копируются только значения примитивных полей и ссылки на объекты, но не сами объекты, на которые эти ссылки указывают. Если объект содержит ссылки на другие объекты, то в копии эти ссылки будут указывать на те же объекты, что и в оригинале.</li>\n	<li><em><strong>Класс должен реализовать интерфейс `Cloneable`: </strong></em>Чтобы объект класса мог быть клонирован с использованием метода <strong>`clone()`</strong>, этот класс должен реализовать интерфейс<strong> `Cloneable`</strong>. Интерфейс<strong> `Cloneable`</strong> не содержит методов и служит маркером, указывающим, что класс разрешает клонирование. Если объект класса, который не реализует <strong>`Cloneable`</strong>, пытается использовать метод <strong>`clone()`</strong>, будет выброшено исключение <strong>`CloneNotSupportedException`</strong>.</li>\n	<li><em><strong>Переопределение метода `clone()`:</strong></em> Для реализации глубокого клонирования или специфической логики клонирования метод <strong>`clone()` </strong>может быть переопределён. При переопределении рекомендуется вызывать <strong>`super.clone()` </strong>для получения объекта, а затем выполнять копирование внутренних объектов или выполнение дополнительных действий.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Sheep implements Cloneable {\n    private String name;\n\n    public Sheep(String name) {\n        this.name = name;\n    }\n\n    // Геттеры и сеттеры\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\npublic class CloneExample {\n    public static void main(String[] args) {\n        Sheep original = new Sheep(\"Dolly\");\n        Sheep copy = null;\n        try {\n            copy = (Sheep) original.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(original != copy); // Выведет true, так как это разные объекты\n        System.out.println(original.getClass() == copy.getClass()); // Выведет true, так как тип один и тот же\n        System.out.println(original.equals(copy)); // Результат зависит от реализации метода equals()\n    }\n}</code></pre>\n\n<p>Метод <strong>`clone()` </strong>позволяет создавать копии объектов, но его использование требует осторожности, особенно при работе с объектами, содержащими ссылки на другие объекты (глубокое и поверхностное клонирование). Необходимость реализации интерфейса<strong> `Cloneable` </strong>и обработки исключения <strong>`CloneNotSupportedException`</strong> делает использование метода <strong>`clone()` </strong>менее удобным по сравнению с другими подходами к клонированию, такими как конструкторы копирования или фабричные методы.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(58,'В чём отличие Supplier\'а от Consumer\'а','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><strong>`Supplier`</strong> и<strong> `Consumer`</strong> являются функциональными интерфейсами, введёнными в Java 8 в рамках Stream API и пакета<strong> `java.util.function`</strong>. Они оба используются в лямбда-выражениях, методах ссылках и потоках данных, но служат разным целям и имеют противоположные действия.</p>\n\n<p><strong>Supplier</strong></p>\n\n<p>Представляет собой функциональный интерфейс, который поставляет результат заданного типа <strong>`T`</strong>. Интерфейс не принимает никаких аргументов, но возвращает значение типа <strong>`T`</strong>. Это может быть полезно, когда вам нужно лениво генерировать или поставлять значения, например, при создании новых объектов или выполнении операций, результат которых необходимо вернуть.</p>\n\n<p><strong>Пример использования Supplier:</strong></p>\n\n<pre>\n<code class=\"language-java\">Supplier&lt;String&gt; stringSupplier = () -&gt; \"Hello, World!\";\nSystem.out.println(stringSupplier.get()); // Выводит \"Hello, World!\"</code></pre>\n\n<p><strong>Consumer</strong></p>\n\n<p>Это функциональный интерфейс, предназначенный для выполнения операции над объектом типа <strong>`T`</strong>. Он принимает один аргумент и не возвращает результат (возвращаемый тип<strong> `void`</strong>). Это полезно, когда вам нужно выполнить какое-либо действие или операцию над объектом, например, напечатать его, изменить его состояние и т.д., без возвращения какого-либо значения.</p>\n\n<p>Пример использования Consumer:</p>\n\n<pre>\n<code class=\"language-java\">Consumer&lt;String&gt; stringConsumer = s -&gt; System.out.println(s);\nstringConsumer.accept(\"Hello, World!\"); // Выводит \"Hello, World!\"</code></pre>\n\n<p>Основное отличие между <strong>`Supplier`</strong> и<strong> `Consumer` </strong>заключается в их назначении и способе работы:</p>\n\n<ul>\n	<li><em><strong>Supplier&nbsp;</strong></em>используется для получения или генерации данных без каких-либо входных параметров. Он &laquo;поставляет&raquo; данные.</li>\n	<li><em><strong>Consumer&nbsp;</strong></em>используется для выполнения операций над данными, которые он принимает в качестве параметров, и не возвращает никакого результата. Он &laquo;потребляет&raquo; данные.</li>\n</ul>\n\n<p><strong>`Supplier`</strong> и<strong> `Consumer`</strong> представляют две разные операции: поставку данных и их потребление соответственно, что делает их важными компонентами для реализации функционального стиля программирования.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(59,'Что такое строка в Java',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Строка представляет собой последовательность символов и является объектом класса <strong>`String`</strong>. Они неизменяемы (immutable), что означает, что однажды созданный объект <strong>`String` </strong>не может быть изменён. Если вам нужно изменить строку, на самом деле создаётся новый объект <strong>`String` </strong>с изменённым содержимым.</p>\n\n<p><strong>Основные особенности строк:</strong></p>\n\n<ul>\n	<li><em><strong>Неизменяемость:</strong></em> Как только она создана, её содержимое не может быть изменено. Любые операции, кажущиеся изменяющими строку, на самом деле создают новый объект <strong>`String`</strong>.</li>\n	<li><em><strong>String Pool:</strong></em> Для экономии памяти использует механизм &quot;пула строк&quot; (String Pool). Это специальная область в куче (Heap), где хранятся все уникальные литералы строк, используемые в программе. Если строка уже существует в пуле, Java использует ту же ссылку, вместо создания нового объекта<strong> `String`</strong>.</li>\n	<li><em><strong>Кодировка: </strong></em>Строки в Java кодируются в UTF-16, где каждый символ (в основном) занимает 2 байта.</li>\n</ul>\n\n<p><strong>Создание строк:</strong></p>\n\n<p>Их можно создавать разными способами, например:</p>\n\n<pre>\n<code class=\"language-java\">String s1 = \"Hello\"; // Создание строки через литерал - строка помещается в пул строк\nString s2 = new String(\"Hello\"); // Явное создание нового объекта строки - не использует пул строк</code></pre>\n\n<p><strong>Работа со строками:</strong></p>\n\n<p>Класс <strong>`String`</strong> предоставляет множество методов для работы со строками, включая поиск подстроки, сравнение строк, преобразование регистра, конкатенацию (слияние строк) и многое другое.</p>\n\n<p>Примеры некоторых операций со строками:</p>\n\n<pre>\n<code class=\"language-java\">String str = \"Java\";\nString upperStr = str.toUpperCase(); // Преобразует все символы в верхний регистр\nboolean startsWithJ = str.startsWith(\"J\"); // Проверяет, начинается ли строка с символа \"J\"\nString combined = str + \" Programming\"; // Конкатенация строк</code></pre>\n\n<p><strong>Важно помнить:</strong></p>\n\n<ul>\n	<li>Использование оператора<strong> `+` </strong>для многократной конкатенации строк в цикле может быть неэффективным по производительности из-за создания множества временных объектов <strong>`String`</strong>. В таких случаях рекомендуется использовать <strong>`StringBuilder` </strong>или<strong> `StringBuffer`</strong>.</li>\n	<li>Для сравнения строк по содержимому следует использовать метод <strong>`equals()`</strong>, а не оператор <strong>`==`</strong>, который сравнивает ссылки на объекты.</li>\n</ul>\n\n<p>Строки &mdash; мощный инструмент для работы с текстовыми данными, поддерживающий широкий спектр операций и обеспечивающий удобство и безопасность использования благодаря своей неизменяемости.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(60,'С чем работает Garbage Collector','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Garbage Collector (GC) работает с управлением памятью в куче (Heap), автоматически освобождая память, занятую объектами, которые больше не используются программой. Он является частью среды выполнения Java (JRE) и играет критическую роль в управлении памятью, делая разработку менее подверженной ошибкам, связанным с утечками памяти и неправильным управлением памятью, типичными для языков программирования, где требуется ручное управление памятью (например, C или C++).</p>\n\n<p><strong>Принцип работы</strong></p>\n\n<p>Осуществляет поиск объектов в куче, на которые нет активных ссылок из доступного программе контекста. Объект считается &quot;доступным для сбора мусора&quot; (eligible for garbage collection), если на него не существует ни одной ссылки из активных частей программы. После определения таких объектов GC автоматически освобождает память, занятую ими, делая её доступной для новых объектов.</p>\n\n<p><strong>Как он работает:</strong></p>\n\n<p>1. <em><strong>Маркировка (Marking): </strong></em>Идентифицирует все объекты, доступные для приложения, начиная с &quot;корней&quot; (root objects), таких как локальные переменные и активные потоки, и отмечает все объекты, до которых можно дойти по ссылкам.</p>\n\n<p>2. <em><strong>Удаление (Sweeping):</strong></em> После маркировки всех достижимых объектов, GC удаляет все недостижимые объекты, тем самым освобождая память.</p>\n\n<p><strong>Стратегии сборки мусора</strong></p>\n\n<p>Существует несколько алгоритмов сборки мусора, каждый из которых имеет свои особенности и оптимизирован под разные типы приложений:</p>\n\n<ul>\n	<li><em><strong>Serial Garbage Collector: </strong></em>Простейший, используется в приложениях с ограниченными ресурсами.</li>\n	<li><em><strong>Parallel Garbage Collector&nbsp;</strong></em>(также известный как Throughput Collector): Использует несколько потоков для ускорения сборки мусора, подходит для многопроцессорных систем.</li>\n	<li><em><strong>Concurrent Mark Sweep (CMS) Garbage Collector: </strong></em>Минимизирует паузы, вызванные сборкой мусора, за счет выполнения большей части работы параллельно с выполнением программы.</li>\n	<li><em><strong>G1 Garbage Collector: </strong></em>Предназначен для систем с большим объемом памяти, позволяет более точно управлять временем пауз, вызванных сборкой мусора.</li>\n</ul>\n\n<p>Garbage Collector обеспечивает автоматическое управление памятью, освобождая от необходимости явно освобождать память от неиспользуемых объектов. Это повышает надежность программ и уменьшает риск ошибок, связанных с управлением памятью. Однако наличие его не исключает необходимости внимательного управления ресурсами, особенно в приложениях с высокими требованиями к производительности и времени отклика.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(61,'В чем идея Stream API',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Идея Stream API заключается в предоставлении мощного и гибкого инструмента для обработки последовательностей данных (коллекций, массивов или любых других источников данных) в декларативном стиле. Он был введен и стал ключевым элементом в поддержке функционального программирования.</p>\n\n<p><strong>Основные концепции:</strong></p>\n\n<p>1. <em><strong>Обработка данных в стиле функционального программирования: </strong></em>Позволяет применять функции к последовательностям данных без изменения исходных данных, что делает код более читабельным, кратким и легко поддерживаемым.</p>\n\n<p>2. <em><strong>Ленивость выполнения:</strong></em> Операции с потоками данных выполняются лениво, то есть вычисления начинаются только тогда, когда это необходимо для получения конечного результата, например, при вызове терминальных операций.</p>\n\n<p>3. <em><strong>Параллелизм: </strong></em>Упрощает параллельную обработку данных, позволяя легко распараллелить выполнение операций над данными для повышения производительности, используя многопоточность.</p>\n\n<p><strong>Ключевые возможности и операции:</strong></p>\n\n<ul>\n	<li><em><strong>Промежуточные операции&nbsp;(Intermediate operations):</strong></em> такие как <strong>`filter()`</strong>,<strong> `map()`</strong>,<strong> `sorted()`</strong>, которые преобразуют поток и возвращают новый поток с результатами для дальнейшей обработки. Эти операции не выполняются немедленно и ожидают вызова терминальной операции.</li>\n	<li><em><strong>Терминальные операции&nbsp;(Terminal operations): </strong></em>такие как <strong>`forEach()`</strong>, <strong>`collect()`</strong>, <strong>`reduce()`</strong>, которые выполняются немедленно и завершают поток, возвращая результат или выполняя некоторое действие с элементами потока.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; strings = Arrays.asList(\"one\", \"two\", \"three\", \"four\");\nList&lt;String&gt; filtered = strings.stream() // Создание потока данных\n    .filter(s -&gt; s.startsWith(\"t\")) // Промежуточная операция: фильтрация\n    .collect(Collectors.toList()); // Терминальная операция: сборка в список\n\nSystem.out.println(filtered); // Вывод: [two, three]</code></pre>\n\n<p>Stream API представляет собой мощный инструмент для обработки коллекций и других форм последовательностей данных, позволяя писать более чистый, выразительный и эффективный код. Благодаря поддержке ленивого выполнения и возможности легкой параллелизации, она является важным инструментом для современной разработки.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(62,'Можно ли переопределить статические методы',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Статические методы не подлежат переопределению в том смысле, в каком обычно используется термин &quot;переопределение&quot; для методов экземпляра. Переопределение подразумевает, что вызов метода на объекте будет определяться типом этого объекта во время выполнения программы. Однако статические методы привязаны к классу, а не к инстанции класса, и выбор конкретного метода для вызова происходит во время компиляции, а не выполнения программы, и основывается на типе переменной, через которую производится вызов.</p>\n\n<p>Тем не менее, статические методы могут быть &quot;скрыты&quot; в подклассах. Если подкласс определяет статический метод с той же сигнатурой, что и статический метод в суперклассе, то метод подкласса &quot;скрывает&quot; метод суперкласса. Это не считается переопределением в строгом смысле, поскольку это не влияет на процесс выбора метода для вызова &mdash; он по-прежнему определяется во время компиляции исходя из типа ссылки, а не типа объекта.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">class Parent {\n    static void test() {\n        System.out.println(\"Метод из Parent\");\n    }\n}\n\nclass Child extends Parent {\n    static void test() {\n        System.out.println(\"Метод из Child\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Parent parent = new Parent();\n        Parent childAsParent = new Child();\n        Child child = new Child();\n\n        parent.test(); // Выводит: Метод из Parent\n        childAsParent.test(); // Выводит: Метод из Parent, несмотря на то, что объект типа Child\n        child.test(); // Выводит: Метод из Child\n    }\n}</code></pre>\n\n<p>В этом примере, несмотря на то что переменная <strong>`childAsParent`</strong> ссылается на объект типа <strong>`Child`</strong>, вызывается статический метод класса <strong>`Parent`</strong>, потому что тип данной переменной &mdash;<strong> `Parent`</strong>, и решение о том, какой метод вызвать, принимается во время компиляции на основе типа переменной.</p>\n\n<p>Хотя статические методы не могут быть переопределены в том же смысле, что и методы экземпляра, они могут быть скрыты в подклассах. Это поведение отличается от переопределения и важно понимать различие, чтобы избежать путаницы при работе с наследованием и статическими методами.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(63,'Какие методы располагаются в интерфейсе','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>В интерфейсе могут располагаться различные типы методов, начиная с Java 8, когда в язык были добавлены новые возможности, такие как default методы и static методы. До Java 8 интерфейсы могли содержать только абстрактные методы. Ниже представлены типы методов, которые могут быть объявлены в интерфейсе:</p>\n\n<p>1. <strong>Абстрактные методы</strong></p>\n\n<p>Это методы без тела, предназначенные для переопределения в классах, которые реализуют интерфейс. Абстрактные методы представляют собой контракт, который должен быть выполнен классом-реализатором. Все методы в интерфейсе неявно являются <strong>`public abstract`</strong>, даже если явно не указаны эти модификаторы.</p>\n\n<pre>\n<code class=\"language-java\">void myMethod();</code></pre>\n\n<p>2. <strong>Default методы (начиная с Java 8)</strong></p>\n\n<p>Позволяют определять реализацию метода непосредственно в интерфейсе. Классы, реализующие интерфейс, могут переопределять эти методы, но это не обязательно. Default методы были введены для обеспечения обратной совместимости, позволяя добавлять новые методы в интерфейсы без нарушения существующих реализаций.</p>\n\n<pre>\n<code class=\"language-java\">default void defaultMethod() {\n    // Реализация\n}</code></pre>\n\n<p>3. <strong>Static методы (начиная с Java 8)</strong></p>\n\n<p>Позволяют определять методы с реализацией, которые могут быть вызваны без создания экземпляра класса, реализующего интерфейс. Эти методы нельзя переопределить в реализующем интерфейс классе.</p>\n\n<pre>\n<code class=\"language-java\">static void staticMethod() {\n    // Реализация\n}</code></pre>\n\n<p>4. <strong>Private методы (начиная с Java 9)</strong></p>\n\n<p>Позволяют определять вспомогательные методы, которые предназначены для использования в default или static методах внутри того же интерфейса. Эти методы не могут быть вызваны извне интерфейса или реализующих его классов.</p>\n\n<pre>\n<code class=\"language-java\">private void privateMethod() {\n    // Реализация\n}</code></pre>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public interface MyInterface {\n    // Абстрактный метод\n    void abstractMethod();\n    \n    // Default метод\n    default void defaultMethod() {\n        System.out.println(\"Default implementation\");\n    }\n    \n    // Static метод\n    static void staticMethod() {\n        System.out.println(\"Static implementation\");\n    }\n    \n    // Private метод (используется внутри интерфейса)\n    private void privateMethod() {\n        System.out.println(\"Private helper method\");\n    }\n}</code></pre>\n\n<p>Интерфейсы могут содержать абстрактные методы, которые обязательны для реализации, а начиная с Java 8, также могут включать default методы с реализацией, static методы, доступные для вызова на уровне интерфейса, и private методы для внутреннего использования. Эти возможности делают интерфейсы более гибкими и мощным.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(64,'try with resourses','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Оператор<strong> `try-with-resources`</strong> &mdash; это конструкция обеспечивает автоматическое управление ресурсами, в частности, автоматическое закрытие ресурсов после их использования. Ресурсом может быть любой объект, который реализует интерфейс <strong>`AutoCloseable`</strong> или <strong>`Closeable`</strong>, например, потоки ввода/вывода (<strong>`InputStream`</strong>,<strong> `OutputStream`</strong>), соединения с базой данных и т.д.</p>\n\n<p><strong>Как работает</strong></p>\n\n<p>Конструкция<strong> `try-with-resources` </strong>автоматически закрывает ресурсы, объявленные в скобках после оператора <strong>`try`</strong>, независимо от того, завершилось ли выполнение блока <strong>`try`</strong> нормально или было выброшено исключение. Это упрощает код и делает его более надежным, поскольку не требуется явно вызывать метод<strong> `close()`</strong> в блоке<strong> `finally`</strong>.</p>\n\n<p><strong>Пример без `try-with-resources`</strong></p>\n\n<p>До Java 7 для закрытия ресурсов требовалось явно использовать блок <strong>`finally`</strong>, чтобы гарантировать закрытие ресурса:</p>\n\n<pre>\n<code class=\"language-java\">InputStream input = null;\ntry {\n    input = new FileInputStream(\"file.txt\");\n    // Чтение из файла\n} catch (IOException ex) {\n    ex.printStackTrace();\n} finally {\n    if (input != null) {\n        try {\n            input.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n\n<p><strong>Пример с `try-with-resources`</strong></p>\n\n<p>С Java 7 и новее можно использовать его для упрощения кода:</p>\n\n<pre>\n<code class=\"language-java\">try (InputStream input = new FileInputStream(\"file.txt\")) {\n    // Чтение из файла\n} catch (IOException ex) {\n    ex.printStackTrace();\n}</code></pre>\n\n<p>В этом примере ресурс <strong>`InputStream`</strong> будет автоматически закрыт после выполнения блока<strong> `try`</strong>, даже если в процессе чтения файла будет выброшено исключение. Это сокращает код и делает его более читабельным и безопасным, поскольку уменьшает риск утечки ресурсов.</p>\n\n<p><strong>Преимущества `try-with-resources`</strong></p>\n\n<p>1. <em><strong>Автоматическое закрытие ресурсов:</strong></em> Гарантирует, что каждый ресурс будет закрыт после использования, что помогает предотвратить утечки ресурсов.<br />\n2. <em><strong>Упрощение кода:</strong></em> Уменьшает объем кода, необходимого для закрытия ресурсов, и повышает его читабельность.<br />\n3. <em><strong>Улучшение управления исключениями: </strong></em>Позволяет более эффективно управлять исключениями, связанными с работой ресурсов.</p>\n\n<p>Оператор <strong>`try-with-resources` </strong>упрощает работу с ресурсами, автоматизируя их закрытие и уменьшая риск возникновения ошибок, связанных с неправильным управлением ресурсами. Это делает код более надежным и читабельным.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(65,'Может ли примитивный тип данных попасть в кучу','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Примитивные типы данных обычно хранятся на стеке (Stack), когда они определены как локальные переменные внутри методов или как часть вызова метода. Однако, примитивные типы могут &quot;попасть&quot; в кучу (Heap), когда они используются как часть объекта или обёрнуты в обёрточные классы (<strong>`Integer`</strong>, <strong>`Long`</strong>, <strong>`Double` </strong>и т.д.), которые являются объектами и хранятся в куче.</p>\n\n<p><strong>Обёртки примитивных типов</strong></p>\n\n<p>Предоставляет обёрточные классы для каждого примитивного типа, позволяя использовать примитивные значения как объекты. Например,<strong> `int`</strong> можно обернуть в <strong>`Integer`</strong>,<strong> `double`</strong> в <strong>`Double`</strong> и так далее. Когда примитивный тип данных обёрнут в такой класс, он может храниться в куче как часть объекта.</p>\n\n<p><strong>Примитивные типы как часть объектов</strong></p>\n\n<p>Когда он используется как поле объекта, само значение примитива будет храниться в куче вместе с остальной частью объекта. Например, если у вас есть класс<strong> `Person`</strong> с полем<strong> `int age`</strong>, то значение <strong>`age`</strong> будет храниться в куче вместе с объектом <strong>`Person`</strong>.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code class=\"language-java\">public class Person {\n    int age; // Примитивный тип данных внутри объекта, хранящегося в куче\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Integer number = 5; // Обёрнутый примитивный тип, хранящийся в куче\n        Person person = new Person(); // Объект, хранящийся в куче, с примитивным полем\n        person.age = 25; // Примитивное значение age хранится в куче вместе с объектом person\n    }\n}</code></pre>\n\n<p>В этом примере<strong> `number`</strong> (обёрнутый<strong> `int`</strong>) и<strong> `person`</strong> (объект с примитивным полем <strong>`age`</strong>) хранятся в куче.</p>\n\n<p>Хотя примитивные типы данных обычно ассоциируются с хранением на стеке, они могут храниться в куче, если являются частью объекта или обёрнуты в соответствующие обёрточные классы. Это позволяет примитивным типам участвовать в динамическом управлении памятью и объектно-ориентированных структурах данных, сохраняя при этом эффективность работы с данными.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(66,'Что такое Parallel Stream','<div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Parallel Stream является частью Java Stream API, который представлен. Это мощное средство для выполнения параллельной обработки данных, позволяя разработчикам легко писать многопоточный код. Он использует ForkJoinPool, который по умолчанию создаёт столько рабочих потоков, сколько у вас ядер процессора, для разделения задачи на подзадачи и их параллельной обработки, а затем объединения результатов. Это позволяет значительно ускорить выполнение операций с большими объёмами данных за счёт распараллеливания вычислений.</p>\n\n<p><strong>Как он работает</strong></p>\n\n<p>Когда вы вызываете метод<strong> `parallelStream()`</strong> на коллекции или используете метод<strong> `parallel()` </strong>на потоке данных, Java автоматически старается распараллелить выполнение операций над этим потоком данных. Однако степень ускорения, которую можно получить, сильно зависит от количества данных, типа выполняемых операций и доступных системных ресурсов.</p>\n\n<p>Пример:</p>\n\n<pre>\n<code>```java\nList&lt;String&gt; strings = Arrays.asList(\"one\", \"two\", \"three\", \"four\");\nList&lt;String&gt; result = strings.parallelStream()\n                             .map(String::toUpperCase)\n                             .collect(Collectors.toList());\n```</code></pre>\n\n<p>В этом примере <strong>`parallelStream()`</strong> используется для создания параллельного потока из списка строк, каждая строка преобразуется в верхний регистр с помощью метода <strong>`map`</strong>, а результат собирается обратно в список.</p>\n\n<p><strong>Важные моменты:</strong></p>\n\n<ul>\n	<li><strong>Не всегда быстрее:</strong> Параллельная обработка не всегда быстрее последовательной из-за накладных расходов на разделение данных на части и их последующее слияние. Для небольших объёмов данных или операций с низкой вычислительной сложностью использование параллельных потоков может даже ухудшить производительность.</li>\n	<li><strong>Побочные эффекты: </strong>При использовании параллельных потоков следует избегать операций, имеющих побочные эффекты (например, изменение состояния внешних переменных), так как это может привести к непредсказуемому поведению.</li>\n	<li><strong>Порядок выполнения:</strong> Порядок выполнения операций в параллельных потоках не гарантируется, что может быть важно для некоторых операций, зависящих от порядка обработки элементов.</li>\n</ul>\n\n<p><u>Parallel Stream</u> &mdash; это мощный инструмент для ускорения обработки больших объёмов данных за счёт параллельного выполнения операций. Однако его эффективность зависит от множества факторов, и его использование требует понимания особенностей параллельной обработки данных.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(67,'JVM, JDK, JRE',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>JVM (Java Virtual Machine), JDK (Java Development Kit) и JRE (Java Runtime Environment)</u> &mdash; это три основных компонента экосистемы, каждый из которых играет свою роль в разработке, выполнении и распространении приложений.</p>\n\n<p><strong>JVM (Java Virtual Machine)</strong></p>\n\n<p>Это виртуальная машина, которая выполняет байт-код. Байт-код &mdash; это промежуточное представление кода, которое получается после компиляции исходного кода. JVM делает Java платформенно независимым языком, поскольку позволяет запускать программы на любой операционной системе, для которой существует соответствующая реализация . Главная задача &mdash; обеспечить исполнение приложений с высокой производительностью и безопасностью, предоставляя при этом управление памятью, сборку мусора и другие службы выполнения.</p>\n\n<p><strong>JRE (Java Runtime Environment)</strong></p>\n\n<p>Включает в себя JVM и библиотеки классов Java, необходимые для выполнения приложений. Он представляет собой минимально необходимый набор инструментов для запуска Java-приложений, но не содержит инструменты для разработки, такие как компилятор или отладчик. Он предназначен для конечных пользователей, которым нужно только запускать Java-приложения без разработки собственного кода.</p>\n\n<p><strong>JDK (Java Development Kit)</strong></p>\n\n<p>Является полным набором инструментов и включает в себя JRE, компилятор Java (javac), средства для упаковки и развертывания приложений (jar), документацию, примеры и другие утилиты, необходимые для разработки приложений. Он позволяет программистам компилировать и тестировать свои приложения перед их запуском на JRE.</p>\n\n<p>Взаимосвязь между ними</p>\n\n<ul>\n	<li><strong>JVM&nbsp;</strong>является сердцем Java, поскольку обеспечивает выполнение байт-кода на любой платформе.</li>\n	<li><strong>JRE&nbsp;</strong>содержит JVM и библиотеки классов, необходимые для выполнения Java-приложений.</li>\n	<li><strong>JDK&nbsp;</strong>включает в себя JRE и дополнительные инструменты, необходимые для разработки и тестирования Java-приложений.</li>\n</ul>\n\n<p>В совокупности, JVM, JRE и JDK образуют полную экосистему для разработки, тестирования и запуска приложений, обеспечивая платформенную независимость, высокую производительность и безопасность исполнения кода.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',1),(68,'Преимущества и недостатки ООП',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Преимущества:</p>\n\n<ul>\n	<li>Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.</li>\n	<li>Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.</li>\n	<li>Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.</li>\n	<li>Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.</li>\n	<li>Возможность создавать расширяемые системы.</li>\n	<li>Использование полиморфизма оказывается полезным при:\n	<ul>\n		<li>Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.</li>\n		<li>Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.</li>\n		<li>Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.</li>\n		<li>Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.</li>\n	</ul>\n	</li>\n	<li>Повторное использование кода:\n	<ul>\n		<li>Сокращается время на разработку, которое может быть отдано другим задачам.</li>\n		<li>Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.</li>\n		<li>Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.</li>\n		<li>Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>Недостатки:</p>\n\n<ul>\n	<li>В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.</li>\n	<li>Код для обработки сообщения иногда &laquo;размазан&raquo; по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).</li>\n	<li>Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.</li>\n	<li>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).</li>\n	<li>Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.</li>\n</ul></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p>Объектно-ориентированное программирование (ООП), процедурное и функциональное программирование &mdash; три основных парадигмы программирования, каждая из которых имеет свои преимущества и недостатки. Понимание этих различий помогает выбрать наиболее подходящий подход для конкретного проекта или задачи.</p>\n\n<p><strong>Объектно-ориентированное программирование (ООП)</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Модульность: </strong>Облегчает разбиение программы на небольшие, управляемые части (классы и объекты), что упрощает разработку и тестирование.<br />\n<strong>2. Повторное использование кода: </strong>Наследование позволяет создавать новые классы на основе существующих, что способствует повторному использованию кода.<br />\n<strong>3. Скрытие данных: </strong>Инкапсуляция позволяет скрыть детали реализации класса и предотвращает непреднамеренное изменение данных.<br />\n<strong>4. Расширяемость: </strong>Полиморфизм и наследование обеспечивают гибкость в добавлении новой функциональности и модификации существующей без изменения существующего кода.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Сложность: </strong>Может вносить дополнительную сложность в проектирование и реализацию программы.<br />\n<strong>2. Производительность: </strong>Создание объектов и выполнение методов может потреблять больше времени и памяти, чем в процедурном программировании.<br />\n<strong>3. Кривая обучения: </strong>Освоение принципов ООП и их эффективное применение может потребовать значительного времени и опыта.</p>\n\n<p><strong>Процедурное</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Простота: </strong>Легче понять и использовать для начинающих программистов, поскольку оно следует прямолинейной логике выполнения программы.<br />\n<strong>2. Производительность: </strong>Программы, написанные в процедурном стиле, могут быть более быстрыми и эффективными по памяти, так как они напрямую управляют структурами данных и операциями.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Трудности в управлении сложными программами: </strong>Может стать трудно управляемым при работе с большими и сложными программами.<br />\n<strong>2. Ограниченное повторное использование кода: </strong>Отсутствие наследования и инкапсуляции затрудняет повторное использование кода.</p>\n\n<p><strong>Функциональное</strong></p>\n\n<p><strong>Преимущества:</strong></p>\n\n<p><strong>1. Непеременность данных: </strong>Использует неизменяемые данные, что упрощает разработку конкурентных программ и повышает их надежность.<br />\n<strong>2. Повторное использование кода: </strong>Функции высшего порядка и функции как объекты первого класса облегчают создание выразительных и модульных программ.<br />\n<strong>3. Простота тестирования: </strong>Функции в нем легко тестировать изолированно благодаря отсутствию побочных эффектов.</p>\n\n<p><strong>Недостатки:</strong></p>\n\n<p><strong>1. Кривая обучения: </strong>Концепции, такие как чистые функции, рекурсия и монады, могут быть непривычными и сложными для понимания новичками.<br />\n<strong>2. Производительность: </strong>Интенсивное использование рекурсии и создание большого количества временных неизменяемых структур данных может привести к снижению производительности в некоторых случаях.</p>\n\n<p>Выбор между ООП, процедурным и функциональным программированием зависит от конкретных требований проекта, предпочтений и специфики задач, которые предстоит решить. Каждый из этих подходов имеет свои сильные и слабые стороны, и в некоторых проектах может быть целесообразным комбинировать их для достижения оптимальных результатов.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',0),(69,'Что такое mock в тестирование',' <div class=\"row\">\n                <div class=\"card mb-3 col\" >\n                    <div class=\"card-body\">\n                        <p class=\"card-text\"><p><u>&quot;mock&quot; (подделка, макет)</u> &mdash; это объект, который имитирует поведение реального компонента в контролируемом окружении. Такие объекты часто используются в модульном тестировании для имитации взаимодействия между компонентами программы, позволяя тестировать каждый компонент изолированно от остальных. Это особенно полезно в ситуациях, когда реальные объекты трудно настроить, они медленно работают или их использование в тестах может привести к нежелательным побочным эффектам (например, изменение данных в базе данных).</p>\n\n<p>Ключевые аспекты:</p>\n\n<ul>\n	<li><strong>Изоляция тестируемого компонента: </strong>Объекты позволяют изолировать тестируемый компонент от его зависимостей, что обеспечивает точность тестирования и помогает точно определить причины возникновения ошибок.</li>\n	<li><strong>Контроль взаимодействий: </strong>С помощью него объектов можно точно определить, как тестируемый компонент взаимодействует с его зависимостями, включая проверку вызовов методов, передачу аргументов и возвращаемые значения.</li>\n	<li><strong>Тестирование в различных сценариях: </strong>Объекты позволяют легко настраивать различные условия тестирования, например, имитируя различные ситуации ошибок или исключительных состояний, которые могут быть трудно воспроизвести с реальными объектами.</li>\n	<li><strong>Ускорение тестирования: </strong>Поскольку такие объекты имитируют только необходимые аспекты реальных объектов, они могут существенно ускорить выполнение тестов по сравнению с использованием реальных компонентов, особенно если последние медленно работают или требуют сложной настройки.</li>\n</ul>\n\n<p>Пример:</p>\n\n<pre>\n<code>```java\nimport static org.mockito.Mockito.*;\n\npublic class SomeTest {\n    @Test\n    public void testSomeMethod() {\n        // Создание mock объекта\n        MyDependency myMock = mock(MyDependency.class);\n        \n        // Настройка поведения mock объекта\n        when(myMock.someMethod()).thenReturn(\"expected value\");\n        \n        // Создание экземпляра тестируемого класса с mock зависимостью\n        MyClass myClass = new MyClass(myMock);\n        \n        // Вызов тестируемого метода\n        String result = myClass.useDependency();\n        \n        // Проверка результата\n        assertEquals(\"expected value\", result);\n        \n        // Проверка взаимодействия с mock объектом\n        verify(myMock).someMethod();\n    }\n}\n```</code></pre>\n\n<p>В этом примере используется mock объект для зависимости<strong> `MyDependency`</strong> класса <strong>`MyClass`</strong>, что позволяет тестировать поведение<strong> `MyClass` </strong>в изоляции от реализации <strong>`MyDependency`</strong>, предоставляя при этом контролируемое окружение для проверки взаимодействий и результатов выполнения.</p>\n\n<p>Mock объекты являются важным инструментом при написании модульных тестов. Они облегчают тестирование, позволяя точно и изолированно проверять поведение компонентов программы в различных сценариях.</p></p>\n                        \n                        \n                    </div>\n                </div>\n            </div>',8),(70,'Физическая и логическая транзакция','<h1>Разница между физической и логической транзакцией</h1>\n    \n    <h2>Физическая транзакция</h2>\n    <p>\n        <strong>Физическая транзакция</strong> относится к реальному обмену данными между системой и внешним миром. Это может быть, например, запись данных на диск, чтение данных из базы данных или передача данных по сети. Физические транзакции связаны с аппаратными ресурсами и их использованием.\n    </p>\n    <ul>\n        <li>Пример: Запись данных на жесткий диск.</li>\n        <li>Характеристики: Зависит от физических ограничений оборудования (скорость диска, пропускная способность сети и т.д.).</li>\n    </ul>\n\n    <h2>Логическая транзакция</h2>\n    <p>\n        <strong>Логическая транзакция</strong> — это абстрактное понятие, которое описывает набор операций, выполняемых как единое целое. Логические транзакции обеспечивают целостность данных и их согласованность. Они не зависят от физической реализации и могут включать в себя несколько физических транзакций.\n    </p>\n    <ul>\n        <li>Пример: Перевод денег с одного счета на другой в банковской системе.</li>\n        <li>Характеристики: Обеспечивает атомарность, согласованность, изолированность и долговечность (ACID).</li>\n    </ul>\n\n    <h2>Основные отличия</h2>\n    <table border=\"1\">\n        <tr>\n            <th>Аспект</th>\n            <th>Физическая транзакция</th>\n            <th>Логическая транзакция</th>\n        </tr>\n        <tr>\n            <td>Определение</td>\n            <td>Реальный обмен данными с физическими устройствами.</td>\n            <td>Абстрактный набор операций, выполняемых как единое целое.</td>\n        </tr>\n        <tr>\n            <td>Зависимость</td>\n            <td>Зависит от аппаратных ресурсов.</td>\n            <td>Не зависит от физической реализации.</td>\n        </tr>\n        <tr>\n            <td>Пример</td>\n            <td>Запись данных на диск.</td>\n            <td>Перевод денег между счетами.</td>\n        </tr>\n        <tr>\n            <td>Цель</td>\n            <td>Обеспечение физического взаимодействия с данными.</td>\n            <td>Обеспечение целостности и согласованности данных.</td>\n        </tr>\n    </table>',4);
/*!40000 ALTER TABLE `topic` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-02-02 21:32:05
